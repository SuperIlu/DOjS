<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head><title>
Allegro Manual
</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" title="Default" type="text/css" href="allegro.css"></head><body bgcolor=white text=black link="#0000ee" alink="#ff0000" vlink="#551a8b">
<pre>
     ______   ___    ___
    /\  _  \ /\_ \  /\_ \
    \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
     \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ <tt>`\/\`'</tt>__\/ __`\
      \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
       \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
        \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
                                       /\____/
                                       \_/__/     Version 4.2.2


                A game programming library.

             By Shawn Hargreaves, Jul 22, 2007.

                See the <a href="thanks.html">AUTHORS</a> file for a
               complete list of contributors.
</pre>



<p><br>
#include &lt;std_disclaimer.h&gt;
<blockquote class="text"><i>
   "I do not accept responsibility for any effects, adverse or otherwise, 
    that this code may have on you, your computer, your sanity, your dog, 
    and anything else that you can think of. Use it at your own risk."
</i></blockquote>


<p><br>
<h1><a name="Contents">Contents</a></h1>

<p>
<ul>
<li><a href="readme.html">A general introduction to Allegro</a>
</ul><p>API</p><ul>
<li><a href="#Using Allegro">Using Allegro</a>
<li><a href="#Structures and types defined by Allegro">Structures and types defined by Allegro</a>
<li><a href="#Unicode routines">Unicode routines</a>
<li><a href="#Configuration routines">Configuration routines</a>
<li><a href="#Mouse routines">Mouse routines</a>
<li><a href="#Timer routines">Timer routines</a>
<li><a href="#Keyboard routines">Keyboard routines</a>
<li><a href="#Joystick routines">Joystick routines</a>
<li><a href="#Graphics modes">Graphics modes</a>
<li><a href="#Bitmap objects">Bitmap objects</a>
<li><a href="#Loading image files">Loading image files</a>
<li><a href="#Palette routines">Palette routines</a>
<li><a href="#Truecolor pixel formats">Truecolor pixel formats</a>
<li><a href="#Drawing primitives">Drawing primitives</a>
<li><a href="#Blitting and sprites">Blitting and sprites</a>
<li><a href="#RLE sprites">RLE sprites</a>
<li><a href="#Compiled sprites">Compiled sprites</a>
<li><a href="#Fonts">Fonts</a>
<li><a href="#Text output">Text output</a>
<li><a href="#Polygon rendering">Polygon rendering</a>
<li><a href="#Transparency and patterned drawing">Transparency and patterned drawing</a>
<li><a href="#Converting between color formats">Converting between color formats</a>
<li><a href="#Direct access to video memory">Direct access to video memory</a>
<li><a href="#FLIC routines">FLIC routines</a>
<li><a href="#Sound init routines">Sound init routines</a>
<li><a href="#Mixer routines">Mixer routines</a>
<li><a href="#Digital sample routines">Digital sample routines</a>
<li><a href="#Music routines (MIDI)">Music routines (MIDI)</a>
<li><a href="#Audio stream routines">Audio stream routines</a>
<li><a href="#Recording routines">Recording routines</a>
<li><a href="#File and compression routines">File and compression routines</a>
<li><a href="#Datafile routines">Datafile routines</a>
<li><a href="#Fixed point math routines">Fixed point math routines</a>
<li><a href="#3D math routines">3D math routines</a>
<li><a href="#Quaternion math routines">Quaternion math routines</a>
<li><a href="#GUI routines">GUI routines</a>
</ul><p>Platform specifics</p><ul>
<li><a href="#DOS specifics">DOS specifics</a>
<li><a href="#Windows specifics">Windows specifics</a>
<li><a href="#Unix specifics">Unix specifics</a>
<li><a href="#BeOS specifics">BeOS specifics</a>
<li><a href="#QNX specifics">QNX specifics</a>
<li><a href="#MacOS X specifics">MacOS X specifics</a>
<li><a href="#Differences between platforms">Differences between platforms</a>
</ul><p>Miscellaneous</p><ul>
<li><a href="#Reducing your executable size">Reducing your executable size</a>
<li><a href="#Debugging">Debugging</a>
<li><a href="#Makefile targets">Makefile targets</a>
<li><a href="#Available Allegro examples">Available Allegro examples</a>
<li><a href="changes.html">Changes since previous versions</a>
<li><a href="thanks.html">Contributors: The Hall of Fame</a>
<li><a href="faq.html">Frequently asked questions (FAQ)</a>
<li><a href="mistakes.html">Common mistakes</a>
<li><a href="help.html">Help: what to do when your Allegro program doesn't work</a>
<li><a href="api.html">API compatibility information</a>
<li><a href="abi.html">ABI compatibility information</a>
<li><a href="ahack.html">The Allegro hacker's guide</a>
<li><a href="const.html">Allegro <tt>`const'</tt>-correctness</a>
<li><a href="packfile.html">Packfile format information</a>
<li><a href="datafile.html">Datafile format information</a>
<li><a href="license.html">License and Disclaimer</a>
</ul><p>Tools</p><ul>
<li><a href="makedoc.html">makedoc - Generate documentation in various formats</a>
<li><a href="grabber.html">grabber - Create datafiles</a>
<li><a href="dat.html">dat - Manipulate datafiles from the command line</a>
<li><a href="dat2s.html">dat2s - Compile datafiles into assembler code</a>
<li><a href="dat2c.html">dat2c - Compile datafiles into C code</a>
</ul><ul>
<li><a href="#Community">Community</a>
<li><a href="#Conclusion">Conclusion</a>
<li><a href="#Index">Index</a>
</ul>
<ul>
<li><a href="#Using Allegro">Using Allegro</a>
<ul>
<li><a href="#AL_ID">AL_ID</a> &mdash; Converts four 8 bit values to a packed 32 bit integer ID.
<li><a href="#ALLEGRO_DATE">ALLEGRO_DATE</a> &mdash; Defined to a number with the release date of Allegro.
<li><a href="#ALLEGRO_DATE_STR">ALLEGRO_DATE_STR</a> &mdash; Defined to a string with the year Allegro was released.
<li><a href="#allegro_error">allegro_error</a> &mdash; Stores the last Allegro error message.
<li><a href="#allegro_exit">allegro_exit</a> &mdash; Closes down the Allegro system.
<li><a href="#allegro_id">allegro_id</a> &mdash; String containing date and version number of Allegro.
<li><a href="#allegro_init">allegro_init</a> &mdash; Macro to initialise the Allegro library.
<li><a href="#allegro_message">allegro_message</a> &mdash; Used mainly to show error messages to users.
<li><a href="#ALLEGRO_SUB_VERSION">ALLEGRO_SUB_VERSION</a> &mdash; Defined to the middle version of Allegro.
<li><a href="#ALLEGRO_VERSION">ALLEGRO_VERSION</a> &mdash; Defined to the major version of Allegro.
<li><a href="#ALLEGRO_VERSION_STR">ALLEGRO_VERSION_STR</a> &mdash; Defined to a string with the full Allegro version number.
<li><a href="#ALLEGRO_WIP_VERSION">ALLEGRO_WIP_VERSION</a> &mdash; Defined to the minor version of Allegro.
<li><a href="#check_cpu">check_cpu</a> &mdash; Detects the CPU type.
<li><a href="#cpu_capabilities">cpu_capabilities</a> &mdash; Contains the capability flags of the CPU.
<li><a href="#cpu_family">cpu_family</a> &mdash; Contains the CPU type.
<li><a href="#cpu_model">cpu_model</a> &mdash; Contains the Intel CPU submodel.
<li><a href="#cpu_vendor">cpu_vendor</a> &mdash; Contains the CPU vendor name.
<li><a href="#desktop_color_depth">desktop_color_depth</a> &mdash; Finds out the desktop color depth.
<li><a href="#END_OF_MAIN">END_OF_MAIN</a> &mdash; Macro to put after your main() function.
<li><a href="#get_desktop_resolution">get_desktop_resolution</a> &mdash; Finds out the desktop resolution.
<li><a href="#install_allegro">install_allegro</a> &mdash; Initialise the Allegro library.
<li><a href="#MAKE_VERSION">MAKE_VERSION</a> &mdash; Create a 32 bit integer from the Allegro version
<li><a href="#os_multitasking">os_multitasking</a> &mdash; Indicates if the OS is multitasking.
<li><a href="#os_revision">os_revision</a> &mdash; Version of the OS currently running.
<li><a href="#os_type">os_type</a> &mdash; Stores the detected type of the OS.
<li><a href="#os_version">os_version</a> &mdash; Version of the OS currently running.
<li><a href="#set_close_button_callback">set_close_button_callback</a> &mdash; Handles the user clicking on the close button of the window.
<li><a href="#set_window_title">set_window_title</a> &mdash; Sets the window title of the Allegro program.
</ul>
<li><a href="#Structures and types defined by Allegro">Structures and types defined by Allegro</a>
<ul>
<li><a href="#al_ffblk">al_ffblk</a> &mdash; Cross platform structure storing file information.
<li><a href="#AUDIOSTREAM">AUDIOSTREAM</a> &mdash; Stores an audiostream.
<li><a href="#BITMAP">BITMAP</a> &mdash; Stores the contents of a bitmap.
<li><a href="#COLOR_MAP">COLOR_MAP</a> &mdash; Stores a color map to accelerate drawing.
<li><a href="#COMPILED_SPRITE">COMPILED_SPRITE</a> &mdash; Stores the contents of a compiled sprite.
<li><a href="#DATAFILE">DATAFILE</a> &mdash; Stores an Allegro datafile in memory.
<li><a href="#DIALOG">DIALOG</a> &mdash; Stores a GUI description.
<li><a href="#DIALOG_PLAYER">DIALOG_PLAYER</a> &mdash; Stores GUI data internally used by Allegro.
<li><a href="#fixed">fixed</a> &mdash; Fixed point integer to replace floats.
<li><a href="#FONT">FONT</a> &mdash; Stores an Allegro font.
<li><a href="#GFX_MODE">GFX_MODE</a> &mdash; Stores video mode information.
<li><a href="#GFX_MODE_LIST">GFX_MODE_LIST</a> &mdash; Stores an array of GFX_MODE structures.
<li><a href="#JOYSTICK_AXIS_INFO">JOYSTICK_AXIS_INFO</a> &mdash; Stores joystick axis information.
<li><a href="#JOYSTICK_BUTTON_INFO">JOYSTICK_BUTTON_INFO</a> &mdash; Stores joystick button information.
<li><a href="#JOYSTICK_INFO">JOYSTICK_INFO</a> &mdash; Stores information about joysticks.
<li><a href="#JOYSTICK_STICK_INFO">JOYSTICK_STICK_INFO</a> &mdash; Stores joystick stick information.
<li><a href="#LZSS_PACK_DATA">LZSS_PACK_DATA</a> &mdash; Opaque structure for handling LZSS compression.
<li><a href="#LZSS_UNPACK_DATA">LZSS_UNPACK_DATA</a> &mdash; Opaque structure for handling LZSS decompression.
<li><a href="#MATRIX">MATRIX</a> &mdash; Fixed point matrix structure.
<li><a href="#MATRIX_f">MATRIX_f</a> &mdash; Floating point matrix structure.
<li><a href="#MENU">MENU</a> &mdash; Stores the entries of a menu.
<li><a href="#MENU_PLAYER">MENU_PLAYER</a> &mdash; Stores GUI data internally used by Allegro.
<li><a href="#MIDI">MIDI</a> &mdash; Stores MIDI data.
<li><a href="#PACKFILE">PACKFILE</a> &mdash; Packfile structure, similar to the libc FILE structure.
<li><a href="#PACKFILE_VTABLE">PACKFILE_VTABLE</a> &mdash; Packfile vtable structure, for custom packfiles.
<li><a href="#PAL_SIZE">PAL_SIZE</a> &mdash; Number of entries in a palette.
<li><a href="#PALETTE">PALETTE</a> &mdash; Stores palette information.
<li><a href="#QUAT">QUAT</a> &mdash; Stores quaternion information.
<li><a href="#RGB">RGB</a> &mdash; Single palette entry.
<li><a href="#RGB_MAP">RGB_MAP</a> &mdash; Stores an rgb map to accelerate conversions.
<li><a href="#RLE_SPRITE">RLE_SPRITE</a> &mdash; Stores the contents of an RLE sprite.
<li><a href="#SAMPLE">SAMPLE</a> &mdash; Stores sound data.
<li><a href="#V3D">V3D</a> &mdash; Fixed point vertex structure used by 3d functions.
<li><a href="#V3D_f">V3D_f</a> &mdash; Floating point vertex structure used by 3d functions.
<li><a href="#ZBUFFER">ZBUFFER</a> &mdash; Stores 3d zbuffer information.
</ul>
<li><a href="#Unicode routines">Unicode routines</a>
<ul>
<li><a href="#_ustrdup">_ustrdup</a> &mdash; Duplicates a string with a custom memory allocator.
<li><a href="#do_uconvert">do_uconvert</a> &mdash; Converts a string to another encoding format.
<li><a href="#empty_string">empty_string</a> &mdash; Universal string NULL terminator.
<li><a href="#get_uformat">get_uformat</a> &mdash; Finds out what text encoding format is currently selected.
<li><a href="#need_uconvert">need_uconvert</a> &mdash; Tells if a string requires encoding conversion.
<li><a href="#register_uformat">register_uformat</a> &mdash; Installs handler functions for a new text encoding format.
<li><a href="#set_ucodepage">set_ucodepage</a> &mdash; Sets 8-bit to Unicode conversion tables.
<li><a href="#set_uformat">set_uformat</a> &mdash; Set the global current text encoding format.
<li><a href="#uatof">uatof</a> &mdash; Converts a string into a double.
<li><a href="#uconvert">uconvert</a> &mdash; High level string encoding conversion wrapper.
<li><a href="#uconvert_ascii">uconvert_ascii</a> &mdash; Converts string from ASCII into the current format.
<li><a href="#uconvert_size">uconvert_size</a> &mdash; Number of bytes needed to store a string after conversion.
<li><a href="#uconvert_toascii">uconvert_toascii</a> &mdash; Converts strings from the current format into ASCII.
<li><a href="#ucwidth">ucwidth</a> &mdash; Low level helper function for testing Unicode text data.
<li><a href="#ugetat">ugetat</a> &mdash; Finds out the value of a character in a string.
<li><a href="#ugetc">ugetc</a> &mdash; Low level helper function for reading Unicode text data.
<li><a href="#ugetx">ugetx</a> &mdash; Low level helper function for reading Unicode text data.
<li><a href="#ugetxc">ugetxc</a> &mdash; Low level helper function for reading Unicode text data.
<li><a href="#uinsert">uinsert</a> &mdash; Inserts a character in a string.
<li><a href="#uisdigit">uisdigit</a> &mdash; Tells if a character is a digit.
<li><a href="#uisok">uisok</a> &mdash; Low level helper function for testing Unicode text data.
<li><a href="#uisspace">uisspace</a> &mdash; Tells if a character is whitespace.
<li><a href="#uoffset">uoffset</a> &mdash; Finds the offset of a character in a string.
<li><a href="#uremove">uremove</a> &mdash; Removes a character from a string.
<li><a href="#usetat">usetat</a> &mdash; Replaces a character in a string.
<li><a href="#usetc">usetc</a> &mdash; Low level helper function for writing Unicode text data.
<li><a href="#usprintf">usprintf</a> &mdash; Writes formatted data into a buffer.
<li><a href="#ustrcat">ustrcat</a> &mdash; Concatenates a string to another one.
<li><a href="#ustrchr">ustrchr</a> &mdash; Finds the first occurrence of a character in a string.
<li><a href="#ustrcmp">ustrcmp</a> &mdash; Compares two strings.
<li><a href="#ustrcpy">ustrcpy</a> &mdash; Copies a string into another one.
<li><a href="#ustrdup">ustrdup</a> &mdash; Duplicates a string.
<li><a href="#ustrerror">ustrerror</a> &mdash; Returns a string describing errno.
<li><a href="#ustricmp">ustricmp</a> &mdash; Compares two strings ignoring case.
<li><a href="#ustrlen">ustrlen</a> &mdash; Tells the number of characters in a string.
<li><a href="#ustrlwr">ustrlwr</a> &mdash; Replaces all letters with lower case.
<li><a href="#ustrncat">ustrncat</a> &mdash; Concatenates a string to another one, specifying size.
<li><a href="#ustrncmp">ustrncmp</a> &mdash; Compares up to n letters of two strings.
<li><a href="#ustrncpy">ustrncpy</a> &mdash; Copies a string into another one, specifying size.
<li><a href="#ustrnicmp">ustrnicmp</a> &mdash; Compares up to n letters of two strings ignoring case.
<li><a href="#ustrpbrk">ustrpbrk</a> &mdash; Finds the first character that matches any in a set.
<li><a href="#ustrrchr">ustrrchr</a> &mdash; Finds the last occurrence of a character in a string.
<li><a href="#ustrsize">ustrsize</a> &mdash; Size of the string in bytes without null terminator.
<li><a href="#ustrsizez">ustrsizez</a> &mdash; Size of the string in bytes including null terminator.
<li><a href="#ustrstr">ustrstr</a> &mdash; Finds the first occurrence of a string in another one.
<li><a href="#ustrtod">ustrtod</a> &mdash; Converts a string into a floating point number.
<li><a href="#ustrtok">ustrtok</a> &mdash; Retrieves tokens from a string.
<li><a href="#ustrtok_r">ustrtok_r</a> &mdash; Reentrant function to retrieve tokens from a string.
<li><a href="#ustrtol">ustrtol</a> &mdash; Converts a string into an integer.
<li><a href="#ustrupr">ustrupr</a> &mdash; Replaces all letters with upper case.
<li><a href="#ustrzcat">ustrzcat</a> &mdash; Concatenates a string to another one, specifying size.
<li><a href="#ustrzcpy">ustrzcpy</a> &mdash; Copies a string into another one, specifying size.
<li><a href="#ustrzncat">ustrzncat</a> &mdash; Concatenates a string to another one, specifying size.
<li><a href="#ustrzncpy">ustrzncpy</a> &mdash; Copies a string into another one, specifying size.
<li><a href="#uszprintf">uszprintf</a> &mdash; Writes formatted data into a buffer, specifying size.
<li><a href="#utolower">utolower</a> &mdash; Converts a letter to lower case.
<li><a href="#utoupper">utoupper</a> &mdash; Converts a letter to upper case.
<li><a href="#uvsprintf">uvsprintf</a> &mdash; Writes formatted data into a buffer, using variable arguments.
<li><a href="#uvszprintf">uvszprintf</a> &mdash; Writes formatted data into a buffer, using size and variable arguments.
<li><a href="#uwidth">uwidth</a> &mdash; Low level helper function for testing Unicode text data.
<li><a href="#uwidth_max">uwidth_max</a> &mdash; Number of bytes a character can occupy.
</ul>
<li><a href="#Configuration routines">Configuration routines</a>
<ul>
<li><a href="#config_is_hooked">config_is_hooked</a> &mdash; Tells if a config section has custom hooks.
<li><a href="#flush_config_file">flush_config_file</a> &mdash; Flushes the current config file to disk.
<li><a href="#free_config_entries">free_config_entries</a> &mdash; Frees memory allocated for config entry lists.
<li><a href="#get_config_argv">get_config_argv</a> &mdash; Reads a token list from the configuration file.
<li><a href="#get_config_float">get_config_float</a> &mdash; Retrieves a float from the configuration file.
<li><a href="#get_config_hex">get_config_hex</a> &mdash; Retrieves a hexadecimal value from the configuration file.
<li><a href="#get_config_id">get_config_id</a> &mdash; Retrieves a driver ID from a configuration file.
<li><a href="#get_config_int">get_config_int</a> &mdash; Retrieves an integer from the configuration file.
<li><a href="#get_config_string">get_config_string</a> &mdash; Retrieves a string from the configuration file.
<li><a href="#get_config_text">get_config_text</a> &mdash; Returns a string translated to the current language.
<li><a href="#hook_config_section">hook_config_section</a> &mdash; Hooks a configuration file section with custom handlers.
<li><a href="#list_config_entries">list_config_entries</a> &mdash; Lists the names of all entries in a config section
<li><a href="#list_config_sections">list_config_sections</a> &mdash; Lists the names of all sections available in the current configuration.
<li><a href="#override_config_data">override_config_data</a> &mdash; Specifies a block of data containing config overrides.
<li><a href="#override_config_file">override_config_file</a> &mdash; Specifies a file containing config overrides.
<li><a href="#pop_config_state">pop_config_state</a> &mdash; Pops a previously pushed configuration state.
<li><a href="#push_config_state">push_config_state</a> &mdash; Pushes the current configuration state.
<li><a href="#reload_config_texts">reload_config_texts</a> &mdash; Reloads translated strings returned by get_config_text().
<li><a href="#set_config_data">set_config_data</a> &mdash; Sets a block of configuration data.
<li><a href="#set_config_file">set_config_file</a> &mdash; Sets the configuration file.
<li><a href="#set_config_float">set_config_float</a> &mdash; Writes a float in the configuration file.
<li><a href="#set_config_hex">set_config_hex</a> &mdash; Writes a hexadecimal integer in the configuration file.
<li><a href="#set_config_id">set_config_id</a> &mdash; Writes a driver ID in the configuration file.
<li><a href="#set_config_int">set_config_int</a> &mdash; Writes an integer in the configuration file.
<li><a href="#set_config_string">set_config_string</a> &mdash; Writes a string in the configuration file.
</ul>
<li><a href="#Mouse routines">Mouse routines</a>
<ul>
<li><a href="#disable_hardware_cursor">disable_hardware_cursor</a> &mdash; Disables the OS hardware cursor.
<li><a href="#enable_hardware_cursor">enable_hardware_cursor</a> &mdash; Enables the OS hardware cursor.
<li><a href="#freeze_mouse_flag">freeze_mouse_flag</a> &mdash; Flag to avoid redrawing the mouse pointer.
<li><a href="#get_mouse_mickeys">get_mouse_mickeys</a> &mdash; How far the mouse has moved since the last call to this function.
<li><a href="#install_mouse">install_mouse</a> &mdash; Installs the Allegro mouse handler.
<li><a href="#mouse_b">mouse_b</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#mouse_callback">mouse_callback</a> &mdash; User specified mouse callback.
<li><a href="#mouse_needs_poll">mouse_needs_poll</a> &mdash; Tells if the mouse driver requires polling.
<li><a href="#mouse_pos">mouse_pos</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#mouse_sprite">mouse_sprite</a> &mdash; Global variable with the mouse sprite and focus point.
<li><a href="#mouse_w">mouse_w</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#mouse_x">mouse_x</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#mouse_x_focus">mouse_x_focus</a> &mdash; Global variable with the mouse sprite and focus point.
<li><a href="#mouse_y">mouse_y</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#mouse_y_focus">mouse_y_focus</a> &mdash; Global variable with the mouse sprite and focus point.
<li><a href="#mouse_z">mouse_z</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#poll_mouse">poll_mouse</a> &mdash; Polls the mouse.
<li><a href="#position_mouse">position_mouse</a> &mdash; Moves the mouse to the specified screen position.
<li><a href="#position_mouse_w">position_mouse_w</a> &mdash; Sets the horizontal mouse wheel position.
<li><a href="#position_mouse_z">position_mouse_z</a> &mdash; Sets the mouse wheel position global variable.
<li><a href="#remove_mouse">remove_mouse</a> &mdash; Removes the mouse handler.
<li><a href="#scare_mouse">scare_mouse</a> &mdash; Helper for hiding the mouse pointer before drawing.
<li><a href="#scare_mouse_area">scare_mouse_area</a> &mdash; Helper for hiding the mouse cursor before drawing in an area.
<li><a href="#select_mouse_cursor">select_mouse_cursor</a> &mdash; Tells Allegro to select software or hardware cursor drawing.
<li><a href="#set_mouse_cursor_bitmap">set_mouse_cursor_bitmap</a> &mdash; Changes the image Allegro uses for mouse cursors.
<li><a href="#set_mouse_range">set_mouse_range</a> &mdash; Sets the area of the screen restricting mouse movement.
<li><a href="#set_mouse_speed">set_mouse_speed</a> &mdash; Sets the mouse speed.
<li><a href="#set_mouse_sprite">set_mouse_sprite</a> &mdash; Sets the mouse sprite.
<li><a href="#set_mouse_sprite_focus">set_mouse_sprite_focus</a> &mdash; Sets the mouse sprite focus.
<li><a href="#show_mouse">show_mouse</a> &mdash; Tells Allegro to display a mouse pointer on the screen.
<li><a href="#show_os_cursor">show_os_cursor</a> &mdash; Low level function to display the operating system cursor.
<li><a href="#unscare_mouse">unscare_mouse</a> &mdash; Undoes the effect of scare_mouse() or scare_mouse_area().
</ul>
<li><a href="#Timer routines">Timer routines</a>
<ul>
<li><a href="#END_OF_FUNCTION">END_OF_FUNCTION</a> &mdash; Locks the code used by a timer.
<li><a href="#install_int">install_int</a> &mdash; Installs a user timer handler.
<li><a href="#install_int_ex">install_int_ex</a> &mdash; Adds or modifies a timer.
<li><a href="#install_param_int">install_param_int</a> &mdash; Installs a timer routine with a customizable parameter.
<li><a href="#install_param_int_ex">install_param_int_ex</a> &mdash; Adds or modifies a timer with a customizable parameter.
<li><a href="#install_timer">install_timer</a> &mdash; Installs the Allegro timer interrupt handler.
<li><a href="#LOCK_FUNCTION">LOCK_FUNCTION</a> &mdash; Locks the memory of a function used by a timer.
<li><a href="#LOCK_VARIABLE">LOCK_VARIABLE</a> &mdash; Locks the memory of a variable used by a timer.
<li><a href="#remove_int">remove_int</a> &mdash; Removes a timers.
<li><a href="#remove_param_int">remove_param_int</a> &mdash; Removes a timer with a customizable parameter.
<li><a href="#remove_timer">remove_timer</a> &mdash; Removes the Allegro time handler.
<li><a href="#rest">rest</a> &mdash; Waits a specified number of milliseconds or yields CPU.
<li><a href="#rest_callback">rest_callback</a> &mdash; Like rest(), but calls the callback during the wait.
<li><a href="#retrace_count">retrace_count</a> &mdash; Retrace count simulator.
</ul>
<li><a href="#Keyboard routines">Keyboard routines</a>
<ul>
<li><a href="#clear_keybuf">clear_keybuf</a> &mdash; Clears the keyboard buffer.
<li><a href="#install_keyboard">install_keyboard</a> &mdash; Installs the Allegro keyboard interrupt handler.
<li><a href="#install_keyboard_hooks">install_keyboard_hooks</a> &mdash; Installs custom keyboard hooks.
<li><a href="#key">key</a> &mdash; Array of flags indicating key state.
<li><a href="#key_led_flag">key_led_flag</a> &mdash; Flag to prevent the keyboard LEDs from being updated.
<li><a href="#key_shifts">key_shifts</a> &mdash; Bitmask containing the current state of modifier keys.
<li><a href="#keyboard_callback">keyboard_callback</a> &mdash; User specified keyboard callback handler.
<li><a href="#keyboard_lowlevel_callback">keyboard_lowlevel_callback</a> &mdash; User specified low level keyboard event handler.
<li><a href="#keyboard_needs_poll">keyboard_needs_poll</a> &mdash; Tells if the keyboard needs polling.
<li><a href="#keyboard_ucallback">keyboard_ucallback</a> &mdash; User specified unicode keyboard callback handler.
<li><a href="#keypressed">keypressed</a> &mdash; Tells if there are keypresses waiting in the input buffer.
<li><a href="#poll_keyboard">poll_keyboard</a> &mdash; Polls the keyboard.
<li><a href="#readkey">readkey</a> &mdash; Returns the next character from the keyboard buffer.
<li><a href="#remove_keyboard">remove_keyboard</a> &mdash; Removes the Allegro keyboard handler.
<li><a href="#scancode_to_ascii">scancode_to_ascii</a> &mdash; Converts a scancode to an ASCII character.
<li><a href="#scancode_to_name">scancode_to_name</a> &mdash; Converts a scancode to a key name.
<li><a href="#set_keyboard_rate">set_keyboard_rate</a> &mdash; Sets the keyboard repeat rate.
<li><a href="#set_leds">set_leds</a> &mdash; Sets the state of the keyboard LED indicators.
<li><a href="#simulate_keypress">simulate_keypress</a> &mdash; Stuffs a key into the keyboard buffer.
<li><a href="#simulate_ukeypress">simulate_ukeypress</a> &mdash; Stuffs an unicode key into the keyboard buffer.
<li><a href="#three_finger_flag">three_finger_flag</a> &mdash; Flag to deactivate the emergency exit key combination.
<li><a href="#ureadkey">ureadkey</a> &mdash; Returns the next unicode character from the keyboard buffer.
</ul>
<li><a href="#Joystick routines">Joystick routines</a>
<ul>
<li><a href="#calibrate_joystick">calibrate_joystick</a> &mdash; Calibrates the specified joystick.
<li><a href="#calibrate_joystick_name">calibrate_joystick_name</a> &mdash; Returns the next calibration text string.
<li><a href="#initialise_joystick">initialise_joystick</a> &mdash; Deprecated version of install_joystick().
<li><a href="#install_joystick">install_joystick</a> &mdash; Initialises the joystick.
<li><a href="#joy">joy</a> &mdash; Global array of joystick state information.
<li><a href="#load_joystick_data">load_joystick_data</a> &mdash; Loads joystick calibration data.
<li><a href="#num_joysticks">num_joysticks</a> &mdash; Global variable saying how many joysticks there are.
<li><a href="#poll_joystick">poll_joystick</a> &mdash; Polls the joystick.
<li><a href="#remove_joystick">remove_joystick</a> &mdash; Removes the joystick handler.
<li><a href="#save_joystick_data">save_joystick_data</a> &mdash; Saves joystick calibration data.
</ul>
<li><a href="#Graphics modes">Graphics modes</a>
<ul>
<li><a href="#destroy_gfx_mode_list">destroy_gfx_mode_list</a> &mdash; Frees the list created by get_gfx_mode_list().
<li><a href="#enable_triple_buffer">enable_triple_buffer</a> &mdash; Enables triple buffering.
<li><a href="#get_color_depth">get_color_depth</a> &mdash; Returns the current pixel color depth.
<li><a href="#get_display_switch_mode">get_display_switch_mode</a> &mdash; Returns the current display switching mode.
<li><a href="#get_gfx_mode_list">get_gfx_mode_list</a> &mdash; Obtains a list of available video modes.
<li><a href="#get_refresh_rate">get_refresh_rate</a> &mdash; Returns the current refresh rate.
<li><a href="#gfx_capabilities">gfx_capabilities</a> &mdash; Bitfield describing video hardware capabilities.
<li><a href="#is_windowed_mode">is_windowed_mode</a> &mdash; Tells if you are running in windowed mode.
<li><a href="#poll_scroll">poll_scroll</a> &mdash; Checks the status of a scroll request with triple buffering.
<li><a href="#remove_display_switch_callback">remove_display_switch_callback</a> &mdash; Removes a switching notification callback.
<li><a href="#request_refresh_rate">request_refresh_rate</a> &mdash; Requests a specific refresh rate during graphic mode switch.
<li><a href="#request_scroll">request_scroll</a> &mdash; Queues a hardware scroll request with triple buffering.
<li><a href="#request_video_bitmap">request_video_bitmap</a> &mdash; Triple buffering page flip request.
<li><a href="#scroll_screen">scroll_screen</a> &mdash; Requests a hardware scroll request.
<li><a href="#set_color_depth">set_color_depth</a> &mdash; Sets the global pixel color depth.
<li><a href="#set_display_switch_callback">set_display_switch_callback</a> &mdash; Installs a switching notification callback.
<li><a href="#set_display_switch_mode">set_display_switch_mode</a> &mdash; Tells Allegro how the program handles background switching.
<li><a href="#set_gfx_mode">set_gfx_mode</a> &mdash; Sets a graphic video mode.
<li><a href="#show_video_bitmap">show_video_bitmap</a> &mdash; Flips the hardware screen to use the specified page.
<li><a href="#vsync">vsync</a> &mdash; Waits for a vertical retrace to begin.
</ul>
<li><a href="#Bitmap objects">Bitmap objects</a>
<ul>
<li><a href="#acquire_bitmap">acquire_bitmap</a> &mdash; Locks the bitmap before drawing onto it.
<li><a href="#acquire_screen">acquire_screen</a> &mdash; Shortcut of acquire_bitmap(screen);
<li><a href="#add_clip_rect">add_clip_rect</a> &mdash; Intersects a bitmap's clipping rectangle with the given area.
<li><a href="#bitmap_color_depth">bitmap_color_depth</a> &mdash; Returns the color depth of the specified bitmap.
<li><a href="#bitmap_mask_color">bitmap_mask_color</a> &mdash; Returns the mask color of the specified bitmap.
<li><a href="#create_bitmap">create_bitmap</a> &mdash; Creates a memory bitmap.
<li><a href="#create_bitmap_ex">create_bitmap_ex</a> &mdash; Creates a memory bitmap specifying color depth.
<li><a href="#create_sub_bitmap">create_sub_bitmap</a> &mdash; Creates a memory sub bitmap.
<li><a href="#create_system_bitmap">create_system_bitmap</a> &mdash; Creates a system memory bitmap.
<li><a href="#create_video_bitmap">create_video_bitmap</a> &mdash; Creates a video memory bitmap.
<li><a href="#destroy_bitmap">destroy_bitmap</a> &mdash; Destroys any type of created bitmap.
<li><a href="#get_clip_rect">get_clip_rect</a> &mdash; Returns the clipping rectangle of a bitmap.
<li><a href="#get_clip_state">get_clip_state</a> &mdash; Tells if clipping is on for a bitmap.
<li><a href="#is_inside_bitmap">is_inside_bitmap</a> &mdash; Tells if a point is inside a bitmap.
<li><a href="#is_linear_bitmap">is_linear_bitmap</a> &mdash; Tells if a bitmap is linear.
<li><a href="#is_memory_bitmap">is_memory_bitmap</a> &mdash; Tells if a bitmap is a memory bitmap.
<li><a href="#is_planar_bitmap">is_planar_bitmap</a> &mdash; Tells if a bitmap is a planar screen bitmap.
<li><a href="#is_same_bitmap">is_same_bitmap</a> &mdash; Tells if two bitmaps describe the same drawing surface.
<li><a href="#is_screen_bitmap">is_screen_bitmap</a> &mdash; Tells if a bitmap is the screen bitmap or sub bitmap.
<li><a href="#is_sub_bitmap">is_sub_bitmap</a> &mdash; Tells if a bitmap is a sub bitmap.
<li><a href="#is_system_bitmap">is_system_bitmap</a> &mdash; Tells if a bitmap is a system bitmap or sub bitmap.
<li><a href="#is_video_bitmap">is_video_bitmap</a> &mdash; Tells if a bitmap is a screen bitmap, video memory or sub bitmap.
<li><a href="#lock_bitmap">lock_bitmap</a> &mdash; Locks the memory used by a bitmap.
<li><a href="#release_bitmap">release_bitmap</a> &mdash; Releases a previously locked bitmap.
<li><a href="#release_screen">release_screen</a> &mdash; Shortcut of release_bitmap(screen);
<li><a href="#screen">screen</a> &mdash; Global pointer to the screen hardware video memory.
<li><a href="#SCREEN_H">SCREEN_H</a> &mdash; Global define to obtain the size of the screen.
<li><a href="#SCREEN_W">SCREEN_W</a> &mdash; Global define to obtain the size of the screen.
<li><a href="#set_clip_rect">set_clip_rect</a> &mdash; Sets the clipping rectangle of a bitmap.
<li><a href="#set_clip_state">set_clip_state</a> &mdash; Turns on or off the clipping of a bitmap.
<li><a href="#VIRTUAL_H">VIRTUAL_H</a> &mdash; Global define to obtain the virtual size of the screen.
<li><a href="#VIRTUAL_W">VIRTUAL_W</a> &mdash; Global define to obtain the virtual size of the screen.
</ul>
<li><a href="#Loading image files">Loading image files</a>
<ul>
<li><a href="#get_color_conversion">get_color_conversion</a> &mdash; Returns the current color conversion mode.
<li><a href="#load_bitmap">load_bitmap</a> &mdash; Loads any supported bitmap from a file.
<li><a href="#load_bmp">load_bmp</a> &mdash; Loads a BMP bitmap from a file.
<li><a href="#load_bmp_pf">load_bmp_pf</a> &mdash; Packfile version of load_bmp.
<li><a href="#load_lbm">load_lbm</a> &mdash; Loads an LBM bitmap from a file.
<li><a href="#load_pcx">load_pcx</a> &mdash; Loads a PCX bitmap from a file.
<li><a href="#load_pcx_pf">load_pcx_pf</a> &mdash; Packfile version of load_pcx.
<li><a href="#load_tga">load_tga</a> &mdash; Loads a TGA bitmap from a file.
<li><a href="#load_tga_pf">load_tga_pf</a> &mdash; Packfile version of load_tga.
<li><a href="#register_bitmap_file_type">register_bitmap_file_type</a> &mdash; Registers custom bitmap loading/saving functions.
<li><a href="#save_bitmap">save_bitmap</a> &mdash; Saves a bitmap into any supported file format.
<li><a href="#save_bmp">save_bmp</a> &mdash; Saves a bitmap into a BMP file.
<li><a href="#save_bmp_pf">save_bmp_pf</a> &mdash; Packfile version of save_bmp.
<li><a href="#save_pcx">save_pcx</a> &mdash; Saves a bitmap into a PCX file.
<li><a href="#save_pcx_pf">save_pcx_pf</a> &mdash; Packfile version of save_pcx.
<li><a href="#save_tga">save_tga</a> &mdash; Saves a bitmap into a TGA file.
<li><a href="#save_tga_pf">save_tga_pf</a> &mdash; Packfile version of save_tga.
<li><a href="#set_color_conversion">set_color_conversion</a> &mdash; Tells Allegro how to convert images during loading time.
</ul>
<li><a href="#Palette routines">Palette routines</a>
<ul>
<li><a href="#_set_color">_set_color</a> &mdash; Inline version of set_color().
<li><a href="#black_palette">black_palette</a> &mdash; A palette containing solid black colors.
<li><a href="#default_palette">default_palette</a> &mdash; The default IBM BIOS palette.
<li><a href="#desktop_palette">desktop_palette</a> &mdash; The palette used by the Atari ST low resolution desktop.
<li><a href="#fade_from">fade_from</a> &mdash; Gradually fades the palette between two others.
<li><a href="#fade_from_range">fade_from_range</a> &mdash; Gradually fades a part of the palette between two others.
<li><a href="#fade_in">fade_in</a> &mdash; Gradually fades the palette from black.
<li><a href="#fade_in_range">fade_in_range</a> &mdash; Gradually fades a part of the palette from black.
<li><a href="#fade_interpolate">fade_interpolate</a> &mdash; Calculates a new palette interpolated between two others.
<li><a href="#fade_out">fade_out</a> &mdash; Gradually fades the palette to black.
<li><a href="#fade_out_range">fade_out_range</a> &mdash; Gradually fades a part of the palette to black.
<li><a href="#generate_332_palette">generate_332_palette</a> &mdash; Constructs a fake truecolor palette.
<li><a href="#generate_optimized_palette">generate_optimized_palette</a> &mdash; Generates an optimized palette for a bitmap.
<li><a href="#get_color">get_color</a> &mdash; Retrieves the specified palette entry.
<li><a href="#get_palette">get_palette</a> &mdash; Retrieves the entire palette of 256 colors.
<li><a href="#get_palette_range">get_palette_range</a> &mdash; Retrieves a specific palette range.
<li><a href="#select_palette">select_palette</a> &mdash; Sets the internal palette for color conversion.
<li><a href="#set_color">set_color</a> &mdash; Sets the specified palette entry to the specified RGB triplet.
<li><a href="#set_palette">set_palette</a> &mdash; Sets the entire palette of 256 colors.
<li><a href="#set_palette_range">set_palette_range</a> &mdash; Sets a specific range of the palette.
<li><a href="#unselect_palette">unselect_palette</a> &mdash; Restores the palette before last call to select_palette().
</ul>
<li><a href="#Truecolor pixel formats">Truecolor pixel formats</a>
<ul>
<li><a href="#geta">geta</a> &mdash; Extract a color component from the current pixel format.
<li><a href="#geta32">geta32</a> &mdash; Extract the alpha component form a 32-bit pixel format color.
<li><a href="#geta_depth">geta_depth</a> &mdash; Extract a color component from a color in a specified pixel format.
<li><a href="#getb">getb</a> &mdash; Extract a color component from the current pixel format.
<li><a href="#getb15">getb15</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getb16">getb16</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getb24">getb24</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getb32">getb32</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getb8">getb8</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getb_depth">getb_depth</a> &mdash; Extract a color component from a color in a specified pixel format.
<li><a href="#getg">getg</a> &mdash; Extract a color component from the current pixel format.
<li><a href="#getg15">getg15</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getg16">getg16</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getg24">getg24</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getg32">getg32</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getg8">getg8</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getg_depth">getg_depth</a> &mdash; Extract a color component from a color in a specified pixel format.
<li><a href="#getr">getr</a> &mdash; Extract a color component from the current pixel format.
<li><a href="#getr15">getr15</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getr16">getr16</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getr24">getr24</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getr32">getr32</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getr8">getr8</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getr_depth">getr_depth</a> &mdash; Extract a color component from a color in a specified pixel format.
<li><a href="#makeacol">makeacol</a> &mdash; Converts RGBA colors into display dependent pixel formats.
<li><a href="#makeacol32">makeacol32</a> &mdash; Converts an RGBA color into a 32-bit display pixel format.
<li><a href="#makeacol_depth">makeacol_depth</a> &mdash; Converts RGBA colors into display dependent pixel formats.
<li><a href="#makecol">makecol</a> &mdash; Converts an RGB value into the current pixel format.
<li><a href="#makecol15">makecol15</a> &mdash; Converts an RGB value into a display dependent pixel format.
<li><a href="#makecol15_dither">makecol15_dither</a> &mdash; Calculates a dithered 15 or 16-bit RGB value.
<li><a href="#makecol16">makecol16</a> &mdash; Converts an RGB value into a display dependent pixel format.
<li><a href="#makecol16_dither">makecol16_dither</a> &mdash; Calculates a dithered 15 or 16-bit RGB value.
<li><a href="#makecol24">makecol24</a> &mdash; Converts an RGB value into a display dependent pixel format.
<li><a href="#makecol32">makecol32</a> &mdash; Converts an RGB value into a display dependent pixel format.
<li><a href="#makecol8">makecol8</a> &mdash; Converts an RGB value into a display dependent pixel format.
<li><a href="#makecol_depth">makecol_depth</a> &mdash; Converts an RGB value into the specified pixel format.
<li><a href="#MASK_COLOR_15">MASK_COLOR_15</a> &mdash; Constant representing the mask value in sprites.
<li><a href="#MASK_COLOR_16">MASK_COLOR_16</a> &mdash; Constant representing the mask value in sprites.
<li><a href="#MASK_COLOR_24">MASK_COLOR_24</a> &mdash; Constant representing the mask value in sprites.
<li><a href="#MASK_COLOR_32">MASK_COLOR_32</a> &mdash; Constant representing the mask value in sprites.
<li><a href="#MASK_COLOR_8">MASK_COLOR_8</a> &mdash; Constant representing the mask value in sprites.
<li><a href="#palette_color">palette_color</a> &mdash; Maps palette indexes into the current pixel format colors.
</ul>
<li><a href="#Drawing primitives">Drawing primitives</a>
<ul>
<li><a href="#_getpixel">_getpixel</a> &mdash; Faster specific version of getpixel().
<li><a href="#_getpixel15">_getpixel15</a> &mdash; Faster specific version of getpixel().
<li><a href="#_getpixel16">_getpixel16</a> &mdash; Faster specific version of getpixel().
<li><a href="#_getpixel24">_getpixel24</a> &mdash; Faster specific version of getpixel().
<li><a href="#_getpixel32">_getpixel32</a> &mdash; Faster specific version of getpixel().
<li><a href="#_putpixel">_putpixel</a> &mdash; Faster specific version of putpixel().
<li><a href="#_putpixel15">_putpixel15</a> &mdash; Faster specific version of putpixel().
<li><a href="#_putpixel16">_putpixel16</a> &mdash; Faster specific version of putpixel().
<li><a href="#_putpixel24">_putpixel24</a> &mdash; Faster specific version of putpixel().
<li><a href="#_putpixel32">_putpixel32</a> &mdash; Faster specific version of putpixel().
<li><a href="#arc">arc</a> &mdash; Draws a circular arc.
<li><a href="#calc_spline">calc_spline</a> &mdash; Calculates a series of values along a Bezier spline.
<li><a href="#circle">circle</a> &mdash; Draws a circle.
<li><a href="#circlefill">circlefill</a> &mdash; Draws a filled circle.
<li><a href="#clear_bitmap">clear_bitmap</a> &mdash; Clears the bitmap to color 0.
<li><a href="#clear_to_color">clear_to_color</a> &mdash; Clears the bitmap to the specified color.
<li><a href="#do_arc">do_arc</a> &mdash; Calculates all the points in a circular arc.
<li><a href="#do_circle">do_circle</a> &mdash; Calculates all the points in a circle.
<li><a href="#do_ellipse">do_ellipse</a> &mdash; Calculates all the points in an ellipse.
<li><a href="#do_line">do_line</a> &mdash; Calculates all the points along a line.
<li><a href="#ellipse">ellipse</a> &mdash; Draws an ellipse.
<li><a href="#ellipsefill">ellipsefill</a> &mdash; Draws a filled ellipse.
<li><a href="#fastline">fastline</a> &mdash; Faster version of line().
<li><a href="#floodfill">floodfill</a> &mdash; Floodfills an enclosed area.
<li><a href="#getpixel">getpixel</a> &mdash; Reads a pixel from a bitmap.
<li><a href="#hline">hline</a> &mdash; Draws a horizontal line onto the bitmap.
<li><a href="#line">line</a> &mdash; Draws a line onto the bitmap.
<li><a href="#polygon">polygon</a> &mdash; Draws a filled polygon.
<li><a href="#putpixel">putpixel</a> &mdash; Writes a pixel into a bitmap.
<li><a href="#rect">rect</a> &mdash; Draws an outline rectangle.
<li><a href="#rectfill">rectfill</a> &mdash; Draws a solid filled rectangle.
<li><a href="#spline">spline</a> &mdash; Draws a Bezier spline using four control points.
<li><a href="#triangle">triangle</a> &mdash; Draws a filled triangle.
<li><a href="#vline">vline</a> &mdash; Draws a vertical line onto the bitmap.
</ul>
<li><a href="#Blitting and sprites">Blitting and sprites</a>
<ul>
<li><a href="#blit">blit</a> &mdash; Copies a rectangular area from one bitmap to another.
<li><a href="#draw_character_ex">draw_character_ex</a> &mdash; Draws non transparent pixels of the sprite with a color.
<li><a href="#draw_gouraud_sprite">draw_gouraud_sprite</a> &mdash; Draws a sprite with gouraud shading.
<li><a href="#draw_lit_sprite">draw_lit_sprite</a> &mdash; Draws a sprite tinted with a specific color.
<li><a href="#draw_sprite">draw_sprite</a> &mdash; Draws a copy of the sprite onto the destination bitmap.
<li><a href="#draw_sprite_h_flip">draw_sprite_h_flip</a> &mdash; Draws the sprite transformed to the destination bitmap.
<li><a href="#draw_sprite_v_flip">draw_sprite_v_flip</a> &mdash; Draws the sprite transformed to the destination bitmap.
<li><a href="#draw_sprite_vh_flip">draw_sprite_vh_flip</a> &mdash; Draws the sprite transformed to the destination bitmap.
<li><a href="#draw_trans_sprite">draw_trans_sprite</a> &mdash; Draws a sprite blending it with the destination.
<li><a href="#masked_blit">masked_blit</a> &mdash; Copies a rectangle skipping pixels with the mask color.
<li><a href="#masked_stretch_blit">masked_stretch_blit</a> &mdash; Scales a rectangular area skipping pixels with the mask color.
<li><a href="#pivot_scaled_sprite">pivot_scaled_sprite</a> &mdash; Rotates and stretches a sprite around a specified point.
<li><a href="#pivot_scaled_sprite_v_flip">pivot_scaled_sprite_v_flip</a> &mdash; Rotates, stretches and flips a sprite around a specified point.
<li><a href="#pivot_sprite">pivot_sprite</a> &mdash; Rotates a sprite around a specified point.
<li><a href="#pivot_sprite_v_flip">pivot_sprite_v_flip</a> &mdash; Rotates and flips a sprite around a specified point.
<li><a href="#rotate_scaled_sprite">rotate_scaled_sprite</a> &mdash; Rotates and stretches a sprite.
<li><a href="#rotate_scaled_sprite_v_flip">rotate_scaled_sprite_v_flip</a> &mdash; Rotates, stretches and flips a sprite.
<li><a href="#rotate_sprite">rotate_sprite</a> &mdash; Rotates a sprite.
<li><a href="#rotate_sprite_v_flip">rotate_sprite_v_flip</a> &mdash; Rotates and flips a sprite.
<li><a href="#stretch_blit">stretch_blit</a> &mdash; Scales a rectangular area from one bitmap to another.
<li><a href="#stretch_sprite">stretch_sprite</a> &mdash; Stretches a sprite to the destination bitmap.
</ul>
<li><a href="#RLE sprites">RLE sprites</a>
<ul>
<li><a href="#destroy_rle_sprite">destroy_rle_sprite</a> &mdash; Destroys an RLE sprite.
<li><a href="#draw_lit_rle_sprite">draw_lit_rle_sprite</a> &mdash; Draws a tinted RLE sprite.
<li><a href="#draw_rle_sprite">draw_rle_sprite</a> &mdash; Draws an RLE sprite.
<li><a href="#draw_trans_rle_sprite">draw_trans_rle_sprite</a> &mdash; Draws a translucent RLE sprite.
<li><a href="#get_rle_sprite">get_rle_sprite</a> &mdash; Creates an RLE sprite using a bitmap as source.
</ul>
<li><a href="#Compiled sprites">Compiled sprites</a>
<ul>
<li><a href="#destroy_compiled_sprite">destroy_compiled_sprite</a> &mdash; Destroys a compiled sprite.
<li><a href="#draw_compiled_sprite">draw_compiled_sprite</a> &mdash; Draws a compiled sprite.
<li><a href="#get_compiled_sprite">get_compiled_sprite</a> &mdash; Creates a compiled sprite using a bitmap as source.
</ul>
<li><a href="#Fonts">Fonts</a>
<ul>
<li><a href="#destroy_font">destroy_font</a> &mdash; Frees the memory being used by a font structure.
<li><a href="#extract_font_range">extract_font_range</a> &mdash; Extracts a range of characters from a font.
<li><a href="#font_has_alpha">font_has_alpha</a> &mdash; Search all pixels of a font for alpha values.
<li><a href="#get_font_range_begin">get_font_range_begin</a> &mdash; Returns the start of a character range in a font.
<li><a href="#get_font_range_end">get_font_range_end</a> &mdash; Returns the last character of a character range in a font.
<li><a href="#get_font_ranges">get_font_ranges</a> &mdash; Returns the number of character ranges in a font.
<li><a href="#grab_font_from_bitmap">grab_font_from_bitmap</a> &mdash; Grabs a font from a bitmap
<li><a href="#is_color_font">is_color_font</a> &mdash; Returns TRUE if a font is a color font.
<li><a href="#is_compatible_font">is_compatible_font</a> &mdash; Check if two fonts are of the same type.
<li><a href="#is_mono_font">is_mono_font</a> &mdash; Returns TRUE if a font is a monochrome font.
<li><a href="#is_trans_font">is_trans_font</a> &mdash; Returns TRUE if a font uses transparency.
<li><a href="#load_bios_font">load_bios_font</a> &mdash; Loads a 8x8 or 8x16 BIOS format font.
<li><a href="#load_bitmap_font">load_bitmap_font</a> &mdash; Grabs a font from a bitmap file.
<li><a href="#load_dat_font">load_dat_font</a> &mdash; Loads a FONT from an Allegro datafile.
<li><a href="#load_font">load_font</a> &mdash; Loads a font from a file.
<li><a href="#load_grx_font">load_grx_font</a> &mdash; Loads a GRX format font.
<li><a href="#load_grx_or_bios_font">load_grx_or_bios_font</a> &mdash; Loads either a BIOS or GRX format font.
<li><a href="#load_txt_font">load_txt_font</a> &mdash; Loads a font script.
<li><a href="#make_trans_font">make_trans_font</a> &mdash; Makes a font use transparency.
<li><a href="#merge_fonts">merge_fonts</a> &mdash; Merges two fonts into one font.
<li><a href="#register_font_file_type">register_font_file_type</a> &mdash; Register a new font loading function.
<li><a href="#transpose_font">transpose_font</a> &mdash; Transposes all characters in a font.
</ul>
<li><a href="#Text output">Text output</a>
<ul>
<li><a href="#allegro_404_char">allegro_404_char</a> &mdash; Character used when Allegro cannot find a glyph.
<li><a href="#font">font</a> &mdash; A simple 8x8 fixed size font.
<li><a href="#text_height">text_height</a> &mdash; Returns the height of a font in pixels.
<li><a href="#text_length">text_length</a> &mdash; Returns the length of a string in pixels.
<li><a href="#textout_centre_ex">textout_centre_ex</a> &mdash; Writes a centered string on a bitmap.
<li><a href="#textout_ex">textout_ex</a> &mdash; Writes a string on a bitmap.
<li><a href="#textout_justify_ex">textout_justify_ex</a> &mdash; Draws justified text within a region.
<li><a href="#textout_right_ex">textout_right_ex</a> &mdash; Writes a right aligned string on a bitmap.
<li><a href="#textprintf_centre_ex">textprintf_centre_ex</a> &mdash; Formatted centered output of a string.
<li><a href="#textprintf_ex">textprintf_ex</a> &mdash; Formatted output of a string.
<li><a href="#textprintf_justify_ex">textprintf_justify_ex</a> &mdash; Formatted justified output of a string.
<li><a href="#textprintf_right_ex">textprintf_right_ex</a> &mdash; Formatted right aligned output of a string.
</ul>
<li><a href="#Polygon rendering">Polygon rendering</a>
<ul>
<li><a href="#clear_scene">clear_scene</a> &mdash; Initializes a scene.
<li><a href="#clear_zbuffer">clear_zbuffer</a> &mdash; Writes a depth value into the given Z-buffer.
<li><a href="#clip3d">clip3d</a> &mdash; Clips the polygon given in vtx using fixed point math.
<li><a href="#clip3d_f">clip3d_f</a> &mdash; Clips the polygon given in vtx using floating point math,
<li><a href="#create_scene">create_scene</a> &mdash; Allocates memory for a 3d scene.
<li><a href="#create_sub_zbuffer">create_sub_zbuffer</a> &mdash; Creates a sub-z-buffer.
<li><a href="#create_zbuffer">create_zbuffer</a> &mdash; Creates a Z-buffer for a bitmap.
<li><a href="#destroy_scene">destroy_scene</a> &mdash; Deallocates the memory used by a scene.
<li><a href="#destroy_zbuffer">destroy_zbuffer</a> &mdash; Destroys a Z-buffer.
<li><a href="#polygon3d">polygon3d</a> &mdash; Draws a 3d polygon onto the specified bitmap.
<li><a href="#polygon3d_f">polygon3d_f</a> &mdash; Draws a 3d polygon onto the specified bitmap.
<li><a href="#POLYTYPE_ATEX">POLYTYPE_ATEX</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_ATEX_LIT">POLYTYPE_ATEX_LIT</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_ATEX_MASK">POLYTYPE_ATEX_MASK</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_ATEX_MASK_LIT">POLYTYPE_ATEX_MASK_LIT</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_ATEX_MASK_TRANS">POLYTYPE_ATEX_MASK_TRANS</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_ATEX_TRANS">POLYTYPE_ATEX_TRANS</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_FLAT">POLYTYPE_FLAT</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_GCOL">POLYTYPE_GCOL</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_GRGB">POLYTYPE_GRGB</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX">POLYTYPE_PTEX</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX_LIT">POLYTYPE_PTEX_LIT</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX_MASK">POLYTYPE_PTEX_MASK</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX_MASK_LIT">POLYTYPE_PTEX_MASK_LIT</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX_MASK_TRANS">POLYTYPE_PTEX_MASK_TRANS</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX_TRANS">POLYTYPE_PTEX_TRANS</a> &mdash; Polygon rendering mode type
<li><a href="#quad3d">quad3d</a> &mdash; Draws a 3d quad onto the specified bitmap.
<li><a href="#quad3d_f">quad3d_f</a> &mdash; Draws a 3d quad onto the specified bitmap.
<li><a href="#render_scene">render_scene</a> &mdash; Renders all the queued scene polygons.
<li><a href="#scene_gap">scene_gap</a> &mdash; Number controlling the scene z-sorting algorithm behaviour.
<li><a href="#scene_polygon3d">scene_polygon3d</a> &mdash; Puts a polygon in the scene rendering list.
<li><a href="#scene_polygon3d_f">scene_polygon3d_f</a> &mdash; Puts a polygon in the scene rendering list.
<li><a href="#set_zbuffer">set_zbuffer</a> &mdash; Makes the given Z-buffer the active one.
<li><a href="#triangle3d">triangle3d</a> &mdash; Draws a 3d triangle onto the specified bitmap.
<li><a href="#triangle3d_f">triangle3d_f</a> &mdash; Draws a 3d triangle onto the specified bitmap.
</ul>
<li><a href="#Transparency and patterned drawing">Transparency and patterned drawing</a>
<ul>
<li><a href="#color_map">color_map</a> &mdash; Global pointer to the color mapping table.
<li><a href="#create_blender_table">create_blender_table</a> &mdash; Emulates truecolor blender effects in paletted modes.
<li><a href="#create_color_table">create_color_table</a> &mdash; Fills a color mapping table for customised effects.
<li><a href="#create_light_table">create_light_table</a> &mdash; Fills a color mapping table for lighting effects.
<li><a href="#create_trans_table">create_trans_table</a> &mdash; Fills a color mapping table for translucency effects.
<li><a href="#drawing_mode">drawing_mode</a> &mdash; Sets the graphics drawing mode.
<li><a href="#set_add_blender">set_add_blender</a> &mdash; Enables an additive blender mode.
<li><a href="#set_alpha_blender">set_alpha_blender</a> &mdash; Enables a special alpha-channel blending mode.
<li><a href="#set_blender_mode">set_blender_mode</a> &mdash; Specifies a custom set of truecolor blender routines.
<li><a href="#set_blender_mode_ex">set_blender_mode_ex</a> &mdash; An even more complex version of set_blender_mode().
<li><a href="#set_burn_blender">set_burn_blender</a> &mdash; Enables a burn blender mode.
<li><a href="#set_color_blender">set_color_blender</a> &mdash; Enables a color blender mode.
<li><a href="#set_difference_blender">set_difference_blender</a> &mdash; Enables a difference blender mode.
<li><a href="#set_dissolve_blender">set_dissolve_blender</a> &mdash; Enables a dissolve blender mode.
<li><a href="#set_dodge_blender">set_dodge_blender</a> &mdash; Enables a dodge blender mode.
<li><a href="#set_hue_blender">set_hue_blender</a> &mdash; Enables a hue blender mode.
<li><a href="#set_invert_blender">set_invert_blender</a> &mdash; Enables an invert blender mode.
<li><a href="#set_luminance_blender">set_luminance_blender</a> &mdash; Enables a luminance blender mode.
<li><a href="#set_multiply_blender">set_multiply_blender</a> &mdash; Enables a multiply blender mode.
<li><a href="#set_saturation_blender">set_saturation_blender</a> &mdash; Enables a saturation blender mode.
<li><a href="#set_screen_blender">set_screen_blender</a> &mdash; Enables a screen blender mode.
<li><a href="#set_trans_blender">set_trans_blender</a> &mdash; Enables a truecolor blender.
<li><a href="#set_write_alpha_blender">set_write_alpha_blender</a> &mdash; Enables the special alpha-channel editing mode.
<li><a href="#solid_mode">solid_mode</a> &mdash; Shortcut for selecting solid drawing mode.
<li><a href="#xor_mode">xor_mode</a> &mdash; Shortcut for toggling xor drawing mode on and off.
</ul>
<li><a href="#Converting between color formats">Converting between color formats</a>
<ul>
<li><a href="#bestfit_color">bestfit_color</a> &mdash; Finds a palette color fitting the requested RGB values.
<li><a href="#create_rgb_table">create_rgb_table</a> &mdash; Generates an RGB mapping table with lookup data for a palette.
<li><a href="#hsv_to_rgb">hsv_to_rgb</a> &mdash; Converts color values between the HSV and RGB color spaces.
<li><a href="#rgb_map">rgb_map</a> &mdash; Look up table to speed up reducing RGB values to palette colors.
<li><a href="#rgb_to_hsv">rgb_to_hsv</a> &mdash; Converts color values between the HSV and RGB color spaces.
</ul>
<li><a href="#Direct access to video memory">Direct access to video memory</a>
<ul>
<li><a href="#bmp_read_line">bmp_read_line</a> &mdash; Direct access bank switching line selection for reading.
<li><a href="#bmp_unwrite_line">bmp_unwrite_line</a> &mdash; Direct access bank switching line release.
<li><a href="#bmp_write_line">bmp_write_line</a> &mdash; Direct access bank switching line selection for writing.
</ul>
<li><a href="#FLIC routines">FLIC routines</a>
<ul>
<li><a href="#close_fli">close_fli</a> &mdash; Closes a FLI file previously opened.
<li><a href="#fli_bitmap">fli_bitmap</a> &mdash; Contains the current frame of the animation.
<li><a href="#fli_bmp_dirty_from">fli_bmp_dirty_from</a> &mdash; Indicate which parts of the image have changed.
<li><a href="#fli_bmp_dirty_to">fli_bmp_dirty_to</a> &mdash; Indicate which parts of the image have changed.
<li><a href="#fli_frame">fli_frame</a> &mdash; Stores the current frame number of the animation.
<li><a href="#fli_pal_dirty_from">fli_pal_dirty_from</a> &mdash; Indicate which parts of the palette have changed.
<li><a href="#fli_pal_dirty_to">fli_pal_dirty_to</a> &mdash; Indicate which parts of the palette have changed.
<li><a href="#fli_palette">fli_palette</a> &mdash; Contains the current palette of the animation.
<li><a href="#fli_timer">fli_timer</a> &mdash; Global variable for timing FLI playback.
<li><a href="#next_fli_frame">next_fli_frame</a> &mdash; Reads the next frame of the current animation file.
<li><a href="#open_fli">open_fli</a> &mdash; Makes a FLI file open and ready for playing.
<li><a href="#open_memory_fli">open_memory_fli</a> &mdash; Makes a FLI file open and ready for playing.
<li><a href="#play_fli">play_fli</a> &mdash; Plays a FLI or FLC animation from disk.
<li><a href="#play_memory_fli">play_memory_fli</a> &mdash; Plays a FLI or FLC animation from memory.
<li><a href="#reset_fli_variables">reset_fli_variables</a> &mdash; Resets the bitmap and palette dirty global variables.
</ul>
<li><a href="#Sound init routines">Sound init routines</a>
<ul>
<li><a href="#detect_digi_driver">detect_digi_driver</a> &mdash; Detects whether the specified digital sound device is available.
<li><a href="#detect_midi_driver">detect_midi_driver</a> &mdash; Detects whether the specified MIDI sound device is available.
<li><a href="#get_hardware_volume">get_hardware_volume</a> &mdash; Retrieves the hardware sound output volume.
<li><a href="#get_volume">get_volume</a> &mdash; Retrieves the global sound output volume.
<li><a href="#install_sound">install_sound</a> &mdash; Initialises the sound module.
<li><a href="#remove_sound">remove_sound</a> &mdash; Cleans up after you are finished with the sound routines.
<li><a href="#reserve_voices">reserve_voices</a> &mdash; Reserve a number of voices for the digital and MIDI drivers.
<li><a href="#set_hardware_volume">set_hardware_volume</a> &mdash; Alters the hardware sound output volume.
<li><a href="#set_volume">set_volume</a> &mdash; Alters the global sound output volume.
<li><a href="#set_volume_per_voice">set_volume_per_voice</a> &mdash; Sets the volume of a voice.
</ul>
<li><a href="#Mixer routines">Mixer routines</a>
<ul>
<li><a href="#get_mixer_bits">get_mixer_bits</a> &mdash; Returns the mixer bit depth (8 or 16).
<li><a href="#get_mixer_buffer_length">get_mixer_buffer_length</a> &mdash; Returns the number of samples per channel in the mixer buffer.
<li><a href="#get_mixer_channels">get_mixer_channels</a> &mdash; Returns the number of output channels.
<li><a href="#get_mixer_frequency">get_mixer_frequency</a> &mdash; Returns the mixer frequency, in Hz.
<li><a href="#get_mixer_quality">get_mixer_quality</a> &mdash; Returns the current mixing quality.
<li><a href="#get_mixer_voices">get_mixer_voices</a> &mdash; Returns the number of voices allocated to the mixer.
<li><a href="#set_mixer_quality">set_mixer_quality</a> &mdash; Sets the resampling quality of the mixer.
</ul>
<li><a href="#Digital sample routines">Digital sample routines</a>
<ul>
<li><a href="#adjust_sample">adjust_sample</a> &mdash; Alters the parameters of a sample while it is playing.
<li><a href="#allocate_voice">allocate_voice</a> &mdash; Allocates a sound card voice for a sample.
<li><a href="#create_sample">create_sample</a> &mdash; Constructs a new sample structure of the specified type.
<li><a href="#deallocate_voice">deallocate_voice</a> &mdash; Frees a sound card voice.
<li><a href="#destroy_sample">destroy_sample</a> &mdash; Destroys a sample structure when you are done with it.
<li><a href="#load_sample">load_sample</a> &mdash; Loads a sample from a file.
<li><a href="#load_voc">load_voc</a> &mdash; Loads a sample from a Creative Labs VOC file.
<li><a href="#load_voc_pf">load_voc_pf</a> &mdash; Packfile version of load_voc.
<li><a href="#load_wav">load_wav</a> &mdash; Loads a sample from a RIFF WAV file.
<li><a href="#load_wav_pf">load_wav_pf</a> &mdash; Packfile version of load_wav.
<li><a href="#lock_sample">lock_sample</a> &mdash; Locks all the memory used by a sample.
<li><a href="#play_sample">play_sample</a> &mdash; Plays a sample.
<li><a href="#reallocate_voice">reallocate_voice</a> &mdash; Switches the sample of an already-allocated voice.
<li><a href="#register_sample_file_type">register_sample_file_type</a> &mdash; Registers custom loading/saving sample routines.
<li><a href="#release_voice">release_voice</a> &mdash; Releases a sound card voice.
<li><a href="#save_sample">save_sample</a> &mdash; Writes a sample into a file.
<li><a href="#stop_sample">stop_sample</a> &mdash; Stops a sample from playing.
<li><a href="#voice_check">voice_check</a> &mdash; Checks whether a voice is currently allocated.
<li><a href="#voice_get_frequency">voice_get_frequency</a> &mdash; Returns the current pitch of the voice.
<li><a href="#voice_get_pan">voice_get_pan</a> &mdash; Returns the current pan position.
<li><a href="#voice_get_position">voice_get_position</a> &mdash; Returns the current position of a voice.
<li><a href="#voice_get_volume">voice_get_volume</a> &mdash; Returns the current volume of the voice.
<li><a href="#voice_ramp_volume">voice_ramp_volume</a> &mdash; Starts a volume ramp for a voice.
<li><a href="#voice_set_echo">voice_set_echo</a> &mdash; Sets the echo parameters for a voice.
<li><a href="#voice_set_frequency">voice_set_frequency</a> &mdash; Sets the pitch of the voice.
<li><a href="#voice_set_pan">voice_set_pan</a> &mdash; Sets the pan position.
<li><a href="#voice_set_playmode">voice_set_playmode</a> &mdash; Adjusts the loop status of the specified voice.
<li><a href="#voice_set_position">voice_set_position</a> &mdash; Sets the position of a voice.
<li><a href="#voice_set_priority">voice_set_priority</a> &mdash; Sets the priority of a voice.
<li><a href="#voice_set_tremolo">voice_set_tremolo</a> &mdash; Sets the tremolo parameters for a voice.
<li><a href="#voice_set_vibrato">voice_set_vibrato</a> &mdash; Sets the vibrato parameters for a voice.
<li><a href="#voice_set_volume">voice_set_volume</a> &mdash; Sets the volume of the voice.
<li><a href="#voice_start">voice_start</a> &mdash; Activates a voice.
<li><a href="#voice_stop">voice_stop</a> &mdash; Stops a voice.
<li><a href="#voice_stop_frequency_sweep">voice_stop_frequency_sweep</a> &mdash; Interrupts a frequency sweep operation.
<li><a href="#voice_stop_pan_sweep">voice_stop_pan_sweep</a> &mdash; Interrupts a pan sweep operation.
<li><a href="#voice_stop_volumeramp">voice_stop_volumeramp</a> &mdash; Interrupts a volume ramp operation.
<li><a href="#voice_sweep_frequency">voice_sweep_frequency</a> &mdash; Starts a frequency sweep for a voice.
<li><a href="#voice_sweep_pan">voice_sweep_pan</a> &mdash; Starts a pan sweep for a voice.
</ul>
<li><a href="#Music routines (MIDI)">Music routines (MIDI)</a>
<ul>
<li><a href="#destroy_midi">destroy_midi</a> &mdash; Destroys a MIDI structure when you are done with it.
<li><a href="#get_midi_length">get_midi_length</a> &mdash; Determines the total playing time of a midi, in seconds.
<li><a href="#load_ibk">load_ibk</a> &mdash; Reads in a .IBK patch definition file for the Adlib driver.
<li><a href="#load_midi">load_midi</a> &mdash; Loads a MIDI file.
<li><a href="#load_midi_patches">load_midi_patches</a> &mdash; Forces the MIDI driver to load a set of patches.
<li><a href="#lock_midi">lock_midi</a> &mdash; Locks all the memory used by a MIDI file.
<li><a href="#midi_loop_end">midi_loop_end</a> &mdash; Loop start and end points, set by play_looped_midi().
<li><a href="#midi_loop_start">midi_loop_start</a> &mdash; Loop start and end points, set by play_looped_midi().
<li><a href="#midi_meta_callback">midi_meta_callback</a> &mdash; Hook functions allowing you to intercept MIDI player events.
<li><a href="#midi_msg_callback">midi_msg_callback</a> &mdash; Hook functions allowing you to intercept MIDI player events.
<li><a href="#midi_out">midi_out</a> &mdash; Streams a block of MIDI commands into the player.
<li><a href="#midi_pause">midi_pause</a> &mdash; Pauses the MIDI player.
<li><a href="#midi_pos">midi_pos</a> &mdash; Stores the current position in the MIDI file.
<li><a href="#midi_resume">midi_resume</a> &mdash; Resumes playback of a paused MIDI file.
<li><a href="#midi_seek">midi_seek</a> &mdash; Seeks to the given midi_pos in the current MIDI file.
<li><a href="#midi_sysex_callback">midi_sysex_callback</a> &mdash; Hook functions allowing you to intercept MIDI player events.
<li><a href="#midi_time">midi_time</a> &mdash; The current position in the MIDI file, in seconds.
<li><a href="#play_looped_midi">play_looped_midi</a> &mdash; Starts playing a MIDI file with a user-defined loop position.
<li><a href="#play_midi">play_midi</a> &mdash; Starts playing the specified MIDI file.
<li><a href="#stop_midi">stop_midi</a> &mdash; Stops whatever music is currently playing.
</ul>
<li><a href="#Audio stream routines">Audio stream routines</a>
<ul>
<li><a href="#free_audio_stream_buffer">free_audio_stream_buffer</a> &mdash; Tells the audio stream player new data can be played.
<li><a href="#get_audio_stream_buffer">get_audio_stream_buffer</a> &mdash; Tells you if you need to fill the audiostream or not.
<li><a href="#play_audio_stream">play_audio_stream</a> &mdash; Creates a new audio stream and starts playing it.
<li><a href="#stop_audio_stream">stop_audio_stream</a> &mdash; Destroys an audio stream when it is no longer required.
</ul>
<li><a href="#Recording routines">Recording routines</a>
<ul>
<li><a href="#digi_recorder">digi_recorder</a> &mdash; Hook notifying you when a new sample buffer becomes available.
<li><a href="#get_sound_input_cap_bits">get_sound_input_cap_bits</a> &mdash; Checks which audio input sample formats are supported.
<li><a href="#get_sound_input_cap_parm">get_sound_input_cap_parm</a> &mdash; Detects if the specified recording parameters are supported.
<li><a href="#get_sound_input_cap_rate">get_sound_input_cap_rate</a> &mdash; Returns the maximum sample frequency for recording.
<li><a href="#get_sound_input_cap_stereo">get_sound_input_cap_stereo</a> &mdash; Tells if the input driver is capable of stereo recording.
<li><a href="#install_sound_input">install_sound_input</a> &mdash; Initialises the sound recorder module.
<li><a href="#midi_recorder">midi_recorder</a> &mdash; Hook notifying you when new MIDI data becomes available.
<li><a href="#read_sound_input">read_sound_input</a> &mdash; Retrieves the last recorded audio buffer.
<li><a href="#remove_sound_input">remove_sound_input</a> &mdash; Cleans up after you are finished with the sound input routines.
<li><a href="#set_sound_input_source">set_sound_input_source</a> &mdash; Selects the audio input source.
<li><a href="#start_sound_input">start_sound_input</a> &mdash; Starts recording in the specified format.
<li><a href="#stop_sound_input">stop_sound_input</a> &mdash; Stops audio recording.
</ul>
<li><a href="#File and compression routines">File and compression routines</a>
<ul>
<li><a href="#al_ffblk_get_size">al_ffblk_get_size</a> &mdash; Get size of file returned by al_findfirst/al_findnext.
<li><a href="#al_findclose">al_findclose</a> &mdash; Closes a previously opened search with al_findfirst().
<li><a href="#al_findfirst">al_findfirst</a> &mdash; Low-level function for searching files.
<li><a href="#al_findnext">al_findnext</a> &mdash; Finds the next file in a search started by al_findfirst().
<li><a href="#append_filename">append_filename</a> &mdash; Concatenates a filename to a path.
<li><a href="#canonicalize_filename">canonicalize_filename</a> &mdash; Converts any filename into its canonical form.
<li><a href="#create_lzss_pack_data">create_lzss_pack_data</a> &mdash; Creates an LZSS structure for compression.
<li><a href="#create_lzss_unpack_data">create_lzss_unpack_data</a> &mdash; Creates an LZSS structure for decompression.
<li><a href="#delete_file">delete_file</a> &mdash; Removes a file from the disk.
<li><a href="#exists">exists</a> &mdash; Shortcut version of file_exists() for normal files.
<li><a href="#file_exists">file_exists</a> &mdash; Tells if a file exists.
<li><a href="#file_size_ex">file_size_ex</a> &mdash; Returns the size of a file in bytes.
<li><a href="#file_time">file_time</a> &mdash; Returns the modification time of a file.
<li><a href="#find_allegro_resource">find_allegro_resource</a> &mdash; Searches for a support file in many places.
<li><a href="#fix_filename_case">fix_filename_case</a> &mdash; Converts a filename to a standardised case.
<li><a href="#fix_filename_slashes">fix_filename_slashes</a> &mdash; Converts all the directory separators to a standard character.
<li><a href="#for_each_file_ex">for_each_file_ex</a> &mdash; Executes callback() for each file matching a wildcard.
<li><a href="#free_lzss_pack_data">free_lzss_pack_data</a> &mdash; Frees an LZSS structure.
<li><a href="#free_lzss_unpack_data">free_lzss_unpack_data</a> &mdash; Frees an LZSS structure.
<li><a href="#get_executable_name">get_executable_name</a> &mdash; Obtains the full path to the current executable.
<li><a href="#get_extension">get_extension</a> &mdash; Returns a pointer to the extension of a filename.
<li><a href="#get_filename">get_filename</a> &mdash; Returns a pointer to the filename portion of a path.
<li><a href="#is_relative_filename">is_relative_filename</a> &mdash; Returns TRUE if the filename is relative.
<li><a href="#lzss_read">lzss_read</a> &mdash; Decompresses data using LZSS.
<li><a href="#lzss_write">lzss_write</a> &mdash; Compresses data using LZSS.
<li><a href="#make_absolute_filename">make_absolute_filename</a> &mdash; Makes an absolute filename from a path and relative filename.
<li><a href="#make_relative_filename">make_relative_filename</a> &mdash; Tries to make a relative filename from absolute path and filename.
<li><a href="#pack_fclose">pack_fclose</a> &mdash; Closes a stream previously opened.
<li><a href="#pack_fclose_chunk">pack_fclose_chunk</a> &mdash; Closes a previously opened sub-chunk.
<li><a href="#pack_feof">pack_feof</a> &mdash; Returns nonzero as soon as you reach the end of the file.
<li><a href="#pack_ferror">pack_ferror</a> &mdash; Tells if an error occurred during an operation on the stream.
<li><a href="#pack_fgets">pack_fgets</a> &mdash; Reads a line from the stream.
<li><a href="#pack_fopen">pack_fopen</a> &mdash; Opens a file according to mode.
<li><a href="#pack_fopen_chunk">pack_fopen_chunk</a> &mdash; Opens a sub-chunk of a file.
<li><a href="#pack_fopen_vtable">pack_fopen_vtable</a> 
<li><a href="#pack_fputs">pack_fputs</a> &mdash; Writes a string to the stream.
<li><a href="#pack_fread">pack_fread</a> &mdash; Reads n bytes from the stream.
<li><a href="#pack_fseek">pack_fseek</a> &mdash; Seeks inside a stream.
<li><a href="#pack_fwrite">pack_fwrite</a> &mdash; Writes n bytes to the stream.
<li><a href="#pack_getc">pack_getc</a> &mdash; Returns the next character from a stream.
<li><a href="#pack_igetl">pack_igetl</a> &mdash; Like pack_getc(), but using 32-bit Intel byte ordering words.
<li><a href="#pack_igetw">pack_igetw</a> &mdash; Like pack_getc(), but using 16-bit Intel byte ordering words.
<li><a href="#pack_iputl">pack_iputl</a> &mdash; Like pack_putc(), but using 32-bit Intel byte ordering words.
<li><a href="#pack_iputw">pack_iputw</a> &mdash; Like pack_putc(), but using 16-bit Intel byte ordering words.
<li><a href="#pack_mgetl">pack_mgetl</a> &mdash; Like pack_getc(), but using 32-bit Motorola byte ordering words.
<li><a href="#pack_mgetw">pack_mgetw</a> &mdash; Like pack_getc(), but using 16-bit Motorola byte ordering words.
<li><a href="#pack_mputl">pack_mputl</a> &mdash; Like pack_putc(), but using 32-bit Motorola byte ordering words.
<li><a href="#pack_mputw">pack_mputw</a> &mdash; Like pack_putc(), but using 16-bit Motorola byte ordering words.
<li><a href="#pack_putc">pack_putc</a> &mdash; Puts a character in the stream.
<li><a href="#pack_ungetc">pack_ungetc</a> &mdash; Moves one single character back to the input buffer.
<li><a href="#packfile_password">packfile_password</a> &mdash; Sets the global I/O encryption password.
<li><a href="#put_backslash">put_backslash</a> &mdash; Puts a path separator at the end of a path if needed.
<li><a href="#replace_extension">replace_extension</a> &mdash; Replaces filename+extension with a new extension tail.
<li><a href="#replace_filename">replace_filename</a> &mdash; Replaces path+filename with a new filename tail.
<li><a href="#set_allegro_resource_path">set_allegro_resource_path</a> &mdash; Sets a specific resource search path.
</ul>
<li><a href="#Datafile routines">Datafile routines</a>
<ul>
<li><a href="#create_datafile_index">create_datafile_index</a> &mdash; Creates an index for a datafile.
<li><a href="#DAT_ID">DAT_ID</a> &mdash; Makes an ID value from four letters.
<li><a href="#destroy_datafile_index">destroy_datafile_index</a> &mdash; Destroys a datafile index.
<li><a href="#find_datafile_object">find_datafile_object</a> &mdash; Searches a datafile for an object with a name.
<li><a href="#fixup_datafile">fixup_datafile</a> &mdash; Fixes truecolor images in compiled datafiles.
<li><a href="#get_datafile_property">get_datafile_property</a> &mdash; Returns the property string for the object.
<li><a href="#load_datafile">load_datafile</a> &mdash; Loads a datafile into memory.
<li><a href="#load_datafile_callback">load_datafile_callback</a> &mdash; Loads a datafile into memory, calling a hook per object.
<li><a href="#load_datafile_object">load_datafile_object</a> &mdash; Loads a specific object from a datafile.
<li><a href="#load_datafile_object_indexed">load_datafile_object_indexed</a> &mdash; Loads a single object from a datafile index.
<li><a href="#register_datafile_object">register_datafile_object</a> &mdash; Registers load/destroy functions for custom object types.
<li><a href="#unload_datafile">unload_datafile</a> &mdash; Frees all the objects in a datafile.
<li><a href="#unload_datafile_object">unload_datafile_object</a> &mdash; Frees an object previously loaded by load_datafile_object().
</ul>
<li><a href="#Fixed point math routines">Fixed point math routines</a>
<ul>
<li><a href="#fixacos">fixacos</a> &mdash; Fixed point inverse cosine lookup table.
<li><a href="#fixadd">fixadd</a> &mdash; Safe function to add fixed point numbers clamping overflow.
<li><a href="#fixasin">fixasin</a> &mdash; Fixed point inverse sine lookup table.
<li><a href="#fixatan">fixatan</a> &mdash; Fixed point inverse tangent lookup table.
<li><a href="#fixatan2">fixatan2</a> &mdash; Fixed point version of the libc atan2() routine.
<li><a href="#fixceil">fixceil</a> &mdash; Returns the smallest integer not less than x.
<li><a href="#fixcos">fixcos</a> &mdash; Fixed point cosine of binary angles.
<li><a href="#fixdiv">fixdiv</a> &mdash; Fixed point division.
<li><a href="#fixfloor">fixfloor</a> &mdash; Returns the greatest integer not greater than x.
<li><a href="#fixhypot">fixhypot</a> &mdash; Fixed point hypotenuse.
<li><a href="#fixmul">fixmul</a> &mdash; Multiplies two fixed point values together.
<li><a href="#fixsin">fixsin</a> &mdash; Fixed point sine of binary angles.
<li><a href="#fixsqrt">fixsqrt</a> &mdash; Fixed point square root.
<li><a href="#fixsub">fixsub</a> &mdash; Safe function to subtract fixed point numbers clamping underflow.
<li><a href="#fixtan">fixtan</a> &mdash; Fixed point tangent of binary angles.
<li><a href="#fixtof">fixtof</a> &mdash; Converts a fixed point to floating point.
<li><a href="#fixtoi">fixtoi</a> &mdash; Converts a fixed point to integer with rounding.
<li><a href="#fixtorad_r">fixtorad_r</a> &mdash; Constant to convert angles in fixed point format to radians.
<li><a href="#ftofix">ftofix</a> &mdash; Converts a floating point value to fixed point.
<li><a href="#itofix">itofix</a> &mdash; Converts an integer to fixed point.
<li><a href="#radtofix_r">radtofix_r</a> &mdash; Constant to convert radians to fixed point angles.
</ul>
<li><a href="#3D math routines">3D math routines</a>
<ul>
<li><a href="#apply_matrix">apply_matrix</a> &mdash; Multiplies a point by a transformation matrix.
<li><a href="#apply_matrix_f">apply_matrix_f</a> &mdash; Multiplies a point by a transformation matrix.
<li><a href="#cross_product">cross_product</a> &mdash; Calculates the cross product.
<li><a href="#cross_product_f">cross_product_f</a> &mdash; Calculates the cross product.
<li><a href="#dot_product">dot_product</a> &mdash; Calculates the dot product.
<li><a href="#dot_product_f">dot_product_f</a> &mdash; Calculates the dot product.
<li><a href="#get_align_matrix">get_align_matrix</a> &mdash; Rotates a matrix to align it along specified coordinate vectors.
<li><a href="#get_align_matrix_f">get_align_matrix_f</a> &mdash; Floating point version of get_align_matrix().
<li><a href="#get_camera_matrix">get_camera_matrix</a> &mdash; Constructs a camera matrix for perspective projection.
<li><a href="#get_camera_matrix_f">get_camera_matrix_f</a> &mdash; Floating point version of get_camera_matrix().
<li><a href="#get_rotation_matrix">get_rotation_matrix</a> &mdash; Constructs X, Y, Z rotation matrices.
<li><a href="#get_rotation_matrix_f">get_rotation_matrix_f</a> &mdash; Constructs X, Y, Z rotation matrices.
<li><a href="#get_scaling_matrix">get_scaling_matrix</a> &mdash; Constructs a scaling matrix.
<li><a href="#get_scaling_matrix_f">get_scaling_matrix_f</a> &mdash; Constructs a scaling matrix.
<li><a href="#get_transformation_matrix">get_transformation_matrix</a> &mdash; Constructs X, Y, Z rotation matrices with an angle and scaling.
<li><a href="#get_transformation_matrix_f">get_transformation_matrix_f</a> &mdash; Floating point version of get_transformation_matrix().
<li><a href="#get_translation_matrix">get_translation_matrix</a> &mdash; Constructs a translation matrix.
<li><a href="#get_translation_matrix_f">get_translation_matrix_f</a> &mdash; Constructs a translation matrix.
<li><a href="#get_vector_rotation_matrix">get_vector_rotation_matrix</a> &mdash; Constructs X, Y, Z rotation matrices with an angle.
<li><a href="#get_vector_rotation_matrix_f">get_vector_rotation_matrix_f</a> &mdash; Constructs X, Y, Z rotation matrices with an angle.
<li><a href="#get_x_rotate_matrix">get_x_rotate_matrix</a> &mdash; Construct X axis rotation matrices.
<li><a href="#get_x_rotate_matrix_f">get_x_rotate_matrix_f</a> &mdash; Construct X axis rotation matrices.
<li><a href="#get_y_rotate_matrix">get_y_rotate_matrix</a> &mdash; Construct Y axis rotation matrices.
<li><a href="#get_y_rotate_matrix_f">get_y_rotate_matrix_f</a> &mdash; Construct Y axis rotation matrices.
<li><a href="#get_z_rotate_matrix">get_z_rotate_matrix</a> &mdash; Construct Z axis rotation matrices.
<li><a href="#get_z_rotate_matrix_f">get_z_rotate_matrix_f</a> &mdash; Construct Z axis rotation matrices.
<li><a href="#identity_matrix">identity_matrix</a> &mdash; Global containing the identity matrix.
<li><a href="#identity_matrix_f">identity_matrix_f</a> &mdash; Global containing the identity matrix.
<li><a href="#matrix_mul">matrix_mul</a> &mdash; Multiplies two matrices.
<li><a href="#matrix_mul_f">matrix_mul_f</a> &mdash; Multiplies two matrices.
<li><a href="#normalize_vector">normalize_vector</a> &mdash; Converts the vector to a unit vector.
<li><a href="#normalize_vector_f">normalize_vector_f</a> &mdash; Converts the vector to a unit vector.
<li><a href="#persp_project">persp_project</a> &mdash; Projects a 3d point into 2d screen space.
<li><a href="#persp_project_f">persp_project_f</a> &mdash; Projects a 3d point into 2d screen space.
<li><a href="#polygon_z_normal">polygon_z_normal</a> &mdash; Finds the Z component of the normal vector to three vertices.
<li><a href="#polygon_z_normal_f">polygon_z_normal_f</a> &mdash; Finds the Z component of the normal vector to three vertices.
<li><a href="#qscale_matrix">qscale_matrix</a> &mdash; Optimised routine for scaling an already generated matrix.
<li><a href="#qscale_matrix_f">qscale_matrix_f</a> &mdash; Optimised routine for scaling an already generated matrix.
<li><a href="#qtranslate_matrix">qtranslate_matrix</a> &mdash; Optimised routine for translating an already generated matrix.
<li><a href="#qtranslate_matrix_f">qtranslate_matrix_f</a> &mdash; Optimised routine for translating an already generated matrix.
<li><a href="#set_projection_viewport">set_projection_viewport</a> &mdash; Sets the viewport used to scale the output of persp_project().
<li><a href="#vector_length">vector_length</a> &mdash; Calculates the length of a vector.
<li><a href="#vector_length_f">vector_length_f</a> &mdash; Calculates the length of a vector.
</ul>
<li><a href="#Quaternion math routines">Quaternion math routines</a>
<ul>
<li><a href="#apply_quat">apply_quat</a> &mdash; Multiplies a point by a quaternion.
<li><a href="#get_rotation_quat">get_rotation_quat</a> &mdash; Constructs a quaternion to rotate points around all three axes.
<li><a href="#get_vector_rotation_quat">get_vector_rotation_quat</a> &mdash; Constructs a quaternion to rotate points around a vector.
<li><a href="#get_x_rotate_quat">get_x_rotate_quat</a> &mdash; Construct axis rotation quaternions.
<li><a href="#get_y_rotate_quat">get_y_rotate_quat</a> &mdash; Construct axis rotation quaternions.
<li><a href="#get_z_rotate_quat">get_z_rotate_quat</a> &mdash; Construct axis rotation quaternions.
<li><a href="#identity_quat">identity_quat</a> &mdash; Global variable containing the identity quaternion.
<li><a href="#matrix_to_quat">matrix_to_quat</a> &mdash; Constructs a quaternion from a rotation matrix.
<li><a href="#quat_interpolate">quat_interpolate</a> &mdash; Constructs a quaternion representing a rotation between from and to.
<li><a href="#quat_mul">quat_mul</a> &mdash; Multiplies two quaternions.
<li><a href="#quat_slerp">quat_slerp</a> &mdash; Version of quat_interpolate() allowing control over the rotation.
<li><a href="#quat_to_matrix">quat_to_matrix</a> &mdash; Constructs a rotation matrix from a quaternion.
</ul>
<li><a href="#GUI routines">GUI routines</a>
<ul>
<li><a href="#active_dialog">active_dialog</a> &mdash; Global pointer to the most recent activated dialog.
<li><a href="#active_menu">active_menu</a> &mdash; Global pointer to the most recent activated menu.
<li><a href="#alert">alert</a> &mdash; Displays a popup alert box.
<li><a href="#alert3">alert3</a> &mdash; Like alert(), but with three buttons.
<li><a href="#broadcast_dialog_message">broadcast_dialog_message</a> &mdash; Broadcasts a message to all the objects in the active dialog.
<li><a href="#centre_dialog">centre_dialog</a> &mdash; Centers an array of dialog objects.
<li><a href="#d_bitmap_proc">d_bitmap_proc</a> &mdash; Dialog procedure drawing a bitmap.
<li><a href="#d_box_proc">d_box_proc</a> &mdash; Dialog procedure drawing boxes onto the screen.
<li><a href="#d_button_proc">d_button_proc</a> &mdash; Dialog procedure implementing a button object.
<li><a href="#d_check_proc">d_check_proc</a> &mdash; Dialog procedure implementing a check box object.
<li><a href="#d_clear_proc">d_clear_proc</a> &mdash; Dialog procedure to clear the screen.
<li><a href="#d_ctext_proc">d_ctext_proc</a> &mdash; Dialogs procedure drawing text onto the screen.
<li><a href="#d_edit_proc">d_edit_proc</a> &mdash; Dialog procedure implementing an editable text object.
<li><a href="#d_icon_proc">d_icon_proc</a> &mdash; Dialog procedure implementing a bitmap button.
<li><a href="#d_keyboard_proc">d_keyboard_proc</a> &mdash; Invisible dialog procedure for implementing keyboard shortcuts.
<li><a href="#d_list_proc">d_list_proc</a> &mdash; Dialog procedure implementing a list box object.
<li><a href="#d_menu_proc">d_menu_proc</a> &mdash; Dialog procedure implementing a menu bar object.
<li><a href="#d_radio_proc">d_radio_proc</a> &mdash; Dialog procedure implementing a radio button object.
<li><a href="#d_rtext_proc">d_rtext_proc</a> &mdash; Dialogs procedure drawing text onto the screen.
<li><a href="#d_shadow_box_proc">d_shadow_box_proc</a> &mdash; Dialog procedure drawing boxes onto the screen.
<li><a href="#d_slider_proc">d_slider_proc</a> &mdash; Dialog procedure implementing a slider control object.
<li><a href="#d_text_list_proc">d_text_list_proc</a> &mdash; Dialog procedure implementing a list box object with type ahead.
<li><a href="#d_text_proc">d_text_proc</a> &mdash; Dialogs procedure drawing text onto the screen.
<li><a href="#d_textbox_proc">d_textbox_proc</a> &mdash; Dialog procedure implementing a text box object.
<li><a href="#d_yield_proc">d_yield_proc</a> &mdash; Invisible dialog procedure that yields CPU time slices.
<li><a href="#dialog_message">dialog_message</a> &mdash; Sends a message to all the objects in an array.
<li><a href="#do_dialog">do_dialog</a> &mdash; Basic dialog manager function.
<li><a href="#do_menu">do_menu</a> &mdash; Displays an animates a popup menu.
<li><a href="#file_select_ex">file_select_ex</a> &mdash; Displays the Allegro file selector with a caption.
<li><a href="#find_dialog_focus">find_dialog_focus</a> &mdash; Searches the dialog for the object which has the input focus.
<li><a href="#gfx_mode_select">gfx_mode_select</a> &mdash; Displays the Allegro graphics mode selection dialog.
<li><a href="#gfx_mode_select_ex">gfx_mode_select_ex</a> &mdash; Extended version of the graphics mode selection dialog.
<li><a href="#gfx_mode_select_filter">gfx_mode_select_filter</a> &mdash; Even more extended version of the graphics mode selection dialog.
<li><a href="#gui_bg_color">gui_bg_color</a> &mdash; The foreground and background colors for the standard dialogs.
<li><a href="#gui_button_proc">gui_button_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_ctext_proc">gui_ctext_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_edit_proc">gui_edit_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_fg_color">gui_fg_color</a> &mdash; The foreground and background colors for the standard dialogs.
<li><a href="#gui_font_baseline">gui_font_baseline</a> &mdash; Adjusts the keyboard shortcut underscores height.
<li><a href="#gui_get_screen">gui_get_screen</a> &mdash; Returns the bitmap surface GUI routines draw to.
<li><a href="#gui_list_proc">gui_list_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_menu_draw_menu">gui_menu_draw_menu</a> &mdash; Hooks to modify the appearance of menus.
<li><a href="#gui_menu_draw_menu_item">gui_menu_draw_menu_item</a> &mdash; Hooks to modify the appearance of menus.
<li><a href="#gui_mg_color">gui_mg_color</a> &mdash; The color used for displaying greyed-out dialog objects.
<li><a href="#gui_mouse_b">gui_mouse_b</a> &mdash; Hook functions used by the GUI routines to access the mouse state.
<li><a href="#gui_mouse_focus">gui_mouse_focus</a> &mdash; Tells if the input focus follows the mouse pointer.
<li><a href="#gui_mouse_x">gui_mouse_x</a> &mdash; Hook functions used by the GUI routines to access the mouse state.
<li><a href="#gui_mouse_y">gui_mouse_y</a> &mdash; Hook functions used by the GUI routines to access the mouse state.
<li><a href="#gui_mouse_z">gui_mouse_z</a> &mdash; Hook functions used by the GUI routines to access the mouse state.
<li><a href="#gui_set_screen">gui_set_screen</a> &mdash; Changes the bitmap surface GUI routines draw to.
<li><a href="#gui_shadow_box_proc">gui_shadow_box_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_strlen">gui_strlen</a> &mdash; Returns the length of a string in pixels.
<li><a href="#gui_text_list_proc">gui_text_list_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_textout_ex">gui_textout_ex</a> &mdash; Draws a text string onto the screen with keyboard shortcut underbars.
<li><a href="#init_dialog">init_dialog</a> &mdash; Low level initialisation of a dialog.
<li><a href="#init_menu">init_menu</a> &mdash; Low level initialisation of a menu.
<li><a href="#object_message">object_message</a> &mdash; Sends a message to an object and returns the answer.
<li><a href="#offer_focus">offer_focus</a> &mdash; Offers the input focus to a particular object.
<li><a href="#popup_dialog">popup_dialog</a> &mdash; do_dialog() used for popup dialogs.
<li><a href="#position_dialog">position_dialog</a> &mdash; Moves an array of dialog objects to the specified position.
<li><a href="#set_dialog_color">set_dialog_color</a> &mdash; Sets the colors of an array of dialog objects.
<li><a href="#shutdown_dialog">shutdown_dialog</a> &mdash; Destroys a dialog player returned by init_dialog().
<li><a href="#shutdown_menu">shutdown_menu</a> &mdash; Destroys a menu player object returned by init_menu().
<li><a href="#update_dialog">update_dialog</a> &mdash; Low level function to update a dialog player.
<li><a href="#update_menu">update_menu</a> &mdash; Low level function to update a menu player.
</ul>
<li><a href="#DOS specifics">DOS specifics</a>
<ul>
<li><a href="#DIGI_*/DOS">DIGI_*/DOS</a> &mdash; Supported DOS digital sound drivers.
<li><a href="#GFX_*/DOS">GFX_*/DOS</a> &mdash; Supported DOS graphic drivers.
<li><a href="#i_love_bill">i_love_bill</a> &mdash; Tells if Allegro has to used fixed rate timers.
<li><a href="#JOY_TYPE_*/DOS">JOY_TYPE_*/DOS</a> &mdash; Supported DOS joystick drivers.
<li><a href="#MIDI_*/DOS">MIDI_*/DOS</a> &mdash; Supported DOS MIDI sound drivers.
</ul>
<li><a href="#Windows specifics">Windows specifics</a>
<ul>
<li><a href="#blit_from_hdc">blit_from_hdc</a> &mdash; Blits from a Windows device context to an Allegro memory bitmap.
<li><a href="#blit_to_hdc">blit_to_hdc</a> &mdash; Blits an Allegro memory bitmap to a Windows device context.
<li><a href="#convert_bitmap_to_hbitmap">convert_bitmap_to_hbitmap</a> &mdash; Converts an Allegro memory bitmap to a Windows DDB.
<li><a href="#convert_hbitmap_to_bitmap">convert_hbitmap_to_bitmap</a> &mdash; Creates an Allegro memory bitmap from a Windows DDB.
<li><a href="#convert_hpalette_to_palette">convert_hpalette_to_palette</a> &mdash; Converts a Windows palette to an Allegro palette.
<li><a href="#convert_palette_to_hpalette">convert_palette_to_hpalette</a> &mdash; Converts an Allegro palette to a Windows palette.
<li><a href="#DIGI_*/Windows">DIGI_*/Windows</a> &mdash; Supported Windows digital sound drivers.
<li><a href="#draw_to_hdc">draw_to_hdc</a> &mdash; Draws an Allegro bitmap to a Windows device context.
<li><a href="#GFX_*/Windows">GFX_*/Windows</a> &mdash; Supported Windows graphic drivers.
<li><a href="#JOY_TYPE_*/Windows">JOY_TYPE_*/Windows</a> &mdash; Supported Windows joystick drivers.
<li><a href="#MIDI_*/Windows">MIDI_*/Windows</a> &mdash; Supported Windows MIDI sound drivers.
<li><a href="#set_gdi_color_format">set_gdi_color_format</a> &mdash; Tells Allegro to use the GDI color layout for truecolor images.
<li><a href="#set_palette_to_hdc">set_palette_to_hdc</a> &mdash; Selects and realizes a palette on the specified device context.
<li><a href="#stretch_blit_from_hdc">stretch_blit_from_hdc</a> &mdash; Blits from a Windows device context to an Allegro memory bitmap.
<li><a href="#stretch_blit_to_hdc">stretch_blit_to_hdc</a> &mdash; Blits an Allegro memory bitmap to a Windows device context.
<li><a href="#win_get_dc">win_get_dc</a> &mdash; Retrieves a handle to the device context.
<li><a href="#win_get_window">win_get_window</a> &mdash; Retrieves a handle to the window used by Allegro.
<li><a href="#win_release_dc">win_release_dc</a> &mdash; Releases a handle to the device context.
<li><a href="#win_set_window">win_set_window</a> &mdash; Registers an user-created window to be used by Allegro.
<li><a href="#win_set_wnd_create_proc">win_set_wnd_create_proc</a> &mdash; Registers a custom procedure to be used by Allegro for creating its window.
</ul>
<li><a href="#Unix specifics">Unix specifics</a>
<ul>
<li><a href="#allegro_icon">allegro_icon</a> &mdash; Pointer to the Allegro X11 icon.
<li><a href="#DIGI_*/Unix">DIGI_*/Unix</a> &mdash; Supported Unix digital sound drivers.
<li><a href="#GFX_*/Linux">GFX_*/Linux</a> &mdash; Supported Linux console graphic drivers.
<li><a href="#GFX_*/X">GFX_*/X</a> &mdash; Supported X graphic drivers.
<li><a href="#JOY_TYPE_*/Linux">JOY_TYPE_*/Linux</a> &mdash; Supported Linux joystick drivers.
<li><a href="#MIDI_*/Unix">MIDI_*/Unix</a> &mdash; Supported Unix MIDI sound drivers.
<li><a href="#xwin_set_window_name">xwin_set_window_name</a> &mdash; Specify the window name and group (or class).
</ul>
<li><a href="#BeOS specifics">BeOS specifics</a>
<ul>
<li><a href="#DIGI_*/BeOS">DIGI_*/BeOS</a> &mdash; Supported BeOS digital sound drivers.
<li><a href="#GFX_*/BeOS">GFX_*/BeOS</a> &mdash; Supported BeOS graphic drivers.
<li><a href="#MIDI_*/BeOS">MIDI_*/BeOS</a> &mdash; Supported BeOS MIDI sound drivers.
</ul>
<li><a href="#QNX specifics">QNX specifics</a>
<ul>
<li><a href="#DIGI_*/QNX">DIGI_*/QNX</a> &mdash; Supported QNX digital sound drivers.
<li><a href="#GFX_*/QNX">GFX_*/QNX</a> &mdash; Supported QNX graphic drivers.
<li><a href="#MIDI_*/QNX">MIDI_*/QNX</a> &mdash; Supported QNX MIDI sound drivers.
<li><a href="#qnx_get_window">qnx_get_window</a> &mdash; Retrieves a handle to the window used by Allegro.
</ul>
<li><a href="#MacOS X specifics">MacOS X specifics</a>
<ul>
<li><a href="#DIGI_*/MacOSX">DIGI_*/MacOSX</a> &mdash; Supported MacOSX digital sound drivers.
<li><a href="#GFX_*/MacOSX">GFX_*/MacOSX</a> &mdash; Supported MacOSX graphic drivers.
<li><a href="#MIDI_*/MacOSX">MIDI_*/MacOSX</a> &mdash; Supported MacOSX MIDI sound drivers.
</ul>
<li><a href="#Differences between platforms">Differences between platforms</a>
<li><a href="#Reducing your executable size">Reducing your executable size</a>
<li><a href="#Debugging">Debugging</a>
<ul>
<li><a href="#al_assert">al_assert</a> &mdash; Asserts at the specified file and line number.
<li><a href="#al_trace">al_trace</a> &mdash; Outputs a debugging trace message.
<li><a href="#ASSERT">ASSERT</a> &mdash; Debugging helper macro to assert.
<li><a href="#register_assert_handler">register_assert_handler</a> &mdash; Registers a custom handler for assert failures.
<li><a href="#register_trace_handler">register_trace_handler</a> &mdash; Registers a custom handler for trace output.
<li><a href="#TRACE">TRACE</a> &mdash; Debugging helper macro to trace messages.
</ul>
<li><a href="#Makefile targets">Makefile targets</a>
<li><a href="#Available Allegro examples">Available Allegro examples</a>
<ul>
<li><a href="#ex12bit">ex12bit</a> &mdash; How to fake a 12-bit truecolor mode on an 8-bit card.
<li><a href="#ex3buf">ex3buf</a> &mdash; Mode-X triple buffering and retrace interrupt simulation.
<li><a href="#ex3d">ex3d</a> &mdash; 3d 'bouncy cubes' demo.
<li><a href="#exaccel">exaccel</a> &mdash; Using offscreen video memory to store source graphics for VBE/AF.
<li><a href="#exalpha">exalpha</a> &mdash; Creating and using 32 bit RGBA sprites.
<li><a href="#exbitmap">exbitmap</a> &mdash; Loading and displaying PCX and BMP files.
<li><a href="#exblend">exblend</a> &mdash; Using translucency in truecolor modes.
<li><a href="#excamera">excamera</a> &mdash; Viewing a 3d world from an arbitrary camera position.
<li><a href="#excolmap">excolmap</a> &mdash; Creating graphical effects with color mapping tables.
<li><a href="#exconfig">exconfig</a> &mdash; Using the configuration routines.
<li><a href="#excustom">excustom</a> &mdash; Creating custom GUI objects.
<li><a href="#exdata">exdata</a> &mdash; Accessing the contents of datafiles.
<li><a href="#exdbuf">exdbuf</a> &mdash; How to use double buffering to avoid flicker.
<li><a href="#exexedat">exexedat</a> &mdash; Appending datafiles onto your executable.
<li><a href="#exfixed">exfixed</a> &mdash; Using fixed point maths.
<li><a href="#exflame">exflame</a> &mdash; How to write directly to video memory improving performance.
<li><a href="#exflip">exflip</a> &mdash; Comparison of double buffering and page flipping.
<li><a href="#exfont">exfont</a> 
<li><a href="#exgui">exgui</a> &mdash; Using the GUI routines.
<li><a href="#exhello">exhello</a> &mdash; Simple graphical "hello world" program.
<li><a href="#exjoy">exjoy</a> &mdash; Detecting, calibrating and using joystick input.
<li><a href="#exkeys">exkeys</a> &mdash; How to get input from the keyboard in different ways.
<li><a href="#exlights">exlights</a> &mdash; One way to do colored lighting effects in a hicolor video mode.
<li><a href="#exmem">exmem</a> &mdash; Drawing onto memory bitmaps and then blitting them to the screen.
<li><a href="#exmidi">exmidi</a> &mdash; Playing MIDI music.
<li><a href="#exmouse">exmouse</a> &mdash; Getting input from the mouse.
<li><a href="#expackf">expackf</a> &mdash; Using custom PACKFILE vtables.
<li><a href="#expal">expal</a> &mdash; Palette effects and color cycling.
<li><a href="#expat">expat</a> &mdash; Using patterned drawing modes and sub-bitmaps.
<li><a href="#exquat">exquat</a> &mdash; A comparison between Euler angles and quaternions.
<li><a href="#exrgbhsv">exrgbhsv</a> &mdash; RGB <-> HSV color space conversions.
<li><a href="#exsample">exsample</a> &mdash; Playing digital samples.
<li><a href="#exscale">exscale</a> &mdash; Loading PCX files and bitmap stretching.
<li><a href="#exscn3d">exscn3d</a> &mdash; Using the 3d scene functions.
<li><a href="#exscroll">exscroll</a> &mdash; Mode-X hardware scrolling and split screens.
<li><a href="#exshade">exshade</a> &mdash; Gouraud shaded sprites.
<li><a href="#exspline">exspline</a> &mdash; Constructing smooth movement paths from spline curves.
<li><a href="#exsprite">exsprite</a> &mdash; Datafiles access and sprite animation.
<li><a href="#exstars">exstars</a> &mdash; 3d starfield and lightsourced spaceship.
<li><a href="#exstream">exstream</a> &mdash; Playing audio streams.
<li><a href="#exswitch">exswitch</a> &mdash; Controlling the console switch mode for background running.
<li><a href="#exsyscur">exsyscur</a> 
<li><a href="#extimer">extimer</a> &mdash; Using the timer (delays and interrupts).
<li><a href="#extrans">extrans</a> &mdash; Lighting and translucency effects.
<li><a href="#extruec">extruec</a> &mdash; Truecolor pixel format conversions.
<li><a href="#exunicod">exunicod</a> &mdash; Using Unicode string functions.
<li><a href="#exupdate">exupdate</a> &mdash; Supporting different screen update methods in a single program.
<li><a href="#exxfade">exxfade</a> &mdash; Truecolor image loading and fades.
<li><a href="#exzbuf">exzbuf</a> &mdash; Z-buffered polygons demo.
</ul>
<li><a href="#Community">Community</a>
<li><a href="#Conclusion">Conclusion</a>
<li><a href="#Index">Index</a>
</ul>



<p><br>
<h1><a name="Using Allegro">Using Allegro</a></h1>

<p>
See <a href="readme.html">readme.txt</a> for a general introduction, copyright details, and 
information about how to install Allegro and link your program with it.

<p><br>
<div class="al-api"><b>int <a name="install_allegro">install_allegro</a>(int system_id, int *errno_ptr, int (*atexit_ptr)());</b></div><br>
   Initialises the Allegro library. You must call either this or 
   allegro_init() before doing anything other than using the Unicode 
   routines. If you want to use a text mode other than UTF-8, you can set
   it with set_uformat() before you call this. The other functions that can
   be called before this one will be marked explicitly in the documentation,
   like set_config_file().

<p>
   The available system ID codes will vary from one platform to another, but
   you will almost always want to pass SYSTEM_AUTODETECT. Alternatively,
   SYSTEM_NONE installs a stripped down version of Allegro that won't even
   try to touch your hardware or do anything platform specific: this can be
   useful for situations where you only want to manipulate memory bitmaps,
   such as the text mode datafile tools or the Windows GDI interfacing
   functions.

<p>
   The <tt>`errno_ptr'</tt> and <tt>`atexit_ptr'</tt> parameters should point to the errno
   variable and atexit function from your libc: these are required because
   when Allegro is linked as a DLL, it doesn't have direct access to your
   local libc data. <tt>`atexit_ptr'</tt> may be NULL, in which case it is your
   responsibility to call allegro_exit() manually. Example:
<blockquote class="code"><pre>
      <a href="#install_allegro" class="autotype" title="Initialise the Allegro library.">install_allegro</a>(SYSTEM_AUTODETECT, &amp;errno, atexit);</pre></blockquote>
<p><b>Return value:</b>
   This function returns zero on success and non-zero on failure (e.g. no
   system driver could be used). Note: in previous versions of Allegro this
   function would abort on error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>,
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>,
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>.</blockquote>
<div class="al-api"><b>int <a name="allegro_init">allegro_init</a>();</b></div><br>
   Macro which initialises the Allegro library. This is the same thing as
   calling install_allegro(SYSTEM_AUTODETECT, &amp;errno, atexit).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_allegro" title="Initialise the Allegro library.">install_allegro</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="allegro_exit">allegro_exit</a>();</b></div><br>
   Closes down the Allegro system. This includes returning the system to
   text mode and removing whatever mouse, keyboard, and timer routines have
   been installed. You don't normally need to bother making an explicit call
   to this function, because allegro_init() installs it as an atexit()
   routine so it will be called automatically when your program exits.

<p>
   Note that after you call this function, other functions like
   destroy_bitmap() will most likely crash. This is a problem for C++ global
   destructors, which usually get called after atexit(), so don't put Allegro
   calls in them. You can write the destructor code in another method which
   you can manually call before your program exits, avoiding this problem.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_allegro" title="Initialise the Allegro library.">install_allegro</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="#exxfade" title="Truecolor image loading and fades.">exxfade</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>Macro <a name="END_OF_MAIN">END_OF_MAIN</a>()</b></div><br>
   In order to maintain cross-platform compatibility, you have to put this
   macro at the very end of your main function. This macro uses some <tt>`magic'</tt>
   to mangle your main procedure on platforms that need it like Windows,
   some flavours of UNIX or MacOS X. On the other platforms this macro 
   compiles to nothing, so you don't have to #ifdef around it. Example:
<blockquote class="code"><pre>
      int main(void)
      {
         <a href="#allegro_init" class="autotype" title="Macro to initialise the Allegro library.">allegro_init</a>();
         /* more stuff goes here */
         ...
         return 0;
      }
      <a href="#END_OF_MAIN" class="autotype" title="Macro to put after your main() function.">END_OF_MAIN</a>()</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Windows specifics" title="">Windows specifics</a>,
<a class="xref" href="#Unix specifics" title="">Unix specifics</a>,
<a class="xref" href="#MacOS X specifics" title="">MacOS X specifics</a>,
<a class="xref" href="#Differences between platforms" title="">Differences between platforms</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>extern char <a name="allegro_id">allegro_id</a>[];</b></div><br>
   Text string containing a date and version number for the library, in case 
   you want to display these somewhere.

<p><br>
<div class="al-api"><b>extern char <a name="allegro_error">allegro_error</a>[ALLEGRO_ERROR_SIZE];</b></div><br>
   Text string used by set_gfx_mode(), install_sound() and other functions to
   report error messages. If they fail and you want to tell the user why, this
   is the place to look for a description of the problem. Example:
<blockquote class="code"><pre>
      void abort_on_error(const char *message)
      {
         if (<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> != NULL)
            <a href="#set_gfx_mode" class="autotype" title="Sets a graphic video mode.">set_gfx_mode</a>(GFX_TEXT, 0, 0, 0, 0);

         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("%s.\nLast Allegro error `%s'\n",
                         message, <a href="#allegro_error" class="autotype" title="Stores the last Allegro error message.">allegro_error</a>);
         exit(-1);
      }
      ...
         if (some_allegro_function() == ERROR_CODE)
            abort_on_error("Error calling some function!");</pre></blockquote>

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>#define <a name="ALLEGRO_VERSION">ALLEGRO_VERSION</a></b></div><br>
   Defined to the major version of Allegro. From a version number like
   4.1.16, this would be defined to the integer 4.
   
<p><br>
<div class="al-api"><b>#define <a name="ALLEGRO_SUB_VERSION">ALLEGRO_SUB_VERSION</a></b></div><br>
   Defined to the middle version of Allegro. From a version number like
   4.1.16, this would be defined to the integer 1.
   
<p><br>
<div class="al-api"><b>#define <a name="ALLEGRO_WIP_VERSION">ALLEGRO_WIP_VERSION</a></b></div><br>
   Defined to the minor version of Allegro. From a version number like
   4.1.16, this would be defined to the integer 16.
   
<p><br>
<div class="al-api"><b>#define <a name="ALLEGRO_VERSION_STR">ALLEGRO_VERSION_STR</a></b></div><br>
   Defined to a text string containing all version numbers and maybe some
   additional text. This could be `4.2.1 (SVN)' for an Allegro version
   obtained straight from the SVN repository.
   
<p><br>
<div class="al-api"><b>#define <a name="ALLEGRO_DATE_STR">ALLEGRO_DATE_STR</a></b></div><br>
   Defined to a text string containing the year this version of Allegro was
   released, like <tt>`2004'</tt>.
   
<p><br>
<div class="al-api"><b>#define <a name="ALLEGRO_DATE">ALLEGRO_DATE</a></b></div><br>
   Defined to an integer containing the release date of Allegro in the packed
   format <tt>`yyyymmdd'</tt>. Example:
<blockquote class="code"><pre>
      const int year = <a href="#ALLEGRO_DATE" class="autotype" title="Defined to a number with the release date of Allegro.">ALLEGRO_DATE</a> / 10000;
      const int month = (<a href="#ALLEGRO_DATE" class="autotype" title="Defined to a number with the release date of Allegro.">ALLEGRO_DATE</a> / 100) % 100;
      const int day = <a href="#ALLEGRO_DATE" class="autotype" title="Defined to a number with the release date of Allegro.">ALLEGRO_DATE</a> % 100;

      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("Year %d, month %d, day %d\n",
         year, month, day);</pre></blockquote>

<p><br>
<div class="al-api"><b>Macro <a name="AL_ID">AL_ID</a>(a,b,c,d)</b></div><br>
   This macro can be used to create a packed 32 bit integer from 8 bit
   characters, on both 32 and 64 bit machines. These can be used for various 
   things, like custom datafile objects or system IDs. Example:
<blockquote class="code"><pre>
      #define OSTYPE_LINUX       <a href="#AL_ID" class="autotype" title="Converts four 8 bit values to a packed 32 bit integer ID.">AL_ID</a>('T','U','X',' ')</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#DAT_ID" title="Makes an ID value from four letters.">DAT_ID</a>.</blockquote>
<div class="al-api"><b>Macro <a name="MAKE_VERSION">MAKE_VERSION</a>(a, b, c)</b></div><br>
   This macro can be used to check if some Allegro version is (binary)
   compatible with the current version. It is safe to use &gt; and &lt; to
   check if one version is more recent than another.
   The third number is ignored if the second number is even, so
   MAKE_VERSION(4, 2, 0) is equivalent to MAKE_VERSION(4, 2, 1).
   This is because of our version numbering policy since 4.0.0:
   the second number is even for stable releases, which must be
   ABI-compatible with earlier versions of the same series.
   This macro is mainly useful for addon packages and libraries. See the 
   `ABI compatibility information' section of the manual for more detailed 
   information. Example:
<blockquote class="code"><pre>
      /* Check if the current version is compatible with Allegro 4.2.0 */
      #if (<a href="#MAKE_VERSION" class="autotype" title="Create a 32 bit integer from the Allegro version">MAKE_VERSION</a>(4, 2, 0) &lt;= <a href="#MAKE_VERSION" class="autotype" title="Create a 32 bit integer from the Allegro version">MAKE_VERSION</a>(<a href="#ALLEGRO_VERSION" class="autotype" title="Defined to the major version of Allegro.">ALLEGRO_VERSION</a>, \
                         <a href="#ALLEGRO_SUB_VERSION" class="autotype" title="Defined to the middle version of Allegro.">ALLEGRO_SUB_VERSION</a>, <a href="#ALLEGRO_WIP_VERSION" class="autotype" title="Defined to the minor version of Allegro.">ALLEGRO_WIP_VERSION</a>))
         /* Allegro 4.2.0 compatibility */
      #else
         /* Work-around */
      #endif</pre></blockquote>
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ALLEGRO_VERSION" title="Defined to the major version of Allegro.">ALLEGRO_VERSION</a>,
<a class="xref" href="#ALLEGRO_SUB_VERSION" title="Defined to the middle version of Allegro.">ALLEGRO_SUB_VERSION</a>,
<a class="xref" href="#ALLEGRO_WIP_VERSION" title="Defined to the minor version of Allegro.">ALLEGRO_WIP_VERSION</a>.</blockquote>
<div class="al-api"><b>extern int <a name="os_type">os_type</a>;</b></div><br>
   Set by allegro_init() to one of the values:
<blockquote class="text"><pre>
      OSTYPE_UNKNOWN    - unknown, or regular MSDOS
      OSTYPE_WIN3       - Windows 3.1 or earlier
      OSTYPE_WIN95      - Windows 95
      OSTYPE_WIN98      - Windows 98
      OSTYPE_WINME      - Windows ME
      OSTYPE_WINNT      - Windows NT
      OSTYPE_WIN2000    - Windows 2000
      OSTYPE_WINXP      - Windows XP
      OSTYPE_WIN2003    - Windows 2003
      OSTYPE_WINVISTA   - Windows Vista
      OSTYPE_OS2        - OS/2
      OSTYPE_WARP       - OS/2 Warp 3
      OSTYPE_DOSEMU     - Linux DOSEMU
      OSTYPE_OPENDOS    - Caldera OpenDOS
      OSTYPE_LINUX      - Linux
      OSTYPE_SUNOS      - SunOS/Solaris
      OSTYPE_FREEBSD    - FreeBSD
      OSTYPE_NETBSD     - NetBSD
      OSTYPE_IRIX       - IRIX
      OSTYPE_DARWIN     - Darwin
      OSTYPE_QNX        - QNX
      OSTYPE_UNIX       - Unknown Unix variant
      OSTYPE_BEOS       - BeOS
      OSTYPE_MACOS      - MacOS
      OSTYPE_MACOSX     - MacOS X</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#os_version" title="Version of the OS currently running.">os_version</a>,
<a class="xref" href="#os_multitasking" title="Indicates if the OS is multitasking.">os_multitasking</a>.</blockquote>
<div class="al-api"><b>extern int <a name="os_version">os_version</a>;</b></div><br>
<div class="al-api-cont"><b>extern int <a name="os_revision">os_revision</a>;</b></div><br>
   The major and minor version of the Operating System currently running.
   Set by allegro_init(). If Allegro for some reason was not able to
   retrieve the version of the Operating System, os_version and
   os_revision will be set to -1. For example: Under Win98 SE (v4.10.2222)
   os_version will be set to 4 and os_revision to 10.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#os_type" title="Stores the detected type of the OS.">os_type</a>,
<a class="xref" href="#os_multitasking" title="Indicates if the OS is multitasking.">os_multitasking</a>.</blockquote>
<div class="al-api"><b>extern int <a name="os_multitasking">os_multitasking</a>;</b></div><br>
   Set by allegro_init() to either TRUE or FALSE depending on whether your
   Operating System is multitasking or not.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#os_type" title="Stores the detected type of the OS.">os_type</a>,
<a class="xref" href="#os_version" title="Version of the OS currently running.">os_version</a>.</blockquote>
<div class="al-api"><b>void <a name="allegro_message">allegro_message</a>(const char *text_format, ...);</b></div><br>
   Outputs a message, using a printf() format string. Usually you want to
   use this to report messages to the user in an OS independent way when some
   Allegro subsystem cannot be initialised. But you must not use this function
   if you are in a graphic mode, only before calling set_gfx_mode(), or after
   a set_gfx_mode(GFX_TEXT). Also, this function depends on a system driver
   being installed, which means that it won't display the message at all on
   some platforms if Allegro has not been initialised correctly.

<p>
   On platforms featuring a windowing system, it will bring up a blocking GUI
   message box. If there is no windowing system, it will try to print the
   string to a text console, attempting to work around codepage differences
   by reducing any accented characters to 7-bit ASCII approximations.
   Example:
<blockquote class="code"><pre>
      if (<a href="#allegro_init" class="autotype" title="Macro to initialise the Allegro library.">allegro_init</a>() != 0)
         exit(1);

      if (init_my_data() != 0) {
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("Sorry, missing game data!\n");
         exit(2);
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#install_allegro" title="Initialise the Allegro library.">install_allegro</a>,
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="set_window_title">set_window_title</a>(const char *name);</b></div><br>
   On platforms that are capable of it, this routine alters the window title 
   for your Allegro program. Note that Allegro cannot set the window title 
   when running in a DOS box under Windows. Example:
<blockquote class="code"><pre>
      <a href="#set_window_title" class="autotype" title="Sets the window title of the Allegro program.">set_window_title</a>("Allegro rules!");</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_close_button_callback" title="Handles the user clicking on the close button of the window.">set_close_button_callback</a>,
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>int <a name="set_close_button_callback">set_close_button_callback</a>(void (*proc)(void));</b></div><br>
   On platforms that have a close button, this routine installs a callback 
   function to handle the close event. In other words, when the user clicks 
   the close button on your program's window or any equivalent device, the
   function you specify here will be called.

<p>
   This function should not generally attempt to exit the program or save 
   any data itself. The function could be called at any time, and there is 
   usually a risk of conflict with the main thread of the program. Instead, 
   you should set a flag during this function, and test it on a regular 
   basis in the main loop of the program.

<p>
   Pass NULL as the <tt>`proc'</tt> argument to this function to disable the close
   button functionality, which is the default state.

<p>
   Note that Allegro cannot intercept the close button of a DOS box in 
   Windows.
   
<p>
   Also note that the supplied callback is also called under MacOS X when
   the user hits Command-Q or selects "Quit" from the application menu.
   Example:
<blockquote class="code"><pre>
      volatile int close_button_pressed = FALSE;

      void close_button_handler(void)
      {
         close_button_pressed = TRUE;
      }
      <a href="#END_OF_FUNCTION" class="autotype" title="Locks the code used by a timer.">END_OF_FUNCTION</a>(close_button_handler)
      ...
      
      <a href="#allegro_init" class="autotype" title="Macro to initialise the Allegro library.">allegro_init</a>();
      <a href="#LOCK_FUNCTION" class="autotype" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>(close_button_handler);
      <a href="#set_close_button_callback" class="autotype" title="Handles the user clicking on the close button of the window.">set_close_button_callback</a>(close_button_handler);
      ...
         
      while (!close_button_pressed)
         do_stuff();</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success and non-zero on failure (e.g. the feature is not
   supported by the platform).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_window_title" title="Sets the window title of the Allegro program.">set_window_title</a>.</blockquote>
<div class="al-api"><b>int <a name="desktop_color_depth">desktop_color_depth</a>();</b></div><br>
   Finds out the currently selected desktop color depth. You can use this
   information to make your program use the same color depth as the desktop,
   which will likely make it run faster because the graphic driver won't be
   doing unnecessary color conversions behind your back.

<p>
   Under some OSes, switching to a full screen graphics mode may automatically
   change the desktop color depth. You have, therefore, to call this function
   before setting any graphics mode in order to retrieve the real desktop
   color depth. Example:
<blockquote class="code"><pre>
      <a href="#allegro_init" class="autotype" title="Macro to initialise the Allegro library.">allegro_init</a>();
      ...
      if ((depth = <a href="#desktop_color_depth" class="autotype" title="Finds out the desktop color depth.">desktop_color_depth</a>()) != 0) {
         <a href="#set_color_depth" class="autotype" title="Sets the global pixel color depth.">set_color_depth</a>(depth);
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns the color depth or zero on platforms where this information is not
   available or does not apply.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_desktop_resolution" title="Finds out the desktop resolution.">get_desktop_resolution</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>.</blockquote>
<div class="al-api"><b>int <a name="get_desktop_resolution">get_desktop_resolution</a>(int *width, int *height);</b></div><br>
   Finds out the currently selected desktop resolution. You can use this
   information to avoid creating windows bigger than the current resolution.
   This is especially important for some windowed drivers which are unable
   to create windows bigger than the desktop. Each parameter is a pointer
   to an integer where one dimension of the screen will be stored.

<p>
   Under some OSes, switching to a full screen graphics mode may automatically
   change the desktop resolution. You have, therefore, to call this function
   before setting any graphics mode in order to retrieve the real desktop
   resolution. Example:
<blockquote class="code"><pre>
      int width, height;
      
      <a href="#allegro_init" class="autotype" title="Macro to initialise the Allegro library.">allegro_init</a>();
      ...
      if (<a href="#get_desktop_resolution" class="autotype" title="Finds out the desktop resolution.">get_desktop_resolution</a>(&amp;width, &amp;height) == 0) {
         /* Got the resolution correctly */
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success, or a negative number if this information is not
   available or does not apply, in which case the values stored in the
   variables you provided for <tt>`width'</tt> and <tt>`height'</tt> are undefined.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#desktop_color_depth" title="Finds out the desktop color depth.">desktop_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="check_cpu">check_cpu</a>();</b></div><br>
   Detects the CPU type, setting the following global variables. You don't 
   normally need to call this, because allegro_init() will do it for you.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#cpu_vendor" title="Contains the CPU vendor name.">cpu_vendor</a>,
<a class="xref" href="#cpu_family" title="Contains the CPU type.">cpu_family</a>,
<a class="xref" href="#cpu_model" title="Contains the Intel CPU submodel.">cpu_model</a>,
<a class="xref" href="#cpu_capabilities" title="Contains the capability flags of the CPU.">cpu_capabilities</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>.</blockquote>
<div class="al-api"><b>extern char <a name="cpu_vendor">cpu_vendor</a>[];</b></div><br>
   On Intel PCs, contains the CPU vendor name if known. On Mac OSX systems 
   this contains the PPC subtype name. On other platforms, this may be an empty
   string. You can read this variable after you have called check_cpu()
   (which is automatically called by allegro_init()).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#check_cpu" title="Detects the CPU type.">check_cpu</a>,
<a class="xref" href="#cpu_family" title="Contains the CPU type.">cpu_family</a>,
<a class="xref" href="#cpu_model" title="Contains the Intel CPU submodel.">cpu_model</a>,
<a class="xref" href="#cpu_capabilities" title="Contains the capability flags of the CPU.">cpu_capabilities</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>.</blockquote>
<div class="al-api"><b>extern int <a name="cpu_family">cpu_family</a>;</b></div><br>
   Contains the Intel type, where applicable. Allegro defines the following
   CPU family types:
<blockquote class="text"><pre>
      CPU_FAMILY_UNKNOWN  - The type of processor is unknown
      CPU_FAMILY_I386     - The processor is an Intel-compatible 386
      CPU_FAMILY_I486     - The processor is an Intel-compatible 486
      CPU_FAMILY_I586     - The processor is a Pentium or equivalent
      CPU_FAMILY_I686     - The processor is a Pentium Pro, II, III
                            or equivalent
      CPU_FAMILY_ITANIUM  - The processor is an Itanium processor
      CPU_FAMILY_POWERPC  - The processor is a PowerPC processor
      CPU_FAMILY_EXTENDED - The processor type needs to be read
                            from the cpu_model
</pre></blockquote>
   You can read this variable after you have called check_cpu()
   (which is automatically called by allegro_init()).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#check_cpu" title="Detects the CPU type.">check_cpu</a>,
<a class="xref" href="#cpu_vendor" title="Contains the CPU vendor name.">cpu_vendor</a>,
<a class="xref" href="#cpu_model" title="Contains the Intel CPU submodel.">cpu_model</a>,
<a class="xref" href="#cpu_capabilities" title="Contains the capability flags of the CPU.">cpu_capabilities</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>.</blockquote>
<div class="al-api"><b>extern int <a name="cpu_model">cpu_model</a>;</b></div><br>
   Contains the CPU submodel, where applicable. Allegro defines at least the 
   following CPU family types (see include/allegro/system.h for a more 
   complete list):
<blockquote class="text"><pre>
      CPU_FAMILY_I586:
         CPU_MODEL_PENTIUM, CPU_MODEL_K5, CPU_MODEL_K6

      CPU_FAMILY_I686:
         CPU_MODEL_PENTIUMPRO, CPU_MODEL_PENTIUMII,
         CPU_MODEL_PENTIUMIIIKATMAI, CPU_MODEL_PENTIUMIIICOPPERMINE,
         CPU_MODEL_ATHLON, CPU_MODEL_DURON

      CPU_FAMILY_EXTENDED:
         CPU_MODEL_PENTIUMIV, CPU_MODEL_XEON,
         CPU_MODEL_ATHLON64, CPU_MODEL_OPTERON

      CPU_FAMILY_POWERPC:
         CPU_MODEL_POWERPC_x, for x=601-604, 620, 750, 7400, 7450
</pre></blockquote>
   You can read this variable after you have called check_cpu() (which is 
   automatically called by allegro_init()). Make sure you check the cpu_family
   and cpu_vendor so you know which models make sense to check.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#check_cpu" title="Detects the CPU type.">check_cpu</a>,
<a class="xref" href="#cpu_vendor" title="Contains the CPU vendor name.">cpu_vendor</a>,
<a class="xref" href="#cpu_family" title="Contains the CPU type.">cpu_family</a>,
<a class="xref" href="#cpu_capabilities" title="Contains the capability flags of the CPU.">cpu_capabilities</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>.</blockquote>
<div class="al-api"><b>extern int <a name="cpu_capabilities">cpu_capabilities</a>;</b></div><br>
   Contains CPU flags indicating what features are available on the current 
   CPU. The flags can be any combination of these:
<blockquote class="text"><pre>
      CPU_ID       - Indicates that the "cpuid" instruction is
                     available. If this is set, then all Allegro CPU
                     variables are 100% reliable, otherwise there
                     may be some mistakes.
      CPU_FPU      - An FPU is available.
      CPU_IA64     - Running on Intel 64 bit CPU
      CPU_AMD64    - Running on AMD 64 bit CPU
      CPU_MMX      - Intel MMX  instruction set is available.
      CPU_MMXPLUS  - Intel MMX+ instruction set is available.
      CPU_SSE      - Intel SSE  instruction set is available.
      CPU_SSE2     - Intel SSE2 instruction set is available.
      CPU_SSE3     - Intel SSE3 instruction set is available.
      CPU_3DNOW    - AMD 3DNow! instruction set is available.
      CPU_ENH3DNOW - AMD Enhanced 3DNow! instruction set is
                     available.
      CPU_CMOV     - Pentium Pro "cmov" instruction is available.
</pre></blockquote>
   You can check for multiple features by OR-ing the flags together.
   For example, to check if the CPU has an FPU and MMX instructions
   available, you'd do:
<blockquote class="code"><pre>
      if ((<a href="#cpu_capabilities" class="autotype" title="Contains the capability flags of the CPU.">cpu_capabilities</a> &amp; (CPU_FPU | CPU_MMX)) ==
          (CPU_FPU | CPU_MMX)) {
         printf("CPU has both an FPU and MMX instructions!\n");
      }
</pre></blockquote>
   You can read this variable after you have called check_cpu() (which is
   automatically called by allegro_init()).




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#check_cpu" title="Detects the CPU type.">check_cpu</a>,
<a class="xref" href="#cpu_vendor" title="Contains the CPU vendor name.">cpu_vendor</a>,
<a class="xref" href="#cpu_family" title="Contains the CPU type.">cpu_family</a>,
<a class="xref" href="#cpu_model" title="Contains the Intel CPU submodel.">cpu_model</a>,
<a class="xref" href="#cpu_capabilities" title="Contains the capability flags of the CPU.">cpu_capabilities</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>.</blockquote>
<h1><a name="Structures and types defined by Allegro">Structures and types defined by Allegro</a></h1>

<p>
There are several structures and types defined by Allegro which are used
in many functions (like the BITMAP structure). This section of the manual
describes their useful content from a user point of view when they don't fit
very well any of the existing manual sections, and redirects you to the
appropriate section when it's already described there. Note that unless stated
otherwise, the contents shown here are just for read only purposes, there
might be other internal flags, but you shouldn't depend on them being
available in past/future versions of Allegro.

<p><br>
<div class="al-api"><b>typedef long <a name="fixed">fixed</a></b></div><br>
   This is a fixed point integer which can replace float with similar results
   and is faster than float on low end machines. Read chapter "Fixed point
   math routines" for the full explanation.
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Fixed point math routines" title="">Fixed point math routines</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exfixed" title="Using fixed point maths.">exfixed</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="BITMAP">BITMAP</a></b></div><br>
<blockquote class="code"><pre>
   int w, h;               - size of the bitmap in pixels
   int clip;               - non-zero if clipping is turned on
   int cl, cr, ct, cb;     - clip rectangle left, right, top,
                             and bottom
   unsigned char *<a href="#line" class="autotype" title="Draws a line onto the bitmap.">line</a>[];  - pointers to the start of each <a href="#line" class="autotype" title="Draws a line onto the bitmap.">line</a>
</pre></blockquote>
   There is some other stuff in the structure as well, but it is liable to
   change and you shouldn't use anything except the above. The <tt>`w'</tt> and <tt>`h'</tt>
   fields can be used to obtain the size of an existing bitmap:
<blockquote class="code"><pre>
      bmp = <a href="#load_bitmap" class="autotype" title="Loads any supported bitmap from a file.">load_bitmap</a>("file.bmp", pal);
      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("Bitmap size: (%dx%d)\n", bmp->w, bmp->h);
</pre></blockquote>
   The clipping rectangle is inclusive on the left and top (0 allows drawing
   to position 0) but exclusive on the right and bottom (10 allows drawing
   to position 9, but not to 10). Note this is not the same format as that of
   the clipping API, which takes inclusive coordinates for all four corners.
   All the values of this structure should be regarded as read-only, with the
   exception of the line field, whose access is described in depth in the
   "Direct access to video memory" section of the manual. If you want to
   modify the clipping region, please refrain from changing this structure.
   Use set_clip_rect() instead.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>,
<a class="xref" href="#RLE_SPRITE" title="Stores the contents of an RLE sprite.">RLE_SPRITE</a>,
<a class="xref" href="#COMPILED_SPRITE" title="Stores the contents of a compiled sprite.">COMPILED_SPRITE</a>,
<a class="xref" href="#Direct access to video memory" title="">Direct access to video memory</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="RLE_SPRITE">RLE_SPRITE</a></b></div><br>
<blockquote class="code"><pre>
   int w, h;           - width and height in pixels
   int color_depth;    - color depth of the image
</pre></blockquote>
   RLE sprites store the image in a simple run-length encoded format, where
   repeated zero pixels are replaced by a single length count, and strings of
   non-zero pixels are preceded by a counter giving the length of the solid
   run. Read chapter "RLE sprites" for a description of the restrictions and
   how to obtain/use this structure.
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_rle_sprite" title="Creates an RLE sprite using a bitmap as source.">get_rle_sprite</a>,
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#COMPILED_SPRITE" title="Stores the contents of a compiled sprite.">COMPILED_SPRITE</a>,
<a class="xref" href="#RLE sprites" title="">RLE sprites</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="COMPILED_SPRITE">COMPILED_SPRITE</a></b></div><br>
<blockquote class="code"><pre>
   short planar;        - set if it's a planar (mode-X) sprite
   short color_depth;   - color depth of the image
   short w, h;          - size of the sprite
</pre></blockquote>
   Compiled sprites are stored as actual machine code instructions that draw
   a specific image onto a bitmap, using mov instructions with immediate data
   values. Read chapter "Compiled sprites" for a description of the
   restrictions and how to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_compiled_sprite" title="Creates a compiled sprite using a bitmap as source.">get_compiled_sprite</a>,
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#RLE_SPRITE" title="Stores the contents of an RLE sprite.">RLE_SPRITE</a>,
<a class="xref" href="#Compiled sprites" title="">Compiled sprites</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="JOYSTICK_INFO">JOYSTICK_INFO</a></b></div><br>
<blockquote class="code"><pre>
   int flags;                       - status flags for this
                                      joystick
   int num_sticks;                  - how many stick inputs?
   int num_buttons;                 - how many buttons?
   <a href="#JOYSTICK_STICK_INFO" class="autotype" title="Stores joystick stick information.">JOYSTICK_STICK_INFO</a> stick[n];    - stick state information
   <a href="#JOYSTICK_BUTTON_INFO" class="autotype" title="Stores joystick button information.">JOYSTICK_BUTTON_INFO</a> button[n];  - button state information
</pre></blockquote>
   Read chapter "Joystick routines" for a description on how to obtain/use
   this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#joy" title="Global array of joystick state information.">joy</a>,
<a class="xref" href="#Joystick routines" title="">Joystick routines</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="JOYSTICK_BUTTON_INFO">JOYSTICK_BUTTON_INFO</a></b></div><br>
<blockquote class="code"><pre>
   int b;                           - boolean on/off flag
   char *name;                      - description of this
                                      button
</pre></blockquote>
   Read chapter "Joystick routines" for a description on how to obtain/use
   this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#joy" title="Global array of joystick state information.">joy</a>,
<a class="xref" href="#Joystick routines" title="">Joystick routines</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="JOYSTICK_STICK_INFO">JOYSTICK_STICK_INFO</a></b></div><br>
<blockquote class="code"><pre>
   int flags;                       - status flags for this
                                      input
   int num_axis;                    - how many axes do we
                                      have? (note the misspelling)
   <a href="#JOYSTICK_AXIS_INFO" class="autotype" title="Stores joystick axis information.">JOYSTICK_AXIS_INFO</a> axis[n];      - axis state information
   char *name;                      - description of this
                                      input
</pre></blockquote>
   Read chapter "Joystick routines" for a description on how to obtain/use
   this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#joy" title="Global array of joystick state information.">joy</a>,
<a class="xref" href="#Joystick routines" title="">Joystick routines</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="JOYSTICK_AXIS_INFO">JOYSTICK_AXIS_INFO</a></b></div><br>
<blockquote class="code"><pre>
   int pos;                         - analogue axis position
   int d1, d2;                      - digital axis position
   char *name;                      - description of this axis
</pre></blockquote>
   Read chapter "Joystick routines" for a description on how to obtain/use
   this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#joy" title="Global array of joystick state information.">joy</a>,
<a class="xref" href="#Joystick routines" title="">Joystick routines</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="GFX_MODE_LIST">GFX_MODE_LIST</a></b></div><br>
<blockquote class="code"><pre>
   int num_modes;
   <a href="#GFX_MODE" class="autotype" title="Stores video mode information.">GFX_MODE</a> *mode;
</pre></blockquote>
   Structure returned by get_gfx_mode_list, which contains an array of
   GFX_MODE structures.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#GFX_MODE" title="Stores video mode information.">GFX_MODE</a>,
<a class="xref" href="#get_gfx_mode_list" title="Obtains a list of available video modes.">get_gfx_mode_list</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="GFX_MODE">GFX_MODE</a></b></div><br>
<blockquote class="code"><pre>
   int width, height, bpp;
</pre></blockquote>
   Structure contained in GFX_MODE_LIST.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#GFX_MODE_LIST" title="Stores an array of GFX_MODE structures.">GFX_MODE_LIST</a>,
<a class="xref" href="#get_gfx_mode_list" title="Obtains a list of available video modes.">get_gfx_mode_list</a>.</blockquote>
<div class="al-api"><b>#define <a name="PAL_SIZE">PAL_SIZE</a></b></div><br>
   Preprocessor constant equal to 256.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a>.</blockquote>
<div class="al-api"><b>typedef <a name="PALETTE">PALETTE</a> RGB[PAL_SIZE]</b></div><br>
   Allegro palettes are arrays of PAL_SIZE RGB entries.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#Palette routines" title="">Palette routines</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="RGB">RGB</a></b></div><br>
<blockquote class="code"><pre>
   unsigned char r, g, b;
</pre></blockquote>
   Palette entry. It contains an additional field for the purpose of padding
   but you should not usually care about it. Read chapter "Palette routines"
   for a description on how to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Palette routines" title="">Palette routines</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>,
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>,
<a class="eref" href="#expal" title="Palette effects and color cycling.">expal</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>,
<a class="eref" href="#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>,
<a class="eref" href="#extruec" title="Truecolor pixel format conversions.">extruec</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="V3D">V3D</a></b></div><br>
<blockquote class="code"><pre>
   <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> x, y, z;       - position
   <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> u, v;          - texture map coordinates
   int c;               - color
</pre></blockquote>
   A vertex structure used by polygon3d and other polygon rendering
   functions. Read the description of polygon3d() for a description on how
   to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="V3D_f">V3D_f</a></b></div><br>
<blockquote class="code"><pre>
   float x, y, z;       - position
   float u, v;          - texture map coordinates
   int c;               - color
</pre></blockquote>
   Like V3D but using float values instead of fixed ones. Read the
   description of polygon3d_f() for a description on how to obtain/use this
   structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a>,
<a class="xref" href="#polygon3d_f" title="Draws a 3d polygon onto the specified bitmap.">polygon3d_f</a>,
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="COLOR_MAP">COLOR_MAP</a></b></div><br>
<blockquote class="code"><pre>
   unsigned char data[<a href="#PAL_SIZE" class="autotype" title="Number of entries in a palette.">PAL_SIZE</a>][<a href="#PAL_SIZE" class="autotype" title="Number of entries in a palette.">PAL_SIZE</a>];
</pre></blockquote>
   Read chapter "Transparency and patterned drawing", section "256-color
   transparency" for a description on how to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#256-color transparency" title="">256-color transparency</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="RGB_MAP">RGB_MAP</a></b></div><br>
<blockquote class="code"><pre>
   unsigned char data[32][32][32];
</pre></blockquote>
   Read chapter "Converting between color formats" for a description on how
   to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Converting between color formats" title="">Converting between color formats</a>,
<a class="xref" href="#create_rgb_table" title="Generates an RGB mapping table with lookup data for a palette.">create_rgb_table</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>struct <a name="al_ffblk">al_ffblk</a></b></div><br>
<blockquote class="code"><pre>
   int attrib;       - actual attributes of the file found
   time_t time;      - modification time of file
   char name[512];   - name of file
</pre></blockquote>
   Read the description of al_findfirst for a description on how to
   obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#al_findfirst" title="Low-level function for searching files.">al_findfirst</a>,
<a class="xref" href="#al_ffblk_get_size" title="Get size of file returned by al_findfirst/al_findnext.">al_ffblk_get_size</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="DATAFILE">DATAFILE</a></b></div><br>
<blockquote class="code"><pre>
   void *dat;     - pointer to the actual data
   int type;      - type of the data
   long size;     - size of the data in bytes
   void *prop;    - list of object properties
</pre></blockquote>
   Read chapter "Datafile routines", section "Using datafiles" for a
   description on how to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#Using datafiles" title="">Using datafiles</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exdata" title="Accessing the contents of datafiles.">exdata</a>,
<a class="eref" href="#exexedat" title="Appending datafiles onto your executable.">exexedat</a>,
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="MATRIX">MATRIX</a></b></div><br>
<blockquote class="code"><pre>
   <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> v[3][3];           - 3x3 scaling and rotation component
   <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> t[3];              - x/y/z translation component
</pre></blockquote>
   Fixed point matrix structure. Read chapter "3D math routines" for a
   description on how to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a>,
<a class="xref" href="#3D math routines" title="">3D math routines</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="MATRIX_f">MATRIX_f</a></b></div><br>
<blockquote class="code"><pre>
   float v[3][3];           - 3x3 scaling and rotation component
   float t[3];              - x/y/z translation component
</pre></blockquote>
   Floating point matrix structure. Read chapter "3D math routines" for a
   description on how to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a>,
<a class="xref" href="#3D math routines" title="">3D math routines</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>,
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="QUAT">QUAT</a></b></div><br>
<blockquote class="code"><pre>
   float w, x, y, z;
</pre></blockquote>
   Read chapter "Quaternion math routines" for a description on how to
   obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Quaternion math routines" title="">Quaternion math routines</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="DIALOG">DIALOG</a></b></div><br>
<blockquote class="code"><pre>
   int (*proc)(int, <a href="#DIALOG" class="autotype" title="Stores a GUI description.">DIALOG</a> *, int); - dialog procedure
                                      (message handler)
   int x, y, w, h;       - position and size of the object
   int fg, bg;           - foreground and background colors
   int <a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>;              - ASCII keyboard shortcut
   int flags;            - flags about the status of the object
   int d1, d2;           - whatever you want to use them for
   void *dp, *dp2, *dp3; - pointers to more object-specific data
</pre></blockquote>
   This is the structure which contains a GUI object. Read chapter "GUI
   routines" for a description on how to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#do_dialog" title="Basic dialog manager function.">do_dialog</a>,
<a class="xref" href="#GUI routines" title="">GUI routines</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="MENU">MENU</a></b></div><br>
<blockquote class="code"><pre>
   char *text;          - the text to display for the menu item
   int (*proc)(void);   - called when the menu item is clicked
   struct <a href="#MENU" class="autotype" title="Stores the entries of a menu.">MENU</a> *child;  - nested child menu
   int flags;           - disabled or checked state
   void *dp;            - pointer to any data you need
</pre></blockquote>
   Structure used to hold an entry of a menu. Read chapter "GUI routines",
   section "GUI menus" for a description on how to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#do_menu" title="Displays an animates a popup menu.">do_menu</a>,
<a class="xref" href="#GUI menus" title="">GUI menus</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="DIALOG_PLAYER">DIALOG_PLAYER</a></b></div><br>
   A structure which holds GUI data used internally by Allegro. Read the
   documentation of init_dialog() for a description on how to obtain/use this
   structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#init_dialog" title="Low level initialisation of a dialog.">init_dialog</a>,
<a class="xref" href="#update_dialog" title="Low level function to update a dialog player.">update_dialog</a>,
<a class="xref" href="#shutdown_dialog" title="Destroys a dialog player returned by init_dialog().">shutdown_dialog</a>,
<a class="xref" href="#GUI routines" title="">GUI routines</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="MENU_PLAYER">MENU_PLAYER</a></b></div><br>
   A structure which holds GUI data used internally by Allegro. Read the
   documentation of init_menu() for a description on how to obtain/use this
   structure.
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#init_menu" title="Low level initialisation of a menu.">init_menu</a>,
<a class="xref" href="#update_menu" title="Low level function to update a menu player.">update_menu</a>,
<a class="xref" href="#shutdown_menu" title="Destroys a menu player object returned by init_menu().">shutdown_menu</a>,
<a class="xref" href="#GUI menus" title="">GUI menus</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="FONT">FONT</a></b></div><br>
   A structure holding an Allegro font, usually created beforehand with the
   grabber tool or Allegro's default font. Read chapter "Fonts" for a
   description on how to load/destroy fonts, and chapter "Text output" for a
   description on how to show text.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exfont" title="">exfont</a>,
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>typedef struct <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> <a name="ZBUFFER">ZBUFFER</a></b></div><br>
   Structure used by Allegro's 3d zbuffered rendering functions. You are not
   supposed to mix ZBUFFER with BITMAP even though it is currently possible
   to do so. This is just an internal representation, and it may change in
   the future.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Zbuffered rendering" title="">Zbuffered rendering</a>,
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="SAMPLE">SAMPLE</a></b></div><br>
<blockquote class="code"><pre>
   int bits;                   - 8 or 16
   int stereo;                 - sample type flag
   int freq;                   - sample frequency
   int priority;               - 0-255
   unsigned long len;          - length (in samples)
   unsigned long loop_start;   - loop start position
   unsigned long loop_end;     - loop finish position
   void *data;                 - raw sample data
</pre></blockquote>
   A sample structure, which holds sound data, used by the digital sample
   routines. You can consider all of these fields as read only except
   priority, loop_start and loop_end, which you can change them for example
   after loading a sample from disk.

<p>
   The priority is a value from 0 to 255 (by default set to 128) and controls
   how hardware voices on the sound card are allocated if you attempt to play
   more than the driver can handle. This may be used to ensure that the less
   important sounds are cut off while the important ones are preserved.

<p>
   The variables loop_start and loop_end specify the loop position in sample
   units, and are set by default to the start and end of the sample.

<p>
   If you are creating your own samples on the fly, you might also want to
   modify the raw data of the sample pointed by the data field. The sample
   data are always in unsigned format. This means that if you are loading a
   PCM encoded sound file with signed 16-bit samples, you would have to XOR
   every two bytes (i.e. every sample value) with 0x8000 to change the
   signedness.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>,
<a class="xref" href="#Digital sample routines" title="">Digital sample routines</a>,
<a class="xref" href="#Voice control" title="">Voice control</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsample" title="Playing digital samples.">exsample</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="MIDI">MIDI</a></b></div><br>
   A structure holding MIDI data. Read chapter "Music routines (MIDI)" for a
   description on how to obtain/use this structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_midi" title="Loads a MIDI file.">load_midi</a>,
<a class="xref" href="#Music routines (MIDI)" title="">Music routines (MIDI)</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="AUDIOSTREAM">AUDIOSTREAM</a></b></div><br>
<blockquote class="code"><pre>
   int voice;  - the hardware voice used for the sample
</pre></blockquote>
   A structure holding an audiostream, which is a convenience wrapper around
   a SAMPLE structure to double buffer sounds too big to fit into memory, or
   do clever things like generating the sound wave real time.
   
<p>
   While you shouldn't modify directly the value of the voice, you can use
   all of the voice functions in chapter "Digital sample routines" to modify
   the properties of the sound, like the frequency.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_audio_stream" title="Creates a new audio stream and starts playing it.">play_audio_stream</a>,
<a class="xref" href="#Audio stream routines" title="">Audio stream routines</a>,
<a class="xref" href="#Voice control" title="">Voice control</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstream" title="Playing audio streams.">exstream</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="PACKFILE">PACKFILE</a></b></div><br>
   A packfile structure, similar to the libc FILE structure. Read chapter
   "File and compression routines" for a description on how to obtain/use
   this structure. Note that prior to version 4.1.18, some internal fields
   were accidentally documented - but PACKFILE should be treated as an
   opaque structure, just like the libc FILE type.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#File and compression routines" title="">File and compression routines</a>,
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>,
<a class="xref" href="#pack_fopen_vtable" title="">pack_fopen_vtable</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="PACKFILE_VTABLE">PACKFILE_VTABLE</a></b></div><br>
<blockquote class="code"><pre>
   int pf_fclose(void *userdata);
   int pf_getc(void *userdata);
   int pf_ungetc(int c, void *userdata);
   long pf_fread(void *p, long n, void *userdata);
   int pf_putc(int c, void *userdata);
   long pf_fwrite(const void *p, long n, void *userdata);
   int pf_fseek(void *userdata, int offset);
   int pf_feof(void *userdata);
   int pf_ferror(void *userdata);
</pre></blockquote>
   This is the vtable which must be provided for custom packfiles, which then
   can read from and write to wherever you like (eg. files in memory). You
   should provide all the entries of the vtable, even if they are empty stubs
   doing nothing, to avoid Allegro (or you) calling a NULL method at some
   point.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#File and compression routines" title="">File and compression routines</a>,
<a class="xref" href="#pack_fopen_vtable" title="">pack_fopen_vtable</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="LZSS_PACK_DATA">LZSS_PACK_DATA</a></b></div><br>
   Opaque structure for handling LZSS compression. Read chapter "File and
   compression routines for a description on how to obtain/use this
   structure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#File and compression routines" title="">File and compression routines</a>,
<a class="xref" href="#create_lzss_pack_data" title="Creates an LZSS structure for compression.">create_lzss_pack_data</a>.</blockquote>
<div class="al-api"><b>typedef struct <a name="LZSS_UNPACK_DATA">LZSS_UNPACK_DATA</a></b></div><br>
   Opaque structure for handling LZSS decompression. Read chapter "File and
   compression routines for a description on how to obtain/use this
   structure.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#File and compression routines" title="">File and compression routines</a>,
<a class="xref" href="#create_lzss_unpack_data" title="Creates an LZSS structure for decompression.">create_lzss_unpack_data</a>.</blockquote>
<h1><a name="Unicode routines">Unicode routines</a></h1>

<p>
Allegro can manipulate and display text using any character values from 0 
right up to 2^32-1 (although the current implementation of the grabber can 
only create fonts using characters up to 2^16-1). You can choose between a 
number of different text encoding formats, which controls how strings are 
stored and how Allegro interprets strings that you pass to it. This setting 
affects all aspects of the system: whenever you see a function that returns 
a char * type, or that takes a char * as an argument, that text will be in 
whatever format you have told Allegro to use.

<p>
By default, Allegro uses UTF-8 encoded text (U_UTF8). This is a 
variable-width format, where characters can occupy anywhere from one to four
bytes. The nice thing about it is that characters ranging from 0-127 are 
encoded directly as themselves, so UTF-8 is upwardly compatible with 7-bit 
ASCII ("Hello, World!" means the same thing regardless of whether you 
interpret it as ASCII or UTF-8 data). Any character values above 128, such 
as accented vowels, the UK currency symbol, and Arabic or Chinese 
characters, will be encoded as a sequence of two or more bytes, each in the 
range 128-255. This means you will never get what looks like a 7-bit ASCII 
character as part of the encoding of a different character value, which 
makes it very easy to manipulate UTF-8 strings.

<p>
There are a few editing programs that understand UTF-8 format text files. 
Alternatively, you can write your strings in plain ASCII or 16-bit Unicode 
formats, and then use the Allegro textconv program to convert them into 
UTF-8.

<p>
If you prefer to use some other text format, you can set Allegro to work 
with normal 8-bit ASCII (U_ASCII), or 16-bit Unicode (U_UNICODE) instead, or 
you can provide some handler functions to make it support whatever other 
text encoding you like (for example it would be easy to add support for 32 
bit UCS-4 characters, or the Chinese GB-code format).

<p>
There is some limited support for alternative 8-bit codepages, via the 
U_ASCII_CP mode. This is very slow, so you shouldn't use it for serious 
work, but it can be handy as an easy way to convert text between different 
codepages. By default the U_ASCII_CP mode is set up to reduce text to a 
clean 7-bit ASCII format, trying to replace any accented vowels with their 
simpler equivalents (this is used by the allegro_message() function when it 
needs to print an error report onto a text mode DOS screen). If you want to 
work with other codepages, you can do this by passing a character mapping 
table to the set_ucodepage() function.

<p>
Note that you can use the Unicode routines before you call install_allegro() 
or allegro_init(). If you want to work in a text mode other than UTF-8, it 
is best to set it with set_uformat() just before you call these.

<p><br>
<div class="al-api"><b>void <a name="set_uformat">set_uformat</a>(int type);</b></div><br>
   Sets the current text encoding format. This will affect all parts of 
   Allegro, wherever you see a function that returns a char *, or takes a 
   char * as a parameter. <tt>`type'</tt> should be one of these values:
<blockquote class="text"><pre>
      U_ASCII     - fixed size, 8-bit ASCII characters
      U_ASCII_CP  - alternative 8-bit codepage (see set_ucodepage())
      U_UNICODE   - fixed size, 16-bit Unicode characters
      U_UTF8      - variable size, UTF-8 format Unicode characters
</pre></blockquote>
   Although you can change the text format on the fly, this is not a good 
   idea. Many strings, for example the names of your hardware drivers and 
   any language translations, are loaded when you call allegro_init(), so if 
   you change the encoding format after this, they will be in the wrong 
   format, and things will not work properly. Generally you should only call 
   set_uformat() once, before allegro_init(), and then leave it on the same 
   setting for the duration of your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_uformat" title="Finds out what text encoding format is currently selected.">get_uformat</a>,
<a class="xref" href="#register_uformat" title="Installs handler functions for a new text encoding format.">register_uformat</a>,
<a class="xref" href="#set_ucodepage" title="Sets 8-bit to Unicode conversion tables.">set_ucodepage</a>,
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>,
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrsize" title="Size of the string in bytes without null terminator.">ustrsize</a>,
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#ugetx" title="Low level helper function for reading Unicode text data.">ugetx</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>,
<a class="xref" href="#uoffset" title="Finds the offset of a character in a string.">uoffset</a>,
<a class="xref" href="#ugetat" title="Finds out the value of a character in a string.">ugetat</a>,
<a class="xref" href="#usetat" title="Replaces a character in a string.">usetat</a>,
<a class="xref" href="#uinsert" title="Inserts a character in a string.">uinsert</a>,
<a class="xref" href="#uremove" title="Removes a character from a string.">uremove</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>int <a name="get_uformat">get_uformat</a>(void);</b></div><br>
   Finds out what text encoding format is currently selected. This function
   is probably useful only if you are writing an Allegro addon dealing with
   text strings and you use a different codepath for each possible format.
   Example:
<blockquote class="code"><pre>
      switch(<a href="#get_uformat" class="autotype" title="Finds out what text encoding format is currently selected.">get_uformat</a>()) {
         case U_ASCII:
            do_something();
            break;
         case U_UTF8:
            do_something_else();
            break;
         ...
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns the currently selected text encoding format. See the documentation
   of set_uformat() for a list of encoding formats.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>.</blockquote>
<div class="al-api"><b>void <a name="register_uformat">register_uformat</a>(int type,
                      int (*u_getc)(const char *s),
                      int (*u_getx)(char **s),
                      int (*u_setc)(char *s, int c),
                      int (*u_width)(const char *s),
                      int (*u_cwidth)(int c),
                      int (*u_isok)(int c));</b></div><br>
   Installs a set of custom handler functions for a new text encoding 
   format. The <tt>`type'</tt> is the ID code for your new format, which should be a
   4-character string as produced by the AL_ID() macro, and which can later 
   be passed to functions like set_uformat() and uconvert(). The function 
   parameters are handlers that implement the character access for your new 
   type: see below for details of these.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>,
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#ugetx" title="Low level helper function for reading Unicode text data.">ugetx</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>.</blockquote>
<div class="al-api"><b>void <a name="set_ucodepage">set_ucodepage</a>(const unsigned short *table,
                   const unsigned short *extras);</b></div><br>
   When you select the U_ASCII_CP encoding mode, a set of tables are used to 
   convert between 8-bit characters and their Unicode equivalents. You can 
   use this function to specify a custom set of mapping tables, which allows 
   you to support different 8-bit codepages.

<p>
   The <tt>`table'</tt> parameter points to an array of 256 shorts, which contain the
   Unicode value for each character in your codepage. The <tt>`extras'</tt> parameter,
   if not NULL, points to a list of mapping pairs, which will be used when
   reducing Unicode data to your codepage. Each pair consists of a Unicode
   value, followed by the way it should be represented in your codepage.
   The list is terminated by a zero Unicode value. This allows you to create
   a many-&gt;one mapping, where many different Unicode characters can be
   represented by a single codepage value (eg. for reducing accented vowels
   to 7-bit ASCII).

<p>
   Allegro will use the <tt>`table'</tt> parameter when it needs to convert an ASCII
   string to an Unicode string. But when Allegro converts an Unicode string
   to ASCII, it will use both parameters. First, it will loop through the
   <tt>`table'</tt> parameter looking for an index position pointing at the Unicode
   value it is trying to convert (ie. the <tt>`table'</tt> parameter is also used for
   reverse matching). If that fails, the <tt>`extras'</tt> list is used. If that fails
   too, Allegro will put the character <tt>`^'</tt>, giving up the conversion.

<p>
   Note that Allegro comes with a default <tt>`table'</tt> and <tt>`extras'</tt> parameters
   set internally. The default <tt>`table'</tt> will convert 8-bit characters to <tt>`^'</tt>.
   The default <tt>`extras'</tt> list reduces Latin-1 and Extended-A characters to 7
   bits in a sensible way (eg. an accented vowel will be reduced to the same
   vowel without the accent).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>.</blockquote>
<div class="al-api"><b>int <a name="need_uconvert">need_uconvert</a>(const char *s, int type, int newtype);</b></div><br>
   Given a pointer to a string (<tt>`s'</tt>), a description of the type of the string
   (<tt>`type'</tt>), and the type that you would like this string to be converted into
   (<tt>`newtype'</tt>), this function tells you whether any conversion is required. No
   conversion will be needed if <tt>`type'</tt> and <tt>`newtype'</tt> are the same, or if one
   type is ASCII, the other is UTF-8, and the string contains only character
   values less than 128. As a convenience shortcut, you can pass the value
   U_CURRENT as either of the type parameters, to represent whatever text
   encoding format is currently selected. Example:
<blockquote class="code"><pre>
      if (<a href="#need_uconvert" class="autotype" title="Tells if a string requires encoding conversion.">need_uconvert</a>(text, U_UTF8, U_CURRENT)) {
         /* conversion is required */
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns non-zero if any conversion is required or zero otherwise.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>,
<a class="xref" href="#get_uformat" title="Finds out what text encoding format is currently selected.">get_uformat</a>,
<a class="xref" href="#do_uconvert" title="Converts a string to another encoding format.">do_uconvert</a>,
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>.</blockquote>
<div class="al-api"><b>int <a name="uconvert_size">uconvert_size</a>(const char *s, int type, int newtype);</b></div><br>
   Finds out how many bytes are required to store the specified string <tt>`s'</tt>
   after a conversion from <tt>`type'</tt> to <tt>`newtype'</tt>, including the mandatory zero
   terminator of the string. You can use U_CURRENT for either <tt>`type'</tt> or
   <tt>`newtype'</tt> as a shortcut to represent whatever text encoding format is
   currently selected. Example:
<blockquote class="code"><pre>
      length = <a href="#uconvert_size" class="autotype" title="Number of bytes needed to store a string after conversion.">uconvert_size</a>(old_string, U_CURRENT, U_UNICODE);
      new_string = malloc(length);
      <a href="#ustrcpy" class="autotype" title="Copies a string into another one.">ustrcpy</a>(new_string, old_string);</pre></blockquote>
<p><b>Return value:</b>
   Returns the number of bytes required to store the string after conversion.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#need_uconvert" title="Tells if a string requires encoding conversion.">need_uconvert</a>,
<a class="xref" href="#do_uconvert" title="Converts a string to another encoding format.">do_uconvert</a>.</blockquote>
<div class="al-api"><b>void <a name="do_uconvert">do_uconvert</a>(const char *s, int type,
                 char *buf, int newtype, int size);</b></div><br>
   Converts the specified string <tt>`s'</tt> from <tt>`type'</tt> to <tt>`newtype'</tt>, storing at most
   <tt>`size'</tt> bytes into the output <tt>`buf'</tt>. The type parameters can use the value
   U_CURRENT as a shortcut to represent the currently selected encoding 
   format. Example:
<blockquote class="code"><pre>
      char temp_string[256];
      <a href="#do_uconvert" class="autotype" title="Converts a string to another encoding format.">do_uconvert</a>(input_string, U_CURRENT, temp_string, U_ASCII, 256);
</pre></blockquote>
   Note that, even for empty strings, your destination string must have at
   least enough bytes to store the terminating null character of the string,
   and your parameter size must reflect this. Otherwise, the debug version of
   Allegro will abort at an assertion, and the release version of Allegro
   will overrun the destination buffer.
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>.</blockquote>
<div class="al-api"><b>char *<a name="uconvert">uconvert</a>(const char *s, int type,
               char *buf, int newtype, int size);</b></div><br>
   Higher level function running on top of do_uconvert(). This function 
   converts the specified string <tt>`s'</tt> from <tt>`type'</tt> to <tt>`newtype'</tt>, storing at most
   <tt>`size'</tt> bytes into the output <tt>`buf'</tt> (including the terminating null
   character), but it checks before doing the conversion, and doesn't bother
   if the string formats are already the same (either both types are equal, or
   one is ASCII, the other is UTF-8, and the string contains only 7-bit ASCII
   characters).

<p>
   As a convenience, if <tt>`buf'</tt> is NULL it will convert the string into an
   internal static buffer and the <tt>`size'</tt> parameter will be ignored. You should
   be wary of using this feature, though, because that buffer will be
   overwritten the next time this routine is called, so don't expect the data
   to persist across any other library calls. The static buffer may hold less
   than 1024 characters, so you won't be able to convert large chunks of text.
   Example:
<blockquote class="code"><pre>
      char *p = <a href="#uconvert" class="autotype" title="High level string encoding conversion wrapper.">uconvert</a>(input_string, U_CURRENT, buffer, U_ASCII, 256);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to <tt>`buf'</tt> (or the static buffer if you used NULL) if a
   conversion was performed. Otherwise returns a copy of <tt>`s'</tt>. In any cases,
   you should use the return value rather than assuming that the string will
   always be moved to <tt>`buf'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>,
<a class="xref" href="#need_uconvert" title="Tells if a string requires encoding conversion.">need_uconvert</a>,
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#uconvert_ascii" title="Converts string from ASCII into the current format.">uconvert_ascii</a>,
<a class="xref" href="#uconvert_toascii" title="Converts strings from the current format into ASCII.">uconvert_toascii</a>,
<a class="xref" href="#do_uconvert" title="Converts a string to another encoding format.">do_uconvert</a>.</blockquote>
<div class="al-api"><b>char *<a name="uconvert_ascii">uconvert_ascii</a>(const char *s, char buf[]);</b></div><br>
   Helper macro for converting strings from ASCII into the current encoding 
   format. Expands to uconvert(s, U_ASCII, buf, U_CURRENT, sizeof(buf)).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>char *<a name="uconvert_toascii">uconvert_toascii</a>(const char *s, char buf[]);</b></div><br>
   Helper macro for converting strings from the current encoding format into 
   ASCII. Expands to uconvert(s, U_CURRENT, buf, U_ASCII, sizeof(buf)).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>.</blockquote>
<div class="al-api"><b>extern char <a name="empty_string">empty_string</a>[];</b></div><br>
   You can't just rely on "" to be a valid empty string in any encoding 
   format. This global buffer contains a number of consecutive zeros, so it 
   will be a valid empty string no matter whether the program is running in 
   ASCII, Unicode, or UTF-8 mode.

<p><br>
<div class="al-api"><b>int <a name="ugetc">ugetc</a>(const char *s);</b></div><br>
   Low level helper function for reading Unicode text data. Example:
<blockquote class="code"><pre>
      int first_unicode_letter = <a href="#ugetc" class="autotype" title="Low level helper function for reading Unicode text data.">ugetc</a>(text_string);</pre></blockquote>
<p><b>Return value:</b>
   Returns the character pointed to by <tt>`s'</tt> in the current encoding format.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ugetx" title="Low level helper function for reading Unicode text data.">ugetx</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>.</blockquote>
<div class="al-api"><b>int <a name="ugetx">ugetx</a>(char **s);</b></div><br>
<div class="al-api-cont"><b>int <a name="ugetxc">ugetxc</a>(const char **s);</b></div><br>
   Low level helper function for reading Unicode text data. ugetxc is provided
   for working with pointer-to-pointer-to-const char data. Example:
<blockquote class="code"><pre>
      char *p = string;
      int first_letter, second_letter, third_letter;
      first_letter = <a href="#ugetx" class="autotype" title="Low level helper function for reading Unicode text data.">ugetx</a>(&amp;p);
      second_letter = <a href="#ugetx" class="autotype" title="Low level helper function for reading Unicode text data.">ugetx</a>(&amp;p);
      third_letter = <a href="#ugetx" class="autotype" title="Low level helper function for reading Unicode text data.">ugetx</a>(&amp;p);</pre></blockquote>
<p><b>Return value:</b>
   Returns the character pointed to by <tt>`s'</tt> in the current encoding format, and
   advances the pointer to the next character after the one just returned.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>.</blockquote>
<div class="al-api"><b>int <a name="usetc">usetc</a>(char *s, int c);</b></div><br>
   Low level helper function for writing Unicode text data. Writes the
   character <tt>`c'</tt> to the address pointed to by <tt>`s'</tt>.
<p><b>Return value:</b>
   Returns the number of bytes written, which is equal to the width of the
   character in the current encoding format.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#ugetx" title="Low level helper function for reading Unicode text data.">ugetx</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>.</blockquote>
<div class="al-api"><b>int <a name="uwidth">uwidth</a>(const char *s);</b></div><br>
   Low level helper function for testing Unicode text data.
<p><b>Return value:</b>
   Returns the number of bytes occupied by the first character of the
   specified string, in the current encoding format.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uwidth_max" title="Number of bytes a character can occupy.">uwidth_max</a>,
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#ugetx" title="Low level helper function for reading Unicode text data.">ugetx</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>.</blockquote>
<div class="al-api"><b>int <a name="ucwidth">ucwidth</a>(int c);</b></div><br>
   Low level helper function for testing Unicode text data.
<p><b>Return value:</b>
   Returns the number of bytes that would be occupied by the specified
   character value, when encoded in the current format.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uwidth_max" title="Number of bytes a character can occupy.">uwidth_max</a>,
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#ugetx" title="Low level helper function for reading Unicode text data.">ugetx</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>.</blockquote>
<div class="al-api"><b>int <a name="uisok">uisok</a>(int c);</b></div><br>
   Low level helper function for testing Unicode text data. Finds out if the
   character value <tt>`c'</tt> can be encoded correctly in the current format, which
   can be useful if you are converting from Unicode to ASCII or another
   encoding format where the range of valid characters is limited.
<p><b>Return value:</b>
   Returns non-zero if the value can be correctly encoded, zero otherwise.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#ugetx" title="Low level helper function for reading Unicode text data.">ugetx</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>.</blockquote>
<div class="al-api"><b>int <a name="uoffset">uoffset</a>(const char *s, int index);</b></div><br>
   Finds out the offset (in bytes from the start of the string) of the
   character at the specified <tt>`index'</tt> in the string <tt>`s'</tt>. A zero <tt>`index'</tt>
   parameter will return the first character of the string. If <tt>`index'</tt> is
   negative, it counts backward from the end of the string, so an <tt>`index'</tt> of
   `-1' will return an offset to the last character. Example:
<blockquote class="code"><pre>
      int from_third_letter = <a href="#uoffset" class="autotype" title="Finds the offset of a character in a string.">uoffset</a>(text_string, 2);</pre></blockquote>
<p><b>Return value:</b>
   Returns the offset in bytes to the specified character.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ugetat" title="Finds out the value of a character in a string.">ugetat</a>,
<a class="xref" href="#usetat" title="Replaces a character in a string.">usetat</a>,
<a class="xref" href="#uinsert" title="Inserts a character in a string.">uinsert</a>,
<a class="xref" href="#uremove" title="Removes a character from a string.">uremove</a>.</blockquote>
<div class="al-api"><b>int <a name="ugetat">ugetat</a>(const char *s, int index);</b></div><br>
   Finds out the character value at the specified <tt>`index'</tt> in the string. A
   zero <tt>`index'</tt> parameter will return the first character of the string. If
   <tt>`index'</tt> is negative, it counts backward from the end of the string, so an
   <tt>`index'</tt> of `-1' will return the last character of the string. Example:
<blockquote class="code"><pre>
      int third_letter = <a href="#ugetat" class="autotype" title="Finds out the value of a character in a string.">ugetat</a>(text_string, 2);</pre></blockquote>
<p><b>Return value:</b>
   Returns the character value at the specified index in the string.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uoffset" title="Finds the offset of a character in a string.">uoffset</a>,
<a class="xref" href="#usetat" title="Replaces a character in a string.">usetat</a>,
<a class="xref" href="#uinsert" title="Inserts a character in a string.">uinsert</a>,
<a class="xref" href="#uremove" title="Removes a character from a string.">uremove</a>.</blockquote>
<div class="al-api"><b>int <a name="usetat">usetat</a>(char *s, int index, int c);</b></div><br>
   Replaces the character at the specified index in the string with value <tt>`c'</tt>,
   handling any adjustments for variable width data (ie. if <tt>`c'</tt> encodes to a
   different width than the previous value at that location). If <tt>`index'</tt> is
   negative, it counts backward from the end of the string. Example:
<blockquote class="code"><pre>
      <a href="#usetat" class="autotype" title="Replaces a character in a string.">usetat</a>(text_string, 2, letter_a);</pre></blockquote>
<p><b>Return value:</b>
   Returns the number of bytes by which the trailing part of the string was
   moved. This is of interest only with text encoding formats where
   characters have a variable length, like UTF-8.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uoffset" title="Finds the offset of a character in a string.">uoffset</a>,
<a class="xref" href="#ugetat" title="Finds out the value of a character in a string.">ugetat</a>,
<a class="xref" href="#uinsert" title="Inserts a character in a string.">uinsert</a>,
<a class="xref" href="#uremove" title="Removes a character from a string.">uremove</a>.</blockquote>
<div class="al-api"><b>int <a name="uinsert">uinsert</a>(char *s, int index, int c);</b></div><br>
   Inserts the character <tt>`c'</tt> at the specified <tt>`index'</tt> in the string, sliding
   the rest of the data along to make room. If <tt>`index'</tt> is negative, it counts
   backward from the end of the string. Example:
<blockquote class="code"><pre>
      <a href="#uinsert" class="autotype" title="Inserts a character in a string.">uinsert</a>(text_string, 0, prefix_letter);</pre></blockquote>
<p><b>Return value:</b>
   Returns the number of bytes by which the trailing part of the string was
   moved.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uoffset" title="Finds the offset of a character in a string.">uoffset</a>,
<a class="xref" href="#ugetat" title="Finds out the value of a character in a string.">ugetat</a>,
<a class="xref" href="#usetat" title="Replaces a character in a string.">usetat</a>,
<a class="xref" href="#uremove" title="Removes a character from a string.">uremove</a>.</blockquote>
<div class="al-api"><b>int <a name="uremove">uremove</a>(char *s, int index);</b></div><br>
   Removes the character at the specified <tt>`index'</tt> within the string, sliding
   the rest of the data back to fill the gap. If <tt>`index'</tt> is negative, it
   counts backward from the end of the string. Example:
<blockquote class="code"><pre>
      int length_in_bytes = <a href="#ustrsizez" class="autotype" title="Size of the string in bytes including null terminator.">ustrsizez</a>(text_string);
      ...
      length_in_bytes -= <a href="#uremove" class="autotype" title="Removes a character from a string.">uremove</a>(text_string, -1);</pre></blockquote>
<p><b>Return value:</b>
   Returns the number of bytes by which the trailing part of the string was
   moved.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uoffset" title="Finds the offset of a character in a string.">uoffset</a>,
<a class="xref" href="#ugetat" title="Finds out the value of a character in a string.">ugetat</a>,
<a class="xref" href="#usetat" title="Replaces a character in a string.">usetat</a>,
<a class="xref" href="#uinsert" title="Inserts a character in a string.">uinsert</a>.</blockquote>
<div class="al-api"><b>int <a name="ustrsize">ustrsize</a>(const char *s);</b></div><br>
   Returns the size of the specified string in bytes, not including the 
   trailing null character.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ustrsizez" title="Size of the string in bytes including null terminator.">ustrsizez</a>,
<a class="xref" href="#empty_string" title="Universal string NULL terminator.">empty_string</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>int <a name="ustrsizez">ustrsizez</a>(const char *s);</b></div><br>
   Returns the size of the specified string in bytes, including the trailing 
   null character.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ustrsize" title="Size of the string in bytes without null terminator.">ustrsize</a>,
<a class="xref" href="#empty_string" title="Universal string NULL terminator.">empty_string</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>int <a name="uwidth_max">uwidth_max</a>(int type);</b></div><br>
   Low level helper function for working with Unicode text data. Returns the 
   largest number of bytes that one character can occupy in the given 
   encoding format. Pass U_CURRENT to represent the current format. Example:
<blockquote class="code"><pre>
      char *temp_buffer = malloc(256 * <a href="#uwidth_max" class="autotype" title="Number of bytes a character can occupy.">uwidth_max</a>(U_UTF8));</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>.</blockquote>
<div class="al-api"><b>int <a name="utolower">utolower</a>(int c);</b></div><br>
   This function returns <tt>`c'</tt>, converting it to lower case if it is upper case.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#utoupper" title="Converts a letter to upper case.">utoupper</a>,
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#ugetx" title="Low level helper function for reading Unicode text data.">ugetx</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>.</blockquote>
<div class="al-api"><b>int <a name="utoupper">utoupper</a>(int c);</b></div><br>
   This function returns <tt>`c'</tt>, converting it to upper case if it is lower case.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#utolower" title="Converts a letter to lower case.">utolower</a>,
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#ugetx" title="Low level helper function for reading Unicode text data.">ugetx</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>.</blockquote>
<div class="al-api"><b>int <a name="uisspace">uisspace</a>(int c);</b></div><br>
   Returns nonzero if <tt>`c'</tt> is whitespace, that is, carriage return, newline,
   form feed, tab, vertical tab, or space. Example:
<blockquote class="code"><pre>
      for (counter = 0; counter &lt; <a href="#ustrlen" class="autotype" title="Tells the number of characters in a string.">ustrlen</a>(text_string); counter++) {
         if (<a href="#uisspace" class="autotype" title="Tells if a character is whitespace.">uisspace</a>(<a href="#ugetat" class="autotype" title="Finds out the value of a character in a string.">ugetat</a>(text_string, counter)))
            <a href="#usetat" class="autotype" title="Replaces a character in a string.">usetat</a>(text_string, counter, '_');
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uisdigit" title="Tells if a character is a digit.">uisdigit</a>,
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>.</blockquote>
<div class="al-api"><b>int <a name="uisdigit">uisdigit</a>(int c);</b></div><br>
   Returns nonzero if <tt>`c'</tt> is a digit.
<blockquote class="code"><pre>
      for (counter = 0; counter &lt; <a href="#ustrlen" class="autotype" title="Tells the number of characters in a string.">ustrlen</a>(text_string); counter++) {
         if (<a href="#uisdigit" class="autotype" title="Tells if a character is a digit.">uisdigit</a>(<a href="#ugetat" class="autotype" title="Finds out the value of a character in a string.">ugetat</a>(text_string, counter)))
            <a href="#usetat" class="autotype" title="Replaces a character in a string.">usetat</a>(text_string, counter, '*');
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uisspace" title="Tells if a character is whitespace.">uisspace</a>,
<a class="xref" href="#ugetc" title="Low level helper function for reading Unicode text data.">ugetc</a>,
<a class="xref" href="#usetc" title="Low level helper function for writing Unicode text data.">usetc</a>,
<a class="xref" href="#uwidth" title="Low level helper function for testing Unicode text data.">uwidth</a>,
<a class="xref" href="#ucwidth" title="Low level helper function for testing Unicode text data.">ucwidth</a>,
<a class="xref" href="#uisok" title="Low level helper function for testing Unicode text data.">uisok</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrdup">ustrdup</a>(const char *src)</b></div><br>
   This functions copies the null-terminated string <tt>`src'</tt> into a newly
   allocated area of memory, effectively duplicating it. Example:
<blockquote class="code"><pre>
      void manipulate_string(const char *input_string)
      {
         char *temp_buffer = <a href="#ustrdup" class="autotype" title="Duplicates a string.">ustrdup</a>(input_string);
         /* Now we can modify temp_buffer */
         ...</pre></blockquote>
<p><b>Return value:</b>
   Returns the newly allocated string. This memory must be freed by the
   caller. Returns NULL if it cannot allocate space for the duplicated string.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#_ustrdup" title="Duplicates a string with a custom memory allocator.">_ustrdup</a>,
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrsize" title="Size of the string in bytes without null terminator.">ustrsize</a>,
<a class="xref" href="#ustrsizez" title="Size of the string in bytes including null terminator.">ustrsizez</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>.</blockquote>
<div class="al-api"><b>char *<a name="_ustrdup">_ustrdup</a>(const char *src, void* (*malloc_func)(size_t))</b></div><br>
   Does the same as ustrdup(), but allows the user to specify a custom memory
   allocator function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ustrdup" title="Duplicates a string.">ustrdup</a>,
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrsize" title="Size of the string in bytes without null terminator.">ustrsize</a>,
<a class="xref" href="#ustrsizez" title="Size of the string in bytes including null terminator.">ustrsizez</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrcpy">ustrcpy</a>(char *dest, const char *src);</b></div><br>
   This function copies <tt>`src'</tt> (including the terminating null character into
   <tt>`dest'</tt>. You should try to avoid this function because it is very easy to
   overflow the destination buffer. Use ustrzcpy instead.
<p><b>Return value:</b>
   Returns the value of dest.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrzcpy" title="Copies a string into another one, specifying size.">ustrzcpy</a>,
<a class="xref" href="#ustrncpy" title="Copies a string into another one, specifying size.">ustrncpy</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrzcpy">ustrzcpy</a>(char *dest, int size, const char *src);</b></div><br>
   This function copies <tt>`src'</tt> (including the terminating null character) into
   <tt>`dest'</tt>, whose length in bytes is specified by <tt>`size'</tt> and which is
   guaranteed to be null-terminated even if <tt>`src'</tt> is bigger than <tt>`size'</tt>.

<p>
   Note that, even for empty strings, your destination string must have at
   least enough bytes to store the terminating null character of the string,
   and your parameter size must reflect this. Otherwise, the debug version of
   Allegro will abort at an assertion, and the release version of Allegro
   will overrun the destination buffer.
<p><b>Return value:</b>
   Returns the value of <tt>`dest'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrcpy" title="Copies a string into another one.">ustrcpy</a>,
<a class="xref" href="#ustrzncpy" title="Copies a string into another one, specifying size.">ustrzncpy</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrcat">ustrcat</a>(char *dest, const char *src);</b></div><br>
   This function concatenates <tt>`src'</tt> to the end of <tt>`dest`'</tt>. You should try to
   avoid this function because it is very easy to overflow the destination
   buffer, use ustrzcat instead.
<p><b>Return value:</b>
   Returns the value of <tt>`dest'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrzcat" title="Concatenates a string to another one, specifying size.">ustrzcat</a>,
<a class="xref" href="#ustrncat" title="Concatenates a string to another one, specifying size.">ustrncat</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrzcat">ustrzcat</a>(char *dest, int size, const char *src);</b></div><br>
   This function concatenates <tt>`src'</tt> to the end of <tt>`dest'</tt>, whose length in
   bytes is specified by <tt>`size'</tt> and which is guaranteed to be null-terminated
   even when <tt>`src'</tt> is bigger than <tt>`size'</tt>.

<p>
   Note that, even for empty strings, your destination string must have at
   least enough bytes to store the terminating null character of the string,
   and your parameter size must reflect this. Otherwise, the debug version of
   Allegro will abort at an assertion, and the release version of Allegro
   will overrun the destination buffer.
<p><b>Return value:</b>
   Returns the value of <tt>`dest'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrcat" title="Concatenates a string to another one.">ustrcat</a>,
<a class="xref" href="#ustrzncat" title="Concatenates a string to another one, specifying size.">ustrzncat</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="ustrlen">ustrlen</a>(const char *s);</b></div><br>
   This function returns the number of characters in <tt>`s'</tt>. Note that this
   doesn't have to equal the string's size in bytes.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrsize" title="Size of the string in bytes without null terminator.">ustrsize</a>,
<a class="xref" href="#ustrsizez" title="Size of the string in bytes including null terminator.">ustrsizez</a>.</blockquote>
<div class="al-api"><b>int <a name="ustrcmp">ustrcmp</a>(const char *s1, const char *s2);</b></div><br>
   This function compares <tt>`s1'</tt> and <tt>`s2'</tt>.
<p><b>Return value:</b>
   Returns zero if the strings are equal, a positive number if <tt>`s1'</tt> comes
   after <tt>`s2'</tt> in the ASCII collating sequence, else a negative number.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrsize" title="Size of the string in bytes without null terminator.">ustrsize</a>,
<a class="xref" href="#ustrsizez" title="Size of the string in bytes including null terminator.">ustrsizez</a>,
<a class="xref" href="#ustrncmp" title="Compares up to n letters of two strings.">ustrncmp</a>,
<a class="xref" href="#ustricmp" title="Compares two strings ignoring case.">ustricmp</a>,
<a class="xref" href="#ustrnicmp" title="Compares up to n letters of two strings ignoring case.">ustrnicmp</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrncpy">ustrncpy</a>(char *dest, const char *src, int n);</b></div><br>
   This function is like ustrcpy() except that no more than <tt>`n'</tt> characters
   from <tt>`src'</tt> are copied into <tt>`dest'</tt>. If <tt>`src'</tt> is shorter than <tt>`n'</tt> characters,
   null characters are appended to <tt>`dest'</tt> as padding until <tt>`n'</tt> characters have
   been written.

<p>
   Note that if <tt>`src'</tt> is longer than <tt>`n'</tt> characters, <tt>`dest'</tt> will not be
   null-terminated.
<p><b>Return value:</b>
   The return value is the value of <tt>`dest'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrcpy" title="Copies a string into another one.">ustrcpy</a>,
<a class="xref" href="#ustrzncpy" title="Copies a string into another one, specifying size.">ustrzncpy</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrzncpy">ustrzncpy</a>(char *dest, int size, const char *src, int n);</b></div><br>
   This function is like ustrzcpy() except that no more than <tt>`n'</tt> characters
   from <tt>`src'</tt> are copied into <tt>`dest'</tt>. If <tt>`src'</tt> is shorter than <tt>`n'</tt> characters,
   null characters are appended to <tt>`dest'</tt> as padding until <tt>`n'</tt> characters have
   been written. In any case, <tt>`dest'</tt> is guaranteed to be null-terminated.

<p>
   Note that, even for empty strings, your destination string must have at
   least enough bytes to store the terminating null character of the string,
   and your parameter <tt>`size'</tt> must reflect this. Otherwise, the debug version
   of Allegro will abort at an assertion, and the release version of Allegro
   will overrun the destination buffer.
<p><b>Return value:</b>
   The return value is the value of <tt>`dest'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrzcpy" title="Copies a string into another one, specifying size.">ustrzcpy</a>,
<a class="xref" href="#ustrncpy" title="Copies a string into another one, specifying size.">ustrncpy</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exkeys" title="How to get input from the keyboard in different ways.">exkeys</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrncat">ustrncat</a>(char *dest, const char *src, int n);</b></div><br>
   This function is like ustrcat() except that no more than <tt>`n'</tt> characters
   from <tt>`src'</tt> are appended to the end of <tt>`dest'</tt>. If the terminating null
   character in <tt>`src'</tt> is reached before <tt>`n'</tt> characters have been written, the
   null character is copied, but no other characters are written. If <tt>`n'</tt>
   characters are written before a terminating null is encountered, the
   function appends its own null character to <tt>`dest'</tt>, so that `n+1' characters
   are written. You should try to avoid this function because it is very
   easy to overflow the destination buffer. Use ustrzncat instead.
<p><b>Return value:</b>
   The return value is the value of <tt>`dest'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrcat" title="Concatenates a string to another one.">ustrcat</a>,
<a class="xref" href="#ustrzncat" title="Concatenates a string to another one, specifying size.">ustrzncat</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrzncat">ustrzncat</a>(char *dest, int size, const char *src, int n);</b></div><br>
   This function is like ustrzcat() except that no more than <tt>`n'</tt> characters
   from <tt>`src'</tt> are appended to the end of <tt>`dest'</tt>. If the terminating null
   character in <tt>`src'</tt> is reached before <tt>`n'</tt> characters have been written, the
   null character is copied, but no other characters are written. Note that
   <tt>`dest'</tt> is guaranteed to be null-terminated.
<p><b>Return value:</b>
   The return value is the value of <tt>`dest'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrzcat" title="Concatenates a string to another one, specifying size.">ustrzcat</a>,
<a class="xref" href="#ustrncat" title="Concatenates a string to another one, specifying size.">ustrncat</a>.</blockquote>
<div class="al-api"><b>int <a name="ustrncmp">ustrncmp</a>(const char *s1, const char *s2, int n);</b></div><br>
   This function compares up to <tt>`n'</tt> characters of <tt>`s1'</tt> and <tt>`s2'</tt>. Example:
<blockquote class="code"><pre>
      if (<a href="#ustrncmp" class="autotype" title="Compares up to n letters of two strings.">ustrncmp</a>(prefix, long_string, <a href="#ustrlen" class="autotype" title="Tells the number of characters in a string.">ustrlen</a>(prefix)) == 0) {
         /* long_string starts with prefix */
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns zero if the substrings are equal, a positive number if <tt>`s1'</tt> comes
   after <tt>`s2'</tt> in the ASCII collating sequence, else a negative number.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrsize" title="Size of the string in bytes without null terminator.">ustrsize</a>,
<a class="xref" href="#ustrsizez" title="Size of the string in bytes including null terminator.">ustrsizez</a>,
<a class="xref" href="#ustrcmp" title="Compares two strings.">ustrcmp</a>,
<a class="xref" href="#ustricmp" title="Compares two strings ignoring case.">ustricmp</a>,
<a class="xref" href="#ustrnicmp" title="Compares up to n letters of two strings ignoring case.">ustrnicmp</a>.</blockquote>
<div class="al-api"><b>int <a name="ustricmp">ustricmp</a>(const char *s1, const char *s2);</b></div><br>
   This function compares <tt>`s1'</tt> and <tt>`s2'</tt>, ignoring case. Example:
<blockquote class="code"><pre>
      if (<a href="#ustricmp" class="autotype" title="Compares two strings ignoring case.">ustricmp</a>(string, user_input) == 0) {
         /* string and user_input are equal (ignoring case) */
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns zero if the strings are equal, a positive number if <tt>`s1'</tt> comes
   after <tt>`s2'</tt> in the ASCII collating sequence, else a negative number.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrsize" title="Size of the string in bytes without null terminator.">ustrsize</a>,
<a class="xref" href="#ustrsizez" title="Size of the string in bytes including null terminator.">ustrsizez</a>,
<a class="xref" href="#ustrnicmp" title="Compares up to n letters of two strings ignoring case.">ustrnicmp</a>,
<a class="xref" href="#ustrcmp" title="Compares two strings.">ustrcmp</a>,
<a class="xref" href="#ustrncmp" title="Compares up to n letters of two strings.">ustrncmp</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>.</blockquote>
<div class="al-api"><b>int <a name="ustrnicmp">ustrnicmp</a>(const char *s1, const char *s2, int n);</b></div><br>
   This function compares up to <tt>`n'</tt> characters of <tt>`s1'</tt> and <tt>`s2'</tt>, ignoring
   case. Example:
<blockquote class="code"><pre>
      if (<a href="#ustrnicmp" class="autotype" title="Compares up to n letters of two strings ignoring case.">ustrnicmp</a>(prefix, long_string, <a href="#ustrlen" class="autotype" title="Tells the number of characters in a string.">ustrlen</a>(prefix)) == 0) {
         /* long_string starts with prefix (ignoring case) */
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns zero if the strings are equal, a positive number if <tt>`s1'</tt> comes
   after <tt>`s2'</tt> in the ASCII collating sequence, else a negative number.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrsize" title="Size of the string in bytes without null terminator.">ustrsize</a>,
<a class="xref" href="#ustrsizez" title="Size of the string in bytes including null terminator.">ustrsizez</a>,
<a class="xref" href="#ustricmp" title="Compares two strings ignoring case.">ustricmp</a>,
<a class="xref" href="#ustrcmp" title="Compares two strings.">ustrcmp</a>,
<a class="xref" href="#ustrncmp" title="Compares up to n letters of two strings.">ustrncmp</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrlwr">ustrlwr</a>(char *s);</b></div><br>
   This function replaces all upper case letters in <tt>`s'</tt> with lower case
   letters. Example:
<blockquote class="code"><pre>
      char buffer[] = "UPPER CASE STRING";
      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>(<a href="#ustrlwr" class="autotype" title="Replaces all letters with lower case.">ustrlwr</a>(buffer));</pre></blockquote>
<p><b>Return value:</b>
   The return value is the value of <tt>`s'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#utolower" title="Converts a letter to lower case.">utolower</a>,
<a class="xref" href="#ustrupr" title="Replaces all letters with upper case.">ustrupr</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrupr">ustrupr</a>(char *s);</b></div><br>
   This function replaces all lower case letters in <tt>`s'</tt> with upper case
   letters. Example:
<blockquote class="code"><pre>
      char buffer[] = "lower case string";
      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>(<a href="#ustrupr" class="autotype" title="Replaces all letters with upper case.">ustrupr</a>(buffer));</pre></blockquote>
<p><b>Return value:</b>
   The return value is the value of <tt>`s'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#utolower" title="Converts a letter to lower case.">utolower</a>,
<a class="xref" href="#ustrlwr" title="Replaces all letters with lower case.">ustrlwr</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrchr">ustrchr</a>(const char *s, int c);</b></div><br>
   Finds the first occurrence of the character <tt>`c'</tt> in the string <tt>`s'</tt>. Example:
<blockquote class="code"><pre>
      char *p = <a href="#ustrchr" class="autotype" title="Finds the first occurrence of a character in a string.">ustrchr</a>("one,two,three,four", ',');</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the first occurrence of <tt>`c'</tt> in <tt>`s'</tt>, or NULL if no
   match was found. Note that if <tt>`c'</tt> is NULL, this will return a pointer to
   the end of the string.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrrchr" title="Finds the last occurrence of a character in a string.">ustrrchr</a>,
<a class="xref" href="#ustrstr" title="Finds the first occurrence of a string in another one.">ustrstr</a>,
<a class="xref" href="#ustrpbrk" title="Finds the first character that matches any in a set.">ustrpbrk</a>,
<a class="xref" href="#ustrtok" title="Retrieves tokens from a string.">ustrtok</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrrchr">ustrrchr</a>(const char *s, int c);</b></div><br>
   Finds the last occurrence of the character <tt>`c'</tt> in the string <tt>`s'</tt>. Example:
<blockquote class="code"><pre>
      char *p = <a href="#ustrrchr" class="autotype" title="Finds the last occurrence of a character in a string.">ustrrchr</a>("one,two,three,four", ',');</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer for the last occurrence of <tt>`c'</tt> in <tt>`s'</tt>, or NULL if no
   match was found.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrchr" title="Finds the first occurrence of a character in a string.">ustrchr</a>,
<a class="xref" href="#ustrstr" title="Finds the first occurrence of a string in another one.">ustrstr</a>,
<a class="xref" href="#ustrpbrk" title="Finds the first character that matches any in a set.">ustrpbrk</a>,
<a class="xref" href="#ustrtok" title="Retrieves tokens from a string.">ustrtok</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrstr">ustrstr</a>(const char *s1, const char *s2);</b></div><br>
   This function finds the first occurrence of string <tt>`s2'</tt> in string <tt>`s1'</tt>.
   Example:
<blockquote class="code"><pre>
      char *p = <a href="#ustrstr" class="autotype" title="Finds the first occurrence of a string in another one.">ustrstr</a>("hello world", "world");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer within <tt>`s1'</tt>, or NULL if <tt>`s2'</tt> wasn't found.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrchr" title="Finds the first occurrence of a character in a string.">ustrchr</a>,
<a class="xref" href="#ustrrchr" title="Finds the last occurrence of a character in a string.">ustrrchr</a>,
<a class="xref" href="#ustrpbrk" title="Finds the first character that matches any in a set.">ustrpbrk</a>,
<a class="xref" href="#ustrtok" title="Retrieves tokens from a string.">ustrtok</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrpbrk">ustrpbrk</a>(const char *s, const char *set);</b></div><br>
   This function finds the first character in <tt>`s'</tt> that matches any character
   in <tt>`set'</tt>. Example:
<blockquote class="code"><pre>
      char *p = <a href="#ustrpbrk" class="autotype" title="Finds the first character that matches any in a set.">ustrpbrk</a>("one,two-three.four", "-. ");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the first match, or NULL if none are found.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrchr" title="Finds the first occurrence of a character in a string.">ustrchr</a>,
<a class="xref" href="#ustrrchr" title="Finds the last occurrence of a character in a string.">ustrrchr</a>,
<a class="xref" href="#ustrstr" title="Finds the first occurrence of a string in another one.">ustrstr</a>,
<a class="xref" href="#ustrtok" title="Retrieves tokens from a string.">ustrtok</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrtok">ustrtok</a>(char *s, const char *set);</b></div><br>
   This function retrieves tokens from <tt>`s'</tt> which are delimited by characters
   from <tt>`set'</tt>. To initiate the search, pass the string to be searched as <tt>`s'</tt>.
   For the remaining tokens, pass NULL instead. Warning: Since ustrtok alters
   the string it is parsing, you should always copy the string to a temporary
   buffer before parsing it. Also, this function is not re-entrant (ie. you
   cannot parse two strings at the same time). Example:
<blockquote class="code"><pre>
      char *word;
      char string[]="some-words with dashes";
      char *temp = <a href="#ustrdup" class="autotype" title="Duplicates a string.">ustrdup</a>(string);
      word = <a href="#ustrtok" class="autotype" title="Retrieves tokens from a string.">ustrtok</a>(temp, " -");
      while (word) {
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("Found `%s'\n", word);
         word = <a href="#ustrtok" class="autotype" title="Retrieves tokens from a string.">ustrtok</a>(NULL, " -");
      }
      free(temp);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the token, or NULL if no more are found.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrchr" title="Finds the first occurrence of a character in a string.">ustrchr</a>,
<a class="xref" href="#ustrrchr" title="Finds the last occurrence of a character in a string.">ustrrchr</a>,
<a class="xref" href="#ustrstr" title="Finds the first occurrence of a string in another one.">ustrstr</a>,
<a class="xref" href="#ustrpbrk" title="Finds the first character that matches any in a set.">ustrpbrk</a>,
<a class="xref" href="#ustrtok_r" title="Reentrant function to retrieve tokens from a string.">ustrtok_r</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#ustrncpy" title="Copies a string into another one, specifying size.">ustrncpy</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>char *<a name="ustrtok_r">ustrtok_r</a>(char *s, const char *set, char **last);</b></div><br>
   Reentrant version of ustrtok. The <tt>`last'</tt> parameter is used to keep track
   of where the parsing is up to and must be a pointer to a char * variable
   allocated by the user that remains the same while parsing the same
   string. Example:
<blockquote class="code"><pre>
      char *word, *last;
      char string[]="some-words with dashes";
      char *temp = <a href="#ustrdup" class="autotype" title="Duplicates a string.">ustrdup</a>(string);
      word = <a href="#ustrtok_r" class="autotype" title="Reentrant function to retrieve tokens from a string.">ustrtok_r</a>(string, " -", &last);
      while (word) {
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("Found `%s'\n", word);
         word = <a href="#ustrtok_r" class="autotype" title="Reentrant function to retrieve tokens from a string.">ustrtok_r</a>(NULL, " -", &last);
      }
      free(temp);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the token, or NULL if no more are found. You can free
   the memory pointed to by <tt>`last'</tt> once NULL is returned.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ustrtok" title="Retrieves tokens from a string.">ustrtok</a>.</blockquote>
<div class="al-api"><b>double <a name="uatof">uatof</a>(const char *s);</b></div><br>
   Convert as much of the string as possible to an equivalent double
   precision real number. This function is almost like `ustrtod(s, NULL)'.
<p><b>Return value:</b>
   Returns the equivalent value, or zero if the string does not represent a
   number.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrtol" title="Converts a string into an integer.">ustrtol</a>,
<a class="xref" href="#ustrtod" title="Converts a string into a floating point number.">ustrtod</a>.</blockquote>
<div class="al-api"><b>long <a name="ustrtol">ustrtol</a>(const char *s, char **endp, int base);</b></div><br>
   This function converts the initial part of <tt>`s'</tt> to a signed integer, setting
   `*endp' to point to the first unused character, if <tt>`endp'</tt> is not a NULL
   pointer. The <tt>`base'</tt> argument indicates what base the digits (or letters)
   should be treated as. If <tt>`base'</tt> is zero, the base is determined by looking
   for <tt>`0x'</tt>, <tt>`0X'</tt>, or <tt>`0'</tt> as the first part of the string, and sets the base
   used to 16, 16, or 8 if it finds one. The default base is 10 if none of
   those prefixes are found. Example:
<blockquote class="code"><pre>
      char *endp, *string = "456.203 askdfg";
      int number = <a href="#ustrtol" class="autotype" title="Converts a string into an integer.">ustrtol</a>(string, &amp;endp, 10);</pre></blockquote>
<p><b>Return value:</b>
   Returns the string converted as a value of type `long int'. If nothing was
   converted, returns zero with `*endp' pointing to the beginning of <tt>`s'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrtod" title="Converts a string into a floating point number.">ustrtod</a>,
<a class="xref" href="#uatof" title="Converts a string into a double.">uatof</a>.</blockquote>
<div class="al-api"><b>double <a name="ustrtod">ustrtod</a>(const char *s, char **endp);</b></div><br>
   This function converts as many characters of <tt>`s'</tt> that look like a floating
   point number into one, and sets `*endp' to point to the first unused
   character, if <tt>`endp'</tt> is not a NULL pointer. Example:
<blockquote class="code"><pre>
      char *endp, *string = "456.203 askdfg";
      double number = <a href="#ustrtod" class="autotype" title="Converts a string into a floating point number.">ustrtod</a>(string, &amp;endp);</pre></blockquote>
<p><b>Return value:</b>
   Returns the string converted as a value of type <tt>`double'</tt>. If nothing was
   converted, returns zero with *endp pointing to the beginning of s.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#ustrtol" title="Converts a string into an integer.">ustrtol</a>,
<a class="xref" href="#uatof" title="Converts a string into a double.">uatof</a>.</blockquote>
<div class="al-api"><b>const char *<a name="ustrerror">ustrerror</a>(int err);</b></div><br>
   This function returns a string that describes the error code <tt>`err'</tt>, which
   normally comes from the variable <tt>`errno'</tt>. Example:
<blockquote class="code"><pre>
      <a href="#PACKFILE" class="autotype" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *input_file = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>("badname", "r");
      if (input_file == NULL)
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("%s\nSorry!\n", <a href="#ustrerror" class="autotype" title="Returns a string describing errno.">ustrerror</a>(errno));</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to a static string that should not be modified or
   freed. If you make subsequent calls to ustrerror(), the string will be
   overwritten.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>.</blockquote>
<div class="al-api"><b>int <a name="usprintf">usprintf</a>(char *buf, const char *format, ...);</b></div><br>
   This function writes formatted data into the output buffer. A NULL
   character is written to mark the end of the string. You should try to avoid
   this function because it is very easy to overflow the destination buffer.
   Use uszprintf instead.
<p><b>Return value:</b>
   Returns the number of characters written, not including the terminating
   null character.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#uszprintf" title="Writes formatted data into a buffer, specifying size.">uszprintf</a>,
<a class="xref" href="#uvsprintf" title="Writes formatted data into a buffer, using variable arguments.">uvsprintf</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exkeys" title="How to get input from the keyboard in different ways.">exkeys</a>.</blockquote>
<div class="al-api"><b>int <a name="uszprintf">uszprintf</a>(char *buf, int size, const char *format, ...);</b></div><br>
   This function writes formatted data into the output buffer, whose length
   in bytes is specified by <tt>`size'</tt> and which is guaranteed to be NULL
   terminated. Example:
<blockquote class="code"><pre>
      char buffer[10];
      int player_score;
      ...
      <a href="#uszprintf" class="autotype" title="Writes formatted data into a buffer, specifying size.">uszprintf</a>(buffer, sizeof(buffer), "Your score is: %d", player_score);</pre></blockquote>
<p><b>Return value:</b>
   Returns the number of characters that would have been written without
   eventual truncation (like with usprintf), not including the terminating
   null character.
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#usprintf" title="Writes formatted data into a buffer.">usprintf</a>,
<a class="xref" href="#uvszprintf" title="Writes formatted data into a buffer, using size and variable arguments.">uvszprintf</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="uvsprintf">uvsprintf</a>(char *buf, const char *format, va_list args);</b></div><br>
   This is like usprintf(), but you pass the variable argument list directly,
   instead of the arguments themselves. You can use this function to implement
   printf like functions, also called variadic functions. You should try to
   avoid this function because it is very easy to overflow the destination
   buffer. Use uvszprintf instead.
<p><b>Return value:</b>
   Returns the number of characters written, not including the terminating
   null character.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#usprintf" title="Writes formatted data into a buffer.">usprintf</a>,
<a class="xref" href="#uvszprintf" title="Writes formatted data into a buffer, using size and variable arguments.">uvszprintf</a>.</blockquote>
<div class="al-api"><b>int <a name="uvszprintf">uvszprintf</a>(char *buf, int size, const char *format, va_list args);</b></div><br>
   This is like uszprintf(), but you pass the variable argument list
   directly, instead of the arguments themselves. Example:
<blockquote class="code"><pre>
      #include &lt;stdarg.h&gt;

      void log_message(const char *format, ...)
      {
         char buffer[100];
         va_list parameters;
         
         va_start(parameters, format);
         <a href="#uvszprintf" class="autotype" title="Writes formatted data into a buffer, using size and variable arguments.">uvszprintf</a>(buffer, sizeof(buffer), format, parameters);
         va_end(parameters);
         
         append_buffer_to_logfile(log_name, buffer);
         send_buffer_to_other_networked_players(multicast_ip, buffer);
         and_also_print_it_on_the_screen(cool_font, buffer);
      }
      
      void some_other_function(void)
      {
         log_message("Hello %s, are you %d years old?\n", "Dave", 25);
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns the number of characters that would have been written without
   eventual truncation (like with uvsprintf), not including the terminating
   null character.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#uconvert" title="High level string encoding conversion wrapper.">uconvert</a>,
<a class="xref" href="#uszprintf" title="Writes formatted data into a buffer, specifying size.">uszprintf</a>,
<a class="xref" href="#uvsprintf" title="Writes formatted data into a buffer, using variable arguments.">uvsprintf</a>.</blockquote>
<h1><a name="Configuration routines">Configuration routines</a></h1>

<p>
Various parts of Allegro, such as the sound routines and the 
load_joystick_data() function, require some configuration information. This 
data is stored in text files as a collection of <tt>`variable=value'</tt> lines,
along with comments that begin with a `#' character and continue to the end
of the line. The configuration file may optionally be divided into sections, 
which begin with a <tt>`[sectionname]'</tt> line. Each section has a unique
namespace, to prevent variable name conflicts, but any variables that aren't 
in a section are considered to belong to all the sections simultaneously.

<p>
Note that variable and section names cannot contain spaces.

<p>
By default the configuration data is read from a file called <tt>`allegro.cfg'</tt>,
which can be located either in the same directory as the program executable, 
or the directory pointed to by the ALLEGRO environment variable. Under Unix, 
it also checks for `~/allegro.cfg', `~/.allegrorc', <tt>`/etc/allegro.cfg'</tt>, and
<tt>`/etc/allegrorc'</tt>, in that order; under BeOS only the last two are also
checked. MacOS X also checks in the Contents/Resources directory of the
application bundle, if any, before doing the checks above.

<p>
If you don't like this approach, you can specify any filename you like, or
use a block of binary configuration data provided by your program (which
could for example be loaded from a datafile). You can also extend the paths
searched for allegro resources with set_allegro_resource_path().

<p>
You can store whatever custom information you like in the config file, along 
with the standard variables that are used by Allegro (see below). Allegro
comes with a setup directory where you can find configuration programs. The
standalone setup program is likely to be of interest to final users. It
allows any user to create an <tt>`allegro.cfg'</tt> file without the need to touch a
text editor and enter values by hand. It also provides a few basic tests like
sound playing for sound card testing. You are welcome to include the setup
program with your game, either as is or with modified graphics to fit better
your game.

<p><br>
<div class="al-api"><b>void <a name="set_config_file">set_config_file</a>(const char *filename);</b></div><br>
   Sets the configuration file to be used by all subsequent config 
   functions. If you don't call this function, Allegro will use the default 
   <tt>`allegro.cfg'</tt> file, looking first in the same directory as your program
   and then in the directory pointed to by the ALLEGRO environment variable
   and the usual platform-specific paths for configuration files. For example
   it will look for <tt>`/etc/allegro.cfg'</tt> under Unix.

<p>
   All pointers returned by previous calls to get_config_string() and
   other related functions are invalidated when you call this function!
   You can call this function before install_allegro() to change the
   configuration file, but after set_uformat() if you want to use a text 
   encoding format other than the default.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_data" title="Sets a block of configuration data.">set_config_data</a>,
<a class="xref" href="#override_config_file" title="Specifies a file containing config overrides.">override_config_file</a>,
<a class="xref" href="#push_config_state" title="Pushes the current configuration state.">push_config_state</a>,
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>,
<a class="xref" href="#set_config_string" title="Writes a string in the configuration file.">set_config_string</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>.</blockquote>
<div class="al-api"><b>void <a name="set_config_data">set_config_data</a>(const char *data, int length);</b></div><br>
   Specifies a block of data to be used by all subsequent config functions, 
   which you have already loaded from disk (eg. as part of some more 
   complicated format of your own, or in a grabber datafile). This routine 
   makes a copy of the information, so you can safely free the data after 
   calling it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#override_config_data" title="Specifies a block of data containing config overrides.">override_config_data</a>,
<a class="xref" href="#push_config_state" title="Pushes the current configuration state.">push_config_state</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>,
<a class="xref" href="#set_config_string" title="Writes a string in the configuration file.">set_config_string</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>.</blockquote>
<div class="al-api"><b>void <a name="override_config_file">override_config_file</a>(const char *filename);</b></div><br>
   Specifies a file containing config overrides. These settings will be used 
   in addition to the parameters in the main config file, and where a 
   variable is present in both files this version will take priority. This 
   can be used by application programmers to override some of the config 
   settings from their code, while still leaving the main config file free 
   for the end user to customise. For example, you could specify a 
   particular sample frequency and IBK instrument file, but the user could 
   still use an <tt>`allegro.cfg'</tt> file to specify the port settings and irq
   numbers.

<p>
   The override config file will not only take precedence when reading, but
   will also be used for storing values. When you are done with using the
   override config file, you can call override_config_file with a NULL
   parameter, so config data will be directly read from the current config
   file again.

<p>
   Note: The override file is completely independent from the current
   configuration. You can e.g. call set_config_file, and the override file
   will still be active. Also the flush_config_file function will only affect
   the current config file (which can be changed with set_config_file), never
   the overriding one specified with this function. The modified override
   config is written back to disk whenever you call override_config_file.

<p>
   Example:
<blockquote class="code"><pre>
      <a href="#override_config_file" class="autotype" title="Specifies a file containing config overrides.">override_config_file</a>("my.cfg");
      /* This will read from my.cfg, and if it doesn't find a
       * setting, will read from the current config file instead.
       */
      language = <a href="#get_config_string" class="autotype" title="Retrieves a string from the configuration file.">get_config_string</a>("system", "language", NULL);
      /* This will always write to my.cfg, no matter if the
       * settings is already present or not.
       */
      <a href="#set_config_string" class="autotype" title="Writes a string in the configuration file.">set_config_string</a>("system", "language", "RU");
      /* This forces the changed setting to be written back to
       * disk. Else it is written back at the next call to
       * <a href="#override_config_file" class="autotype" title="Specifies a file containing config overrides.">override_config_file</a>, or when Allegro shuts down.
       */
      <a href="#override_config_file" class="autotype" title="Specifies a file containing config overrides.">override_config_file</a>(NULL);</pre></blockquote>

<p>
   Note that this function and override_config_data() are mutually exclusive,
   i.e. calling one will cancel the effects of the other.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#override_config_data" title="Specifies a block of data containing config overrides.">override_config_data</a>,
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>.</blockquote>
<div class="al-api"><b>void <a name="override_config_data">override_config_data</a>(const char *data, int length);</b></div><br>
   Version of override_config_file() which uses a block of data that has 
   already been read into memory. The length of the block has to be specified
   in bytes. Example:
<blockquote class="code"><pre>
      /* Force German as system language, Spanish keyboard map. */
      const char *override_data = "[system]\n"
         "language=DE\n"
         "keyboard=ES";
      <a href="#override_config_data" class="autotype" title="Specifies a block of data containing config overrides.">override_config_data</a>(override_data, <a href="#ustrsize" class="autotype" title="Size of the string in bytes without null terminator.">ustrsize</a>(override_data));</pre></blockquote>

<p>
   Note that this function and override_config_file() are mutually exclusive,
   i.e. calling one will cancel the effects of the other.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#override_config_file" title="Specifies a file containing config overrides.">override_config_file</a>,
<a class="xref" href="#set_config_data" title="Sets a block of configuration data.">set_config_data</a>.</blockquote>
<div class="al-api"><b>void <a name="push_config_state">push_config_state</a>();</b></div><br>
   Pushes the current configuration state (filename, variable values, etc). 
   onto an internal stack, allowing you to select some other config source 
   and later restore the current settings by calling pop_config_state(). 
   This function is mostly intended for internal use by other library 
   functions, for example when you specify a config filename to the 
   save_joystick_data() function, it pushes the config state before 
   switching to the file you specified.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pop_config_state" title="Pops a previously pushed configuration state.">pop_config_state</a>,
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#save_joystick_data" title="Saves joystick calibration data.">save_joystick_data</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>.</blockquote>
<div class="al-api"><b>void <a name="pop_config_state">pop_config_state</a>();</b></div><br>
   Pops a configuration state previously stored by push_config_state(), 
   replacing the current config source with it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#push_config_state" title="Pushes the current configuration state.">push_config_state</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>.</blockquote>
<div class="al-api"><b>void <a name="flush_config_file">flush_config_file</a>();</b></div><br>
   Writes the current config file to disk if the contents have changed 
   since it was loaded or since the latest call to the function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#override_config_file" title="Specifies a file containing config overrides.">override_config_file</a>,
<a class="xref" href="#push_config_state" title="Pushes the current configuration state.">push_config_state</a>.</blockquote>
<div class="al-api"><b>void <a name="reload_config_texts">reload_config_texts</a>(const char *new_language);</b></div><br>
   Reloads the translated strings returned by get_config_text(). This is
   useful to switch to another language in your program at runtime. If you
   want to modify the <tt>`[system]'</tt> language configuration variable yourself, or
   you have switched configuration files, you will want to pass NULL to
   just reload whatever language is currently selected. Or you can pass a
   string containing the two letter code of the language you desire to
   switch to, and the function will modify the language variable. After you
   call this function, the previously returned pointers of get_config_text()
   will be invalid. Example:
<blockquote class="code"><pre>
      ...
      /* The user selects French from a language choice menu. */
      <a href="#reload_config_texts" class="autotype" title="Reloads translated strings returned by get_config_text().">reload_config_texts</a>("FR");</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_config_text" title="Returns a string translated to the current language.">get_config_text</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>
<div class="al-api"><b>void <a name="hook_config_section">hook_config_section</a>(const char *section,
       int (*intgetter)(const char *name, int def),
       const char *(*stringgetter)(const char *name, const char *def),
       void (*stringsetter)(const char *name, const char *value));</b></div><br>
   Takes control of the specified config file section, so that your hook 
   functions will be used to manipulate it instead of the normal disk file 
   access. If both the getter and setter functions are NULL, a currently 
   present hook will be unhooked. Hooked functions have the highest 
   priority. If a section is hooked, the hook will always be called, so you 
   can also hook a '#' section: even override_config_file() cannot override 
   a hooked section. Example:
<blockquote class="code"><pre>
      int decode_encrypted_int(const char *name, int def)
      {
         ...
      }
      
      const char *decode_encrypted_string(const char *name, const char *def)
      {
         ...
      }
      
      void encode_plaintext_string(const char *name, const char *value)
      {
         ...
      }
      
      int main(int argc, char *argv[])
      {
         ...
         /* Make it harder for users to tinker with the high scores. */
         <a href="#hook_config_section" class="autotype" title="Hooks a configuration file section with custom handlers.">hook_config_section</a>("high_scores", decode_encrypted_int,
            decode_encrypted_string, encode_plaintext_string);
         ...
      } <a href="#END_OF_MAIN" class="autotype" title="Macro to put after your main() function.">END_OF_MAIN</a>()</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#config_is_hooked" title="Tells if a config section has custom hooks.">config_is_hooked</a>.</blockquote>
<div class="al-api"><b>int <a name="config_is_hooked">config_is_hooked</a>(const char *section);</b></div><br>
   Returns TRUE if the specified config section has been hooked. Example:
<blockquote class="code"><pre>
      if (<a href="#config_is_hooked" class="autotype" title="Tells if a config section has custom hooks.">config_is_hooked</a>("high_scores")) {
         <a href="#hook_config_section" class="autotype" title="Hooks a configuration file section with custom handlers.">hook_config_section</a>("high_scores, NULL, NULL, NULL);
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#hook_config_section" title="Hooks a configuration file section with custom handlers.">hook_config_section</a>.</blockquote>
<div class="al-api"><b>const char *<a name="get_config_string">get_config_string</a>(const char *section,
                              const char *name, const char *def);</b></div><br>
   Retrieves a string variable from the current config file. The section name
   may be set to NULL to read variables from the root of the file, or used to
   control which set of parameters (eg. sound or joystick) you are interested
   in reading. Example:
<blockquote class="code"><pre>
      const char *lang = <a href="#get_config_string" class="autotype" title="Retrieves a string from the configuration file.">get_config_string</a>("system", "language", "EN");
</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the constant string found in the configuration file.
   If the named variable cannot be found, or its entry in the config file is
   empty, the value of <tt>`def'</tt> is returned.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#set_config_string" title="Writes a string in the configuration file.">set_config_string</a>,
<a class="xref" href="#get_config_argv" title="Reads a token list from the configuration file.">get_config_argv</a>,
<a class="xref" href="#get_config_float" title="Retrieves a float from the configuration file.">get_config_float</a>,
<a class="xref" href="#get_config_hex" title="Retrieves a hexadecimal value from the configuration file.">get_config_hex</a>,
<a class="xref" href="#get_config_int" title="Retrieves an integer from the configuration file.">get_config_int</a>,
<a class="xref" href="#get_config_id" title="Retrieves a driver ID from a configuration file.">get_config_id</a>,
<a class="xref" href="#get_config_text" title="Returns a string translated to the current language.">get_config_text</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>.</blockquote>
<div class="al-api"><b>int <a name="get_config_int">get_config_int</a>(const char *section, const char *name, int def);</b></div><br>
   Reads an integer variable from the current config file. See the comments 
   about get_config_string().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#set_config_int" title="Writes an integer in the configuration file.">set_config_int</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#get_config_argv" title="Reads a token list from the configuration file.">get_config_argv</a>,
<a class="xref" href="#get_config_float" title="Retrieves a float from the configuration file.">get_config_float</a>,
<a class="xref" href="#get_config_hex" title="Retrieves a hexadecimal value from the configuration file.">get_config_hex</a>,
<a class="xref" href="#get_config_id" title="Retrieves a driver ID from a configuration file.">get_config_id</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>.</blockquote>
<div class="al-api"><b>int <a name="get_config_hex">get_config_hex</a>(const char *section, const char *name, int def);</b></div><br>
   Reads an integer variable from the current config file, in hexadecimal 
   format. See the comments about get_config_string().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#set_config_hex" title="Writes a hexadecimal integer in the configuration file.">set_config_hex</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#get_config_argv" title="Reads a token list from the configuration file.">get_config_argv</a>,
<a class="xref" href="#get_config_float" title="Retrieves a float from the configuration file.">get_config_float</a>,
<a class="xref" href="#get_config_int" title="Retrieves an integer from the configuration file.">get_config_int</a>,
<a class="xref" href="#get_config_id" title="Retrieves a driver ID from a configuration file.">get_config_id</a>.</blockquote>
<div class="al-api"><b>float <a name="get_config_float">get_config_float</a>(const char *section, const char *name, float def);</b></div><br>
   Reads a floating point variable from the current config file. See the 
   comments about get_config_string().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#set_config_float" title="Writes a float in the configuration file.">set_config_float</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#get_config_argv" title="Reads a token list from the configuration file.">get_config_argv</a>,
<a class="xref" href="#get_config_hex" title="Retrieves a hexadecimal value from the configuration file.">get_config_hex</a>,
<a class="xref" href="#get_config_int" title="Retrieves an integer from the configuration file.">get_config_int</a>,
<a class="xref" href="#get_config_id" title="Retrieves a driver ID from a configuration file.">get_config_id</a>.</blockquote>
<div class="al-api"><b>int <a name="get_config_id">get_config_id</a>(const char *section, const char *name, int def);</b></div><br>
   Reads a 4-letter driver ID variable from the current config file. See the 
   comments about get_config_string().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#set_config_id" title="Writes a driver ID in the configuration file.">set_config_id</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#get_config_argv" title="Reads a token list from the configuration file.">get_config_argv</a>,
<a class="xref" href="#get_config_float" title="Retrieves a float from the configuration file.">get_config_float</a>,
<a class="xref" href="#get_config_hex" title="Retrieves a hexadecimal value from the configuration file.">get_config_hex</a>,
<a class="xref" href="#get_config_int" title="Retrieves an integer from the configuration file.">get_config_int</a>.</blockquote>
<div class="al-api"><b>char **<a name="get_config_argv">get_config_argv</a>(const char *section, const char *name, int *argc);</b></div><br>
   Reads a token list (words separated by spaces) from the current config
   file. The token list is stored in a temporary buffer that will be clobbered
   by the next call to get_config_argv(), so the data should not be expected
   to persist.
<p><b>Return value:</b>
   Returns an argv style argument list and sets <tt>`argc'</tt> to the number of
   retrieved tokens. If the variable is not present, returns NULL and sets 
   argc to zero.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#get_config_float" title="Retrieves a float from the configuration file.">get_config_float</a>,
<a class="xref" href="#get_config_hex" title="Retrieves a hexadecimal value from the configuration file.">get_config_hex</a>,
<a class="xref" href="#get_config_int" title="Retrieves an integer from the configuration file.">get_config_int</a>,
<a class="xref" href="#get_config_id" title="Retrieves a driver ID from a configuration file.">get_config_id</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>.</blockquote>
<div class="al-api"><b>const char *<a name="get_config_text">get_config_text</a>(const char *msg);</b></div><br>
   This function is primarily intended for use by internal library code, but 
   it may perhaps be helpful to application programmers as well. It uses the 
   <tt>`language.dat'</tt> or <tt>`XXtext.cfg'</tt> files (where XX is a language code) to look 
   up a translated version of the parameter in the currently selected 
   language.

<p>
   This is basically the same thing as calling get_config_string() with 
   <tt>`[language]'</tt> as the section, <tt>`msg'</tt> as the variable name, and <tt>`msg'</tt> as the 
   default value, but it contains some special code to handle Unicode format 
   conversions. The <tt>`msg'</tt> parameter is always given in ASCII format, but the 
   returned string will be converted into the current text encoding, with 
   memory being allocated as required, so you can assume that this pointer 
   will persist without having to manually allocate storage space for each 
   string.

<p>
   Note that if you are planning on distributing your game on the Unix
   platform there is a special issue with how to deal with the <tt>`language.dat'</tt>
   file. Read section "Files shared by Allegro" of the chapter "Unix
   specifics" to learn more about this.
<p><b>Return value:</b>
   Returns a suitable translation if one can be found or a copy of the 
   parameter if nothing else is available. 


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#reload_config_texts" title="Reloads translated strings returned by get_config_text().">reload_config_texts</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>
<div class="al-api"><b>void <a name="set_config_string">set_config_string</a>(const char *section, const char *name,
                       const char *val);</b></div><br>
   Writes a string variable to the current config file, replacing any 
   existing value it may have, or removes the variable if <tt>`val'</tt> is NULL. The
   section name may be set to NULL to write the variable to the root of the 
   file, or used to control which section the variable is inserted into. The 
   altered file will be cached in memory, and not actually written to disk 
   until you call allegro_exit(). Note that you can only write to files in 
   this way, so the function will have no effect if the current config 
   source was specified with set_config_data() rather than set_config_file().

<p>
   As a special case, variable or section names that begin with a '#' 
   character are treated specially and will not be read from or written to 
   the disk. Addon packages can use this to store version info or other 
   status information into the config module, from where it can be read with 
   the get_config_string() function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#set_config_float" title="Writes a float in the configuration file.">set_config_float</a>,
<a class="xref" href="#set_config_hex" title="Writes a hexadecimal integer in the configuration file.">set_config_hex</a>,
<a class="xref" href="#set_config_int" title="Writes an integer in the configuration file.">set_config_int</a>,
<a class="xref" href="#set_config_id" title="Writes a driver ID in the configuration file.">set_config_id</a>.</blockquote>
<div class="al-api"><b>void <a name="set_config_int">set_config_int</a>(const char *section, const char *name, int val);</b></div><br>
   Writes an integer variable to the current config file. See the comments 
   about set_config_string().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#get_config_int" title="Retrieves an integer from the configuration file.">get_config_int</a>,
<a class="xref" href="#set_config_string" title="Writes a string in the configuration file.">set_config_string</a>,
<a class="xref" href="#set_config_float" title="Writes a float in the configuration file.">set_config_float</a>,
<a class="xref" href="#set_config_hex" title="Writes a hexadecimal integer in the configuration file.">set_config_hex</a>,
<a class="xref" href="#set_config_id" title="Writes a driver ID in the configuration file.">set_config_id</a>.</blockquote>
<div class="al-api"><b>void <a name="set_config_hex">set_config_hex</a>(const char *section, const char *name, int val);</b></div><br>
   Writes an integer variable to the current config file, in hexadecimal 
   format. See the comments about set_config_string().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#get_config_hex" title="Retrieves a hexadecimal value from the configuration file.">get_config_hex</a>,
<a class="xref" href="#set_config_string" title="Writes a string in the configuration file.">set_config_string</a>,
<a class="xref" href="#set_config_float" title="Writes a float in the configuration file.">set_config_float</a>,
<a class="xref" href="#set_config_int" title="Writes an integer in the configuration file.">set_config_int</a>,
<a class="xref" href="#set_config_id" title="Writes a driver ID in the configuration file.">set_config_id</a>.</blockquote>
<div class="al-api"><b>void <a name="set_config_float">set_config_float</a>(const char *section, const char *name, float val);</b></div><br>
   Writes a floating point variable to the current config file. See the 
   comments about set_config_string().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#get_config_float" title="Retrieves a float from the configuration file.">get_config_float</a>,
<a class="xref" href="#set_config_string" title="Writes a string in the configuration file.">set_config_string</a>,
<a class="xref" href="#set_config_hex" title="Writes a hexadecimal integer in the configuration file.">set_config_hex</a>,
<a class="xref" href="#set_config_int" title="Writes an integer in the configuration file.">set_config_int</a>,
<a class="xref" href="#set_config_id" title="Writes a driver ID in the configuration file.">set_config_id</a>.</blockquote>
<div class="al-api"><b>void <a name="set_config_id">set_config_id</a>(const char *section, const char *name, int val);</b></div><br>
   Writes a 4-letter driver ID variable to the current config file. See the
   comments about set_config_string().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#get_config_id" title="Retrieves a driver ID from a configuration file.">get_config_id</a>,
<a class="xref" href="#set_config_string" title="Writes a string in the configuration file.">set_config_string</a>,
<a class="xref" href="#set_config_float" title="Writes a float in the configuration file.">set_config_float</a>,
<a class="xref" href="#set_config_hex" title="Writes a hexadecimal integer in the configuration file.">set_config_hex</a>,
<a class="xref" href="#set_config_int" title="Writes an integer in the configuration file.">set_config_int</a>.</blockquote>
<div class="al-api"><b>int <a name="list_config_entries">list_config_entries</a>(const char *section, const char ***names);</b></div><br>
   This function can be used to get a list of all entries in the given config
   section. The names parameter is a pointer to an array of strings. If it
   points to a NULL pointer, the list will be allocated, else it will be
   re-allocated. You should free the list again with free_config_entries if you
   don't need it anymore, or you can pass it again to list_config_entries and
   the memory will be re-used. See the following example for how you can use it,
   it will print out the complete contents of the current configuration:
<blockquote class="code"><pre>
   int i, n;
   char const **sections = NULL;
   char const **entries = NULL;

   /* List all entries not in any section. */
   n = <a href="#list_config_entries" class="autotype" title="Lists the names of all entries in a config section">list_config_entries</a>(NULL, &amp;entries);
   for (i = 0; i < n; i++)
      printf(" %s=\"%s\"\n", entries[i], <a href="#get_config_string" class="autotype" title="Retrieves a string from the configuration file.">get_config_string</a>(
             NULL, entries[i], "-"));

   /* List all sections (and entries in them). */
   n = <a href="#list_config_sections" class="autotype" title="Lists the names of all sections available in the current configuration.">list_config_sections</a>(&amp;sections);
   /* loop through all section names */
   for (i = 0; i < n; i++)
   {
      int j, m;
      printf("%s\n", sections[i]);
      m = <a href="#list_config_entries" class="autotype" title="Lists the names of all entries in a config section">list_config_entries</a>(sections[i], &amp;entries);
      /* loop through all entries in the section */
      for (j = 0; j < m; j++)
      {
          printf(" %s=\"%s\"\n", entries[j], <a href="#get_config_string" class="autotype" title="Retrieves a string from the configuration file.">get_config_string</a>(
             sections[i], entries[j], "-"));
      }
   }
   /* It is enough to free the arrays once at the end. */
   <a href="#free_config_entries" class="autotype" title="Frees memory allocated for config entry lists.">free_config_entries</a>(&amp;sections);
   <a href="#free_config_entries" class="autotype" title="Frees memory allocated for config entry lists.">free_config_entries</a>(&amp;entries);</pre></blockquote>
<p><b>Return value:</b>
   Returns the number of valid strings in the names array.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#list_config_sections" title="Lists the names of all sections available in the current configuration.">list_config_sections</a>,
<a class="xref" href="#free_config_entries" title="Frees memory allocated for config entry lists.">free_config_entries</a>.</blockquote>
<div class="al-api"><b>int <a name="list_config_sections">list_config_sections</a>(const char ***names);</b></div><br>
   The names parameter is a pointer to an array of strings. If it points to a
   NULL pointer, the list will be allocated, else it will be re-allocated. After
   the function returns, it will contain the names of all sections in the
   current configuration. Use free_config_entries to free the allocated memory
   again. See list_config_entries for more information and an example how to use
   it.
<p><b>Return value:</b>
   Returns the number of valid strings in the names array.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#list_config_entries" title="Lists the names of all entries in a config section">list_config_entries</a>,
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#free_config_entries" title="Frees memory allocated for config entry lists.">free_config_entries</a>.</blockquote>
<div class="al-api"><b>int <a name="free_config_entries">free_config_entries</a>(const char ***names);</b></div><br>

<p>
   Once you are done with the string arrays filled in by list_config_entries and
   list_config_sections, you can free them again with this function. The passed
   array pointer will be set to NULL, and you directly can pass the same pointer
   again to list_config_entries or list_config_sections later - but you also
   could pass them again without freeing first, since the memory is re-allocated
   when the pointer is not NULL.

<p>
   See list_config_entries for an example of how to use it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#list_config_entries" title="Lists the names of all entries in a config section">list_config_entries</a>,
<a class="xref" href="#list_config_sections" title="Lists the names of all sections available in the current configuration.">list_config_sections</a>.</blockquote>
<br><center><h2><a name="Standard config variables">Standard config variables</a></h2></center><p>
Allegro uses these standard variables from the configuration file:
<ul><li>
[system]<br>
   Section containing general purpose variables:
<ul><li>
system = x<br>
   Specifies which system driver to use. This is currently only useful on 
   Linux, for choosing between the X-Windows ("XWIN") or console ("LNXC") 
   modes.
<li>
keyboard = x<br>
   Specifies which keyboard layout to use. The parameter is the name of a 
   keyboard mapping file produced by the keyconf utility, and can either be 
   a fully qualified file path or a base name like <tt>`us'</tt> or <tt>`uk'</tt>. If the 
   latter, Allegro will look first for a separate config file with that name 
   (eg. <tt>`uk.cfg'</tt>) and then for an object with that name in the <tt>`keyboard.dat'</tt>
   file (eg. <tt>`UK_CFG'</tt>). The config file or <tt>`keyboard.dat'</tt> file can be stored 
   in the same directory as the program, or in the location pointed to by 
   the ALLEGRO environment variable. Look in the <tt>`keyboard.dat'</tt> file to see 
   what mappings are currently available.
<li>
language = x<br>
   Specifies which language file to use for error messages and other bits of 
   system text. The parameter is the name of a translation file, and can 
   either be a fully qualified file path or a base name like <tt>`en'</tt> or <tt>`es'</tt>. If
   the latter, Allegro will look first for a separate config file with a 
   name in the form <tt>`entext.cfg'</tt>, and then for an object with that name in 
   the <tt>`language.dat'</tt> file (eg. <tt>`ENTEXT_CFG'</tt>). The config file or 
   <tt>`language.dat'</tt> file can be stored in the same directory as the program, or 
   in the location pointed to by the ALLEGRO environment variable.

   Look in the <tt>`language.dat'</tt> file to see which mappings are currently
   available. If there is none for your language, you can create it using the
   English one as model, and even send it to the Allegro development team to
   include it in future releases.
<li>
disable_screensaver = x<br>
   Specifies whether to disable the screensaver: 0 to never disable it, 1 to
   disable it in fullscreen mode only and 2 to always disable it. Default is 1.
<li>
menu_opening_delay = x<br>
   Sets how long the menus take to auto-open. The time is given in
   milliseconds (default is <tt>`300'</tt>). Specifying `-1' will disable the 
   auto-opening feature.
<li>
XInitThreads = x<br>
   If this is set to 0, the X11 port will not call XInitThreads. This can have
   slight performance advantages and was required on some broken X11 servers,
   but it makes Allegro incompatible with other X11 libraries like Mesa.
</ul><li>
[graphics]<br>
   Section containing graphics configuration information, using the
   variables:
<ul><li>
gfx_card = x<br>
   Specifies which graphics driver to use when the program requests 
   GFX_AUTODETECT. Multiple possible drivers can be suggested with extra 
   lines in the form `gfx_card1 = x', `gfx_card2 = x', etc, or you can 
   specify different drivers for each mode and color depth with variables in 
   the form `gfx_card_24bpp = x', `gfx_card_640x480x16 = x', etc.
<li>
gfx_cardw = x<br>
   Specifies which graphics driver to use when the program requests 
   GFX_AUTODETECT_WINDOWED. This variable functions exactly like
   gfx_card in all other respects. If it is not set, Allegro will look
   for the gfx_card variable.
<li>
disable_vsync = x<br>
   Specifies whether to disable synchronization with the vertical blank when
   page-flipping (yes or no). Disabling synchronization may increase the
   frame rate on slow systems, at the expense of introducing flicker on fast
   systems.
<li>
vbeaf_driver = x<br>
   DOS and Linux only: specifies where to look for the VBE/AF driver 
   (vbeaf.drv). If this variable is not set, Allegro will look in the same 
   directory as the program, and then fall back on the standard locations 
   (<tt>`c:\'</tt> for DOS, <tt>`/usr/local/lib'</tt>, <tt>`/usr/lib'</tt>, <tt>`/lib'</tt>, and <tt>`/'</tt> for Linux, or 
   the directory specified with the VBEAF_PATH environment variable).
<li>
framebuffer = x<br>
   Linux only: specifies what device file to use for the fbcon driver. If 
   this variable is not set, Allegro checks the FRAMEBUFFER environment 
   variable, and then defaults to <tt>`/dev/fb0'</tt>.
<li>
force_centering = x<br>
   Unix/X11 only: specifies whether to force window centering in fullscreen
   mode when the XWFS driver is used (yes or no). Enabling this setting may
   cause some artifacts to appear on KDE desktops.
<li>
disable_direct_updating = x<br>
   Windows only: specifies whether to disable direct updating when the 
   GFX_DIRECTX_WIN driver is used in color conversion mode (yes or no).
   Direct updating can cause artifacts to be left on the desktop when the 
   window is moved or minimized; disabling it results in a significant
   performance loss.
</ul><li>
[mouse]<br>
   Section containing mouse configuration information, using the variables:
<ul><li>
mouse = x<br>
   Mouse driver type. Available DOS drivers are:
<blockquote class="text"><pre>
      MICK - mickey mode driver (normally the best)
      I33  - int 0x33 callback driver
      POLL - timer polling (for use under NT)
</pre></blockquote>
   Linux console mouse drivers are:
<blockquote class="text"><pre>
      MS   - Microsoft serial mouse
      IMS  - Microsoft serial mouse with Intellimouse extension
      LPS2 - PS2 mouse
      LIPS - PS2 mouse with Intellimouse extension
      GPMD - GPM repeater data (Mouse Systems protocol)
      EV   - Event interfaces (EVDEV)</pre></blockquote>
<li>
num_buttons = x<br>
   Sets the number of mouse buttons viewed by Allegro. You don't normally
   need to set this variable because Allegro will autodetect it. You can only
   use it to restrict the set of actual mouse buttons to zero or positive
   values, negative values will be ignored.
<li>
emulate_three = x<br>
   Sets whether to emulate a third mouse button by detecting chords of the 
   left and right buttons (yes or no). Defaults to no.
<li>
mouse_device = x<br>
   Linux only: specifies the name of the mouse device file (eg. 
   <tt>`/dev/mouse'</tt>).
<li>
ev_absolute = x<br>
   Linux only: specifies the mode for the default EV input:
      0 - relative mode: pointer position changes if the input moves,
      1 - absolute mode: pointer position is the input position.
   If unspecified, the mode is relative.
   If the device supports several tools (such as a graphic tablet), the
   default input is the mouse. If the device has only one tool (e.g. a
   normal mouse) the default input is this tool. All additional tools
   work in absolute mode.
<li>
ev_min_x = x<br>
ev_max_x = x<br>
ev_min_y = x<br>
ev_max_y = x<br>
ev_min_z = x<br>
ev_max_z = x<br>
   Linux only: for absolute EV inputs, minimum and maximum value. By default
   this information is autodetected.  If you want to use only part of a
   tablet, you need to set the entries for X and Y axis by hand.
<li>
ev_abs_to_rel_x = x<br>
ev_abs_to_rel_y = x<br>
ev_abs_to_rel_z = x<br>
   Linux only: scaling factor for tablet mouse speed.  Defaults to 1.
   This is used only when the input sends absolute events (tablet, joystick,
   etc.) and the cursor should behave like a mouse.
   If you are using a mouse on a tablet, you need to set these entries
   for X and Y axis (try numbers between 1 and 40).
<li>
mouse_accel_factor = x<br>
   Windows only: specifies the mouse acceleration factor. Defaults to 1.
   Set it to 0 in order to disable mouse acceleration. 2 accelerates twice
   as much as 1.
</ul><li>
[sound]<br>
   Section containing sound configuration information, using the variables:
<ul><li>
digi_card = x<br>
   Sets the driver to use for playing digital samples.
<li>
midi_card = x<br>
   Sets the driver to use for MIDI music.
<li>
digi_input_card = x<br>
   Sets the driver to use for digital sample input.
<li>
midi_input_card = x<br>
   Sets the driver to use for MIDI data input.
<li>
digi_voices = x<br>
   Specifies the minimum number of voices to reserve for use by the digital 
   sound driver. How many are possible depends on the driver.
<li>
midi_voices = x<br>
   Specifies the minimum number of voices to reserve for use by the MIDI 
   sound driver. How many are possible depends on the driver.
<li>
digi_volume = x<br>
   Sets the volume for digital sample playback, from 0 to 255.
<li>
midi_volume = x<br>
   Sets the volume for midi music playback, from 0 to 255.
<li>
quality = x<br>
   Controls the sound quality vs. performance tradeoff for the sample mixing 
   code. This can be set to any of the values:<blockquote class="text"><pre>
      0 - fast mixing of 8-bit data into 16-bit buffers
      1 - true 16-bit mixing (requires a 16-bit stereo sound card)
      2 - interpolated 16-bit mixing</pre></blockquote>
<li>
flip_pan = x<br>
   Toggling this between 0 and 1 reverses the left/right panning of samples, 
   which might be needed because some SB cards get the stereo image the wrong
   way round.
<li>
sound_freq = x<br>
   DOS, Unix and BeOS: sets the sample frequency. With the SB driver, 
   possible rates are 11906 (any), 16129 (any), 22727 (SB 2.0 and above), 
   and 45454 (only on SB 2.0 or SB16, not the stereo SB Pro driver). On the 
   ESS Audiodrive, possible rates are 11363, 17046, 22729, or 44194. On the 
   Ensoniq Soundscape, possible rates are 11025, 16000, 22050, or 48000. On 
   the Windows Sound System, possible rates are 11025, 22050, 44100, or 
   48000. Don't worry if you set some other number by mistake: Allegro will 
   automatically round it to the closest supported frequency.
<li>
sound_bits = x<br>
   Unix and BeOS: sets the preferred number of bits (8 or 16).
<li>
sound_stereo = x<br>
   Unix and BeOS: selects mono or stereo output (0 or 1).
<li>
sound_port = x<br>
   DOS only: sets the sound card port address (this is usually 220).
<li>
sound_dma = x<br>
   DOS only: sets the sound card DMA channel (this is usually 1).
<li>
sound_irq = x<br>
   DOS only: sets the sound card IRQ number (this is usually 7).
<li>
fm_port = x<br>
   DOS only: sets the port address of the OPL synth (this is usually 388).
<li>
mpu_port = x<br>
   DOS only: sets the port address of the MPU-401 MIDI interface (this is 
   usually 330).
<li>
mpu_irq = x<br>
   DOS only: sets the IRQ for the MPU-401 (this is usually the same as 
   sound_irq).
<li>
ibk_file = x<br>
   DOS only: specifies the name of a .IBK file which will be used to replace 
   the standard Adlib patch set.
<li>
ibk_drum_file = x<br>
   DOS only: specifies the name of a .IBK file which will be used to replace 
   the standard set of Adlib percussion patches.
<li>
oss_driver = x<br>
   Unix only: sets the OSS device driver name. Usually <tt>`/dev/dsp'</tt> or 
   <tt>`/dev/audio'</tt>, but could be a particular device (e.g. <tt>`/dev/dsp2'</tt>).
<li>
oss_numfrags = x<br>
oss_fragsize = x<br>
   Unix only: sets number of OSS driver fragments (buffers) and size of each 
   buffer in samples. Buffers are filled with data in the interrupts where 
   interval between subsequent interrupts is not less than 10 ms. If 
   hardware can play all information from buffers faster than 10 ms, then 
   there will be clicks, when hardware have played all data and library has 
   not prepared new data yet. On the other hand, if it takes too long for 
   device driver to play data from all buffers, then there will be delays 
   between action which triggers sound and sound itself.
<li>
oss_midi_driver = x<br>
   Unix only: sets the OSS MIDI device name. Usually <tt>`/dev/sequencer'</tt>.
<li>
oss_mixer_driver = x<br>
   Unix only: sets the OSS mixer device name. Usually <tt>`/dev/mixer'</tt>.
<li>
esd_server = x<br>
   Unix only: where to find the ESD (Enlightened Sound Daemon) server.
<li>
alsa_card = x<br>
alsa_pcmdevice = x<br>
   Unix only: card number and PCM device for the ALSA 0.5 sound driver.
<li>
alsa_device = x<br>
   Unix only: device name for the ALSA 0.9 sound driver. The format is
   &lt;driver&gt;[:&lt;card&gt;,&lt;device&gt;], for example: `hw:0,1'.
<li>
alsa_mixer_device = x<br>
   Unix only: mixer device name for the ALSA 0.9 sound driver. The
   default is "default".
<li>
alsa_mixer_elem = x<br>
   Unix only: mixer element name for the ALSA 0.9 driver. The default
   is PCM.
<li>
alsa_numfrags = x<br>
   Unix only: number of ALSA driver fragments (buffers).
<li>
alsa_fragsize = x<br>
   Unix only: size of each ALSA fragment, in samples.
<li>
alsa_rawmidi_card = x<br>
   Unix only: card number and device for the ALSA 0.5 midi driver.
<li>
alsa_rawmidi_device = x<br>
   Unix only: device for the ALSA 0.5 midi driver or device name for
   the ALSA 0.9 midi driver (see alsa_device for the format).
<li>
jack_client_name = x<br>
   Sets the name with which Allegro should identify itself to the Jack
   audio server.
<li>
jack_buffer_size = x<br>
   Forces a buffer size for the transfer buffer from Allegro's mixer
   to Jack.
<li>
be_midi_quality = x<br>
   BeOS only: system MIDI synthesizer instruments quality. 0 uses low
   quality 8-bit 11 kHz samples, 1 uses 16-bit 22 kHz samples.
<li>
be_midi_freq = x<br>
   BeOS only: MIDI sample mixing frequency in Hz. Can be 11025, 22050 or
   44100.
<li>
be_midi_interpolation = x<br>
   BeOS only: specifies the MIDI samples interpolation method. 0 doesn't
   interpolate, it's fast but has the worst quality; 1 does a fast
   interpolation with better performances, but it's a bit slower than the
   previous method; 2 does a linear interpolation between samples, it is the
   slowest method but gives the best performances.
<li>
be_midi_reverb = x<br>
   BeOS only: reverberation intensity, from 0 to 5. 0 disables it, 5 is the
   strongest one.
<li>
ca_midi_quality = x<br>
   MacOS X only: CoreAudio MIDI synthesizer rendering quality, from 0 to 127.
   Higher qualities sound better but increase the CPU work load.
<li>
ca_midi_reverb = x<br>
   MacOS X only: CoreAudio MIDI synthesizer reverberation intensity, from 0
   to 5. 0 equals to a small room (low reverb), 5 to a plate (high reverb).
<li>
patches = x<br>
   Specifies where to find the sample set for the DIGMID driver. This can 
   either be a Gravis style directory containing a collection of .pat files 
   and a <tt>`default.cfg'</tt> index, or an Allegro datafile produced by the pat2dat 
   utility. If this variable is not set, Allegro will look either for a 
   <tt>`default.cfg'</tt> or <tt>`patches.dat'</tt> file in the same directory as the program, 
   the directory pointed to by the ALLEGRO environment variable, and the 
   standard GUS directory pointed to by the ULTRASND environment variable.
</ul><li>
[midimap]<br>
   If you are using the SB MIDI output or MPU-401 drivers with an external 
   synthesiser that is not General MIDI compatible, you can use the midimap 
   section of the config file to specify a patch mapping table for 
   converting GM patch numbers into whatever bank and program change 
   messages will select the appropriate sound on your synth. This is a real 
   piece of self-indulgence. I have a Yamaha TG500, which has some great 
   sounds but no GM patch set, and I just had to make it work somehow...

   This section consists of a set of lines in the form:
<ul><li>
p&lt;n&gt; = bank0 bank1 prog pitch<br>
   With this statement, n is the GM program change number (1-128), bank0 and 
   bank1 are the two bank change messages to send to your synth (on 
   controllers #0 and #32), prog is the program change message to send to 
   your synth, and pitch is the number of semitones to shift everything that 
   is played with that sound. Setting the bank change numbers to -1 will 
   prevent them from being sent.

   For example, the line:
<blockquote class="text"><pre>
      p36 = 0 34 9 12
</pre></blockquote>
   specifies that whenever GM program 36 (which happens to be a fretless 
   bass) is selected, Allegro should send a bank change message #0 with a 
   parameter of 0, a bank change message #32 with a parameter of 34, a 
   program change with a parameter of 9, and then should shift everything up 
   by an octave.
</ul><li>
[joystick]<br>
   Section containing joystick configuration information, using the
   variables:
<ul><li>
joytype = x<br>
   Specifies which joystick driver to use when the program requests 
   JOY_TYPE_AUTODETECT.
<li>
joystick_device = x<br>
   BeOS and Linux only: specifies the name of the joystick device to be used
   (as reported in the system joystick preferences under BeOS). The first
   device found is used by default. If you want to specify the device for
   each joystick, use variables of the form joystick_device_n, where n is
   the joystick number.
<li>
throttle_axis = x<br>
   Linux only: sets the axis number the throttle is located at. This
   variable will be used for every detected joystick. If you want to specify
   the axis number for each joystick individually, use variables of the form
   throttle_axis_n, where n is the joystick number.
</ul></ul>



<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#set_config_string" title="Writes a string in the configuration file.">set_config_string</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>.</blockquote>
<h1><a name="Mouse routines">Mouse routines</a></h1>

<p>
Allegro provides functions for reading the mouse state and displaying a mouse
cursor on-screen. You can read the absolute position of the mouse and the 
state of the mouse buttons from global variables. Additionally, you can read
the mouse position difference as mouse mickeys, which is the number of pixels
the cursor moved since the last time this information was read.

<p>
Allegro offers three ways to display the mouse cursor:
<ul><li>
Standard Allegro cursor<br>
   Allegro is responsible for drawing the mouse cursor from a timer. Use 
   set_mouse_sprite() and show_mouse() to define your own cursor and display 
   it on the screen.
   You need to call scare_mouse()/unscare_mouse() to hide the mouse cursor
   whenever you draw to the screen.
<li>
Custom operating system cursor (hardware cursor)<br>
   Allegro will let the operating system draw the mouse cursor. Use
   set_mouse_sprite() and show_mouse() (or show_os_cursor) to define your
   own cursor and display it on the screen. Not all graphics drivers are
   capable of this and some may only be able to display cursors up to a
   certain size. Allegro will fall back on its own cursor drawing if it
   cannot let the OS handle this. On some platforms, the hardware cursor
   is incompatible with get_mouse_mickeys() and it is therefor disabled by
   default. In such cases you need to call enable_hardware_cursor() to
   enable it explicitly.
<li>
Default operating system cursor<br>
   Allegro will not draw its own cursor, but use the operating system default
   cursor. You can use the select_mouse_cursor() function to select the cursor
   shape to display. As with custom operating system cursors, you need to call 
   enable_hardware_cursor() before you can use this. Or you can use the
   low level show_os_cursor() function.
</ul>
Not all drivers will support all functionality. See the platform specific
information for more details.

<p><br>
<div class="al-api"><b>int <a name="install_mouse">install_mouse</a>();</b></div><br>
   Installs the Allegro mouse handler. You must do this before using any 
   other mouse functions. 
<p><b>Return value:</b>
   Returns -1 on failure, zero if the mouse handler is already installed (in
   which case this function does nothing) and the number of buttons on the
   mouse if the mouse handler has successfully been installed (ie. this is
   the first time a handler is installed or you have removed the previous
   one).

<p>
   Note that the number of mouse buttons returned by this function is more
   an indication than a physical reality. With most devices there is no way
   of telling how many buttons there are, and any user can override the
   number of mouse buttons returned by this function with a custom
   configuration file and the variable num_buttons. Even if this value is
   overridden by the user, the global mouse variables will still report
   whatever the hardware is sending.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#remove_mouse" title="Removes the mouse handler.">remove_mouse</a>,
<a class="xref" href="#poll_mouse" title="Polls the mouse.">poll_mouse</a>,
<a class="xref" href="#mouse_x" title="Global variable with the mouse position/button state.">mouse_x</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#get_mouse_mickeys" title="How far the mouse has moved since the last call to this function.">get_mouse_mickeys</a>,
<a class="xref" href="#position_mouse" title="Moves the mouse to the specified screen position.">position_mouse</a>,
<a class="xref" href="#set_mouse_range" title="Sets the area of the screen restricting mouse movement.">set_mouse_range</a>,
<a class="xref" href="#set_mouse_speed" title="Sets the mouse speed.">set_mouse_speed</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="remove_mouse">remove_mouse</a>();</b></div><br>
   Removes the mouse handler. You don't normally need to bother calling 
   this, because allegro_exit() will do it for you.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>.</blockquote>
<div class="al-api"><b>int <a name="poll_mouse">poll_mouse</a>();</b></div><br>
   Wherever possible, Allegro will read the mouse input asynchronously (ie. 
   from inside an interrupt handler), but on some platforms that may not be 
   possible, in which case you must call this routine at regular intervals 
   to update the mouse state variables. To help you test your mouse polling 
   code even if you are programming on a platform that doesn't require it, 
   after the first time that you call this function Allegro will switch into 
   polling mode, so from that point onwards you will have to call this 
   routine in order to get any mouse input at all, regardless of whether the 
   current driver actually needs to be polled or not. 
<p><b>Return value:</b>
   Returns zero on success, or a negative number on failure (ie. no mouse 
   driver installed).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#mouse_needs_poll" title="Tells if the mouse driver requires polling.">mouse_needs_poll</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#mouse_x" title="Global variable with the mouse position/button state.">mouse_x</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exmouse" title="Getting input from the mouse.">exmouse</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>int <a name="mouse_needs_poll">mouse_needs_poll</a>();</b></div><br>
   Returns TRUE if the current mouse driver is operating in polling mode.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#poll_mouse" title="Polls the mouse.">poll_mouse</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#mouse_x" title="Global variable with the mouse position/button state.">mouse_x</a>.</blockquote>
<div class="al-api"><b>void <a name="enable_hardware_cursor">enable_hardware_cursor</a>(void);</b></div><br>
   After calling this function, Allegro will let the operating system draw the
   mouse cursor instead of doing it itself. This is not possible with all
   graphics drivers though: you'll need to check the gfx_capabilities flags
   after calling show_mouse() to see if this works. On some platforms, enabling
   the hardware cursor causes get_mouse_mickeys() to return only a limited
   range of values, so you should not call this function if you need mouse 
   mickeys.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#set_mouse_sprite" title="Sets the mouse sprite.">set_mouse_sprite</a>,
<a class="xref" href="#get_mouse_mickeys" title="How far the mouse has moved since the last call to this function.">get_mouse_mickeys</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#disable_hardware_cursor" title="Disables the OS hardware cursor.">disable_hardware_cursor</a>,
<a class="xref" href="#show_os_cursor" title="Low level function to display the operating system cursor.">show_os_cursor</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsyscur" title="">exsyscur</a>.</blockquote>
<div class="al-api"><b>void <a name="disable_hardware_cursor">disable_hardware_cursor</a>(void);</b></div><br>
   After calling this function, Allegro will be responsible for drawing the
   mouse cursor rather than the operating system. On some platforms calling
   enable_hardware_cursor() makes the return values of get_mouse_mickeys()
   unreliable. After calling this function, get_mouse_mickeys() returns 
   reliable results again.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#set_mouse_sprite" title="Sets the mouse sprite.">set_mouse_sprite</a>,
<a class="xref" href="#get_mouse_mickeys" title="How far the mouse has moved since the last call to this function.">get_mouse_mickeys</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#enable_hardware_cursor" title="Enables the OS hardware cursor.">enable_hardware_cursor</a>.</blockquote>
<div class="al-api"><b>void <a name="select_mouse_cursor">select_mouse_cursor</a>(int cursor);</b></div><br>
   This function allows you to use the operating system's native mouse
   cursors rather than some custom cursor. You will need to enable this
   functionality by calling enable_hardware_cursor() beforehand. If the
   operating system does not support this functionality, or if it has
   not been enabled, then Allegro will substitute its own cursor images.
   You can change these substitute images using set_mouse_cursor_bitmap().

<p>
   Note that the effects of this function are not apparent until show_mouse()
   is called.

<p>
   To know whether the operating system's native cursor is being used,
   or if Allegro has made a substitution, you can check the GFX_SYSTEM_CURSOR
   flag in gfx_capabilities after calling show_mouse().

<p>
   The cursor argument selects the type of cursor to be displayed:
   
<p>
   <b>MOUSE_CURSOR_NONE</b><br>
   Selects an invisible mouse cursor. In that sense, it is similar to calling
   show_mouse(NULL);
   
<p>
   <b>MOUSE_CURSOR_ALLEGRO</b><br>
   Selects the custom Allegro cursor, i.e. the one that you set with
   set_mouse_sprite().
   
<p>
   <b>MOUSE_CURSOR_ARROW</b><br>
   The operating system default arrow cursor.
   
<p>
   <b>MOUSE_CURSOR_BUSY</b><br>
   The operating system default <tt>`busy'</tt> cursor (hourglass).
   
<p>
   <b>MOUSE_CURSOR_QUESTION</b><br>
   The operating system default <tt>`question'</tt> cursor (arrow with question mark).
   
<p>
   <b>MOUSE_CURSOR_EDIT</b><br>
   The operating system default <tt>`edit'</tt> cursor (vertical bar).
   
<p>
   Example:
<blockquote class="code"><pre>
   /* initialize mouse sub-system */
   <a href="#install_mouse" class="autotype" title="Installs the Allegro mouse handler.">install_mouse</a>();
   <a href="#enable_hardware_cursor" class="autotype" title="Enables the OS hardware cursor.">enable_hardware_cursor</a>();
   
   /* Set busy pointer */
   <a href="#select_mouse_cursor" class="autotype" title="Tells Allegro to select software or hardware cursor drawing.">select_mouse_cursor</a>(MOUSE_CURSOR_BUSY);
   <a href="#show_mouse" class="autotype" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>);
   
   /* Initialize stuff */
   ...
   
   /* Set normal arrow pointer */
   <a href="#select_mouse_cursor" class="autotype" title="Tells Allegro to select software or hardware cursor drawing.">select_mouse_cursor</a>(MOUSE_CURSOR_ARROW);
</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#set_mouse_sprite" title="Sets the mouse sprite.">set_mouse_sprite</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#enable_hardware_cursor" title="Enables the OS hardware cursor.">enable_hardware_cursor</a>,
<a class="xref" href="#set_mouse_cursor_bitmap" title="Changes the image Allegro uses for mouse cursors.">set_mouse_cursor_bitmap</a>,
<a class="xref" href="#show_os_cursor" title="Low level function to display the operating system cursor.">show_os_cursor</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsyscur" title="">exsyscur</a>.</blockquote>
<div class="al-api"><b>void <a name="set_mouse_cursor_bitmap">set_mouse_cursor_bitmap</a>(int cursor, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   This function changes the cursor image Allegro uses if
   select_mouse_cursor() is called but no native operating system cursor
   can be used, e.g. because you did not call enable_hardware_cursor().

<p>
   The cursor argument can be one of:<br>
   <b>MOUSE_CURSOR_ALLEGRO</b><br>
   <b>MOUSE_CURSOR_ARROW</b><br>
   <b>MOUSE_CURSOR_BUSY</b><br>
   <b>MOUSE_CURSOR_QUESTION</b><br>
   <b>MOUSE_CURSOR_EDIT</b><br>

<p>
   but <i>not</i> MOUSE_CURSOR_NONE.

<p>
   The bmp argument can either point to a valid bitmap or it can be NULL.
   Passing a bitmap makes Allegro use that image in place of its own
   default substitution (should the operating system's native cursor
   be unavailable). The bitmap must remain available for the duration
   in which it could be used. Passing NULL lets Allegro revert to its
   default substitutions.

<p>
   The effect of this function will not be apparent until show_mouse() is
   called.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#set_mouse_sprite" title="Sets the mouse sprite.">set_mouse_sprite</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#enable_hardware_cursor" title="Enables the OS hardware cursor.">enable_hardware_cursor</a>,
<a class="xref" href="#show_os_cursor" title="Low level function to display the operating system cursor.">show_os_cursor</a>.</blockquote>
<div class="al-api"><b>extern volatile int <a name="mouse_x">mouse_x</a>;</b></div><br>
<div class="al-api-cont"><b>extern volatile int <a name="mouse_y">mouse_y</a>;</b></div><br>
<div class="al-api-cont"><b>extern volatile int <a name="mouse_z">mouse_z</a>;</b></div><br>
<div class="al-api-cont"><b>extern volatile int <a name="mouse_w">mouse_w</a>;</b></div><br>
<div class="al-api-cont"><b>extern volatile int <a name="mouse_b">mouse_b</a>;</b></div><br>
<div class="al-api-cont"><b>extern volatile int <a name="mouse_pos">mouse_pos</a>;</b></div><br>
   Global variables containing the current mouse position and button state. 
   Wherever possible these values will be updated asynchronously, but if 
   mouse_needs_poll() returns TRUE, you must manually call poll_mouse() to 
   update them with the current input state. The <tt>`mouse_x'</tt> and <tt>`mouse_y'</tt> 
   positions are integers ranging from zero to the bottom right corner of 
   the screen. The <tt>`mouse_z'</tt> and <tt>`mouse_w'</tt> variables hold the current vertical
   and horizontal wheel position, when using an input driver that supports
   wheel mice. The <tt>`mouse_b'</tt> variable is a bitfield indicating the state of
   each button: bit 0 is the left button,  bit 1 the right, and bit 2 the
   middle button. Additional non standard mouse buttons might be available
   as higher bits in this variable. Usage example:
<blockquote class="code"><pre>
      if (<a href="#mouse_b" class="autotype" title="Global variable with the mouse position/button state.">mouse_b</a> &amp; 1)
         printf("Left button is pressed\n");

      if (!(<a href="#mouse_b" class="autotype" title="Global variable with the mouse position/button state.">mouse_b</a> &amp; 2))
         printf("Right button is not pressed\n");
</pre></blockquote>
   The <tt>`mouse_pos'</tt> variable has the current X coordinate in the upper 16 bits
   and  the Y in the lower 16 bits. This may be useful in tight polling loops 
   where a mouse interrupt could occur between your reading of the two
   separate variables, since you can copy this value into a local variable
   with a single instruction and then split it up at your leisure. Example:
<blockquote class="code"><pre>
   int pos, x, y;
   
   pos = <a href="#mouse_pos" class="autotype" title="Global variable with the mouse position/button state.">mouse_pos</a>;
   x = pos >> 16;
   y = pos &amp; 0x0000ffff;
</pre></blockquote>



<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#poll_mouse" title="Polls the mouse.">poll_mouse</a>,
<a class="xref" href="#mouse_needs_poll" title="Tells if the mouse driver requires polling.">mouse_needs_poll</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exmouse" title="Getting input from the mouse.">exmouse</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>extern <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="mouse_sprite">mouse_sprite</a>;</b></div><br>
<div class="al-api-cont"><b>extern int <a name="mouse_x_focus">mouse_x_focus</a>;</b></div><br>
<div class="al-api-cont"><b>extern int <a name="mouse_y_focus">mouse_y_focus</a>;</b></div><br>
   Global variables containing the current mouse sprite and the focus
   point.  These are read-only, and only to be modified using the
   set_mouse_sprite() and set_mouse_sprite_focus() functions.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_mouse_sprite" title="Sets the mouse sprite.">set_mouse_sprite</a>,
<a class="xref" href="#set_mouse_sprite_focus" title="Sets the mouse sprite focus.">set_mouse_sprite_focus</a>.</blockquote>
<div class="al-api"><b>void <a name="show_mouse">show_mouse</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Tells Allegro to display a mouse pointer on the screen. This will only 
   work if the timer module has been installed. The mouse pointer will be 
   drawn onto the specified bitmap, which should normally be <tt>`screen'</tt> (see 
   later for information about bitmaps). To hide the mouse pointer, call 
   show_mouse(NULL). 
   
<p>
   Warning: if you draw anything onto the screen while the pointer is 
   visible, a mouse movement interrupt could occur in the middle of your 
   drawing operation. If this happens the mouse buffering and graphics drawing
   code will get confused and will leave 'mouse droppings' all over the 
   screen. To prevent this, you must make sure you turn off the mouse 
   pointer whenever you draw onto the screen. This is not needed if you are
   using a hardware cursor.

<p>
   Note: you must not be showing a mouse pointer on a bitmap at the time that
   the bitmap is destroyed with destroy_bitmap(), e.g. call show_mouse(NULL);
   before destroying the bitmap. This does not apply to <tt>`screen'</tt> since you
   never destroy <tt>`screen'</tt> with destroy_bitmap().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#set_mouse_sprite" title="Sets the mouse sprite.">set_mouse_sprite</a>,
<a class="xref" href="#scare_mouse" title="Helper for hiding the mouse pointer before drawing.">scare_mouse</a>,
<a class="xref" href="#freeze_mouse_flag" title="Flag to avoid redrawing the mouse pointer.">freeze_mouse_flag</a>,
<a class="xref" href="#show_os_cursor" title="Low level function to display the operating system cursor.">show_os_cursor</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmouse" title="Getting input from the mouse.">exmouse</a>,
<a class="eref" href="#expal" title="Palette effects and color cycling.">expal</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#exsyscur" title="">exsyscur</a>.</blockquote>
<div class="al-api"><b>void <a name="scare_mouse">scare_mouse</a>();</b></div><br>
   Helper for hiding the mouse pointer prior to a drawing operation. This 
   will temporarily get rid of the pointer, but only if that is really 
   required (ie. the mouse is visible, and is displayed on the physical 
   screen rather than some other memory surface, and it is not a hardware 
   or OS cursor). The previous mouse state is stored for subsequent calls to 
   unscare_mouse().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#unscare_mouse" title="Undoes the effect of scare_mouse() or scare_mouse_area().">unscare_mouse</a>,
<a class="xref" href="#scare_mouse_area" title="Helper for hiding the mouse cursor before drawing in an area.">scare_mouse_area</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>.</blockquote>
<div class="al-api"><b>void <a name="scare_mouse_area">scare_mouse_area</a>(int x, int y, int w, int h);</b></div><br>
   Like scare_mouse(), but will only hide the cursor if it is inside the 
   specified rectangle. Otherwise the cursor will simply be frozen in place 
   until you call unscare_mouse(), so it cannot interfere with your drawing.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#unscare_mouse" title="Undoes the effect of scare_mouse() or scare_mouse_area().">unscare_mouse</a>,
<a class="xref" href="#scare_mouse" title="Helper for hiding the mouse pointer before drawing.">scare_mouse</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>.</blockquote>
<div class="al-api"><b>void <a name="unscare_mouse">unscare_mouse</a>();</b></div><br>
   Undoes the effect of a previous call to scare_mouse() or 
   scare_mouse_area(), restoring the original pointer state.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#scare_mouse" title="Helper for hiding the mouse pointer before drawing.">scare_mouse</a>,
<a class="xref" href="#scare_mouse_area" title="Helper for hiding the mouse cursor before drawing in an area.">scare_mouse_area</a>.</blockquote>
<div class="al-api"><b>int <a name="show_os_cursor">show_os_cursor</a>(int cursor);</b></div><br>
   In case you do not need Allegro's mouse cursor API, which automatically
   emulates a cursor in software if no other cursor is available, you can
   use this low level function to try to display or hide the system cursor
   directly. The cursor parameter takes the same values as
   select_mouse_cursor. This function is very similar to calling
   enable_hardware_cursor, select_mouse_cursor and show_mouse, but will
   not try to do anything if no system cursor is available.

<p>
   The most common use for this function is to just call it once at the
   beginning of the program to tell it to display the system cursor inside
   the Allegro window. The return value can be used to see if this
   succeeded or not. On some systems (e.g. DirectX fullscreen) this is not
   supported and the function will always fail, and in other cases only
   some of the cursors will work, or in the case of MOUSE_CURSOR_ALLEGRO,
   only certain bitmap sizes may be supported.

<p>
   You never should use show_os_cursor together with the function
   show_mouse and other functions affecting it (select_mouse_cursor,
   enable_hardware_cursor, disable_hardware_cursor, scare_mouse,
   unscare_mouse). They implement the standard high level mouse API, and
   don't work together with this low level function.
<p><b>Return value:</b>
   Returns 0 if a system cursor is being displayed after the function
   returns, or -1 otherwise.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#set_mouse_cursor_bitmap" title="Changes the image Allegro uses for mouse cursors.">set_mouse_cursor_bitmap</a>,
<a class="xref" href="#select_mouse_cursor" title="Tells Allegro to select software or hardware cursor drawing.">select_mouse_cursor</a>.</blockquote>
<div class="al-api"><b>extern volatile int <a name="freeze_mouse_flag">freeze_mouse_flag</a>;</b></div><br>
   If this flag is set, the mouse pointer won't be redrawn when the mouse 
   moves. This can avoid the need to hide the pointer every time you draw to 
   the screen, as long as you make sure your drawing doesn't overlap with 
   the current pointer position.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>.</blockquote>
<div class="al-api"><b>void <a name="position_mouse">position_mouse</a>(int x, int y);</b></div><br>
   Moves the mouse to the specified screen position. It is safe to call even 
   when a mouse pointer is being displayed.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#position_mouse_z" title="Sets the mouse wheel position global variable.">position_mouse_z</a>,
<a class="xref" href="#set_mouse_range" title="Sets the area of the screen restricting mouse movement.">set_mouse_range</a>,
<a class="xref" href="#set_mouse_speed" title="Sets the mouse speed.">set_mouse_speed</a>,
<a class="xref" href="#position_mouse_w" title="Sets the horizontal mouse wheel position.">position_mouse_w</a>.</blockquote>
<div class="al-api"><b>void <a name="position_mouse_z">position_mouse_z</a>(int z);</b></div><br>
   Sets the mouse wheel position variable to the specified value.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#position_mouse" title="Moves the mouse to the specified screen position.">position_mouse</a>,
<a class="xref" href="#position_mouse_w" title="Sets the horizontal mouse wheel position.">position_mouse_w</a>.</blockquote>
<div class="al-api"><b>void <a name="position_mouse_w">position_mouse_w</a>(int w);</b></div><br>
   Sets the horizontal mouse wheel position to the specified value.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#position_mouse" title="Moves the mouse to the specified screen position.">position_mouse</a>.</blockquote>
<div class="al-api"><b>void <a name="set_mouse_range">set_mouse_range</a>(int x1, int y1, int x2, int y2);</b></div><br>
   Sets the area of the screen within which the mouse can move. Pass the top 
   left corner and the bottom right corner (inclusive). If you don't call 
   this function the range defaults to (0, 0, SCREEN_W-1, SCREEN_H-1).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#set_mouse_speed" title="Sets the mouse speed.">set_mouse_speed</a>,
<a class="xref" href="#position_mouse" title="Moves the mouse to the specified screen position.">position_mouse</a>.</blockquote>
<div class="al-api"><b>void <a name="set_mouse_speed">set_mouse_speed</a>(int xspeed, int yspeed);</b></div><br>
   Sets the mouse speed. Larger values of xspeed and yspeed represent slower 
   mouse movement: the default for both is 2.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#set_mouse_range" title="Sets the area of the screen restricting mouse movement.">set_mouse_range</a>,
<a class="xref" href="#position_mouse" title="Moves the mouse to the specified screen position.">position_mouse</a>.</blockquote>
<div class="al-api"><b>void <a name="set_mouse_sprite">set_mouse_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite);</b></div><br>
   You don't like Allegro's mouse pointer? No problem. Use this function to
   supply an alternative of your own. If you change the pointer and then want
   to get Allegro's lovely arrow back again, call set_mouse_sprite(NULL).

<p>
   As a bonus, set_mouse_sprite(NULL) uses the current palette in choosing
   colors for the arrow. So if your arrow mouse sprite looks ugly after
   changing the palette, call set_mouse_sprite(NULL).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#set_mouse_sprite_focus" title="Sets the mouse sprite focus.">set_mouse_sprite_focus</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmouse" title="Getting input from the mouse.">exmouse</a>.</blockquote>
<div class="al-api"><b>void <a name="set_mouse_sprite_focus">set_mouse_sprite_focus</a>(int x, int y);</b></div><br>
   The mouse focus is the bit of the pointer that represents the actual 
   mouse position, ie. the (mouse_x, mouse_y) position. By default this is 
   the top left corner of the arrow, but if you are using a different mouse 
   pointer you might need to alter it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_mouse_sprite" title="Sets the mouse sprite.">set_mouse_sprite</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmouse" title="Getting input from the mouse.">exmouse</a>.</blockquote>
<div class="al-api"><b>void <a name="get_mouse_mickeys">get_mouse_mickeys</a>(int *mickeyx, int *mickeyy);</b></div><br>
   Measures how far the mouse has moved since the last call to this 
   function. The values of mickeyx and mickeyy will become negative if the 
   mouse is moved left or up, respectively. The mouse will continue to 
   generate movement mickeys even when it reaches the edge of the screen, so 
   this form of input can be useful for games that require an infinite range 
   of mouse movement.

<p>
   Note that the infinite movement may not work in windowed mode, since under 
   some platforms the mouse would leave the window, and may not work at all 
   if the hardware cursor is in use.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmouse" title="Getting input from the mouse.">exmouse</a>.</blockquote>
<div class="al-api"><b>extern void (*<a name="mouse_callback">mouse_callback</a>)(int flags);</b></div><br>
   Called by the interrupt handler whenever the mouse moves or one of the 
   buttons changes state. This function must be in locked memory, and must 
   execute _very_ quickly! It is passed the event flags that triggered the 
   call, which is a bitmask containing any of the values MOUSE_FLAG_MOVE, 
   MOUSE_FLAG_LEFT_DOWN, MOUSE_FLAG_LEFT_UP, MOUSE_FLAG_RIGHT_DOWN, 
   MOUSE_FLAG_RIGHT_UP, MOUSE_FLAG_MIDDLE_DOWN, MOUSE_FLAG_MIDDLE_UP, and 
   MOUSE_FLAG_MOVE_Z. Note that even if the mouse has more than three buttons,
   only the first three can be trapped using a callback.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>.</blockquote>
<h1><a name="Timer routines">Timer routines</a></h1>

<p>
Allegro can set up several virtual timer functions, all going at different
speeds.

<p>
Under DOS it will constantly reprogram the clock to make sure they are all
called at the correct times. Because they alter the low level timer chip
settings, these routines should not be used together with other DOS timer
functions like the DJGPP uclock() routine. Moreover, the FPU state is not
preserved across Allegro interrupts so you ought not to use floating point
or MMX code inside timer interrupt handlers.

<p>
Under other platforms, they are usually implemented using threads, which run
parallel to the main thread. Therefore timer callbacks on such platforms
will not block the main thread when called, so you may need to use
appropriate synchronisation devices (eg. mutexes, semaphores, etc.) when
accessing data that is shared by a callback and the main thread. (Currently
Allegro does not provide such devices.)

<p><br>
<div class="al-api"><b>int <a name="install_timer">install_timer</a>();</b></div><br>
   Installs the Allegro timer interrupt handler. You must do this before 
   installing any user timer routines, and also before displaying a mouse 
   pointer, playing FLI animations or MIDI music, and using any of the GUI 
   routines.
<p><b>Return value:</b>
   Returns zero on success, or a negative number on failure (but you may
   decide not to check the return value as this function is very unlikely to
   fail).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#remove_timer" title="Removes the Allegro time handler.">remove_timer</a>,
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="remove_timer">remove_timer</a>();</b></div><br>
   Removes the Allegro timer handler (and, under DOS, passes control of the
   clock back to the operating system). You don't normally need to bother
   calling this, because allegro_exit() will do it for you.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>.</blockquote>
<div class="al-api"><b>int <a name="install_int">install_int</a>(void (*proc)(), int speed);</b></div><br>
   Installs a user timer handler, with the speed given as the number of 
   milliseconds between ticks. This is the same thing as 
   install_int_ex(proc, MSEC_TO_TIMER(speed)). If you call this routine 
   without having first installed the timer module, install_timer() will be 
   called automatically. Calling again this routine with the same timer
   handler as parameter allows you to adjust its speed.
<p><b>Return value:</b>
   Returns zero on success, or a negative number if there is no room to add
   a new user timer.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#remove_int" title="Removes a timers.">remove_int</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>,
<a class="xref" href="#install_param_int" title="Installs a timer routine with a customizable parameter.">install_param_int</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="#extimer" title="Using the timer (delays and interrupts).">extimer</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>int <a name="install_int_ex">install_int_ex</a>(void (*proc)(), int speed);</b></div><br>
   Adds a function to the list of user timer handlers or, if it is already 
   installed, retroactively adjusts its speed (i.e makes as though the speed
   change occurred precisely at the last tick). The speed is given in hardware
   clock ticks, of which there are 1193181 a second. You can convert from 
   other time formats to hardware clock ticks with the macros:
<blockquote class="text"><pre>
      SECS_TO_TIMER(secs)  - give the number of seconds between
                             each tick
      MSEC_TO_TIMER(msec)  - give the number of milliseconds
                             between ticks
      BPS_TO_TIMER(bps)    - give the number of ticks each second
      BPM_TO_TIMER(bpm)    - give the number of ticks per minute
</pre></blockquote>
   There can only be sixteen timers in use at a time, and some other parts of
   Allegro (the GUI code, the mouse pointer display routines, rest(), the FLI
   player, and the MIDI player) need to install handlers of their own, so you
   should avoid using too many at the same time. If you call this routine
   without having first installed the timer module, install_timer() will be
   called automatically.

<p>
   Your function will be called by the Allegro interrupt handler and not 
   directly by the processor, so it can be a normal C function and does not 
   need a special wrapper. You should be aware, however, that it will be 
   called in an interrupt context, which imposes a lot of restrictions on 
   what you can do in it. It should not use large amounts of stack, it must 
   not make any calls to the operating system, use C library functions, or 
   contain any floating point code, and it must execute very quickly. Don't 
   try to do lots of complicated code in a timer handler: as a general rule 
   you should just set some flags and respond to these later in your main 
   control loop.

<p>
   In a DOS protected mode environment like DJGPP, memory is virtualised and 
   can be swapped to disk. Due to the non-reentrancy of DOS, if a disk swap 
   occurs inside an interrupt handler the system will die a painful death, 
   so you need to make sure you lock all the memory (both code and data) 
   that is touched inside timer routines. Allegro will lock everything it 
   uses, but you are responsible for locking your handler functions. The 
   macros LOCK_VARIABLE (variable), END_OF_FUNCTION (function_name),
   END_OF_STATIC_FUNCTION (function_name), and LOCK_FUNCTION (function_name)
   can be used to simplify this task. For example, if you want an interrupt 
   handler that increments a counter variable, you should write:
<blockquote class="code"><pre>
      volatile int counter;

      void my_timer_handler()
      {
         counter++;
      }

      <a href="#END_OF_FUNCTION" class="autotype" title="Locks the code used by a timer.">END_OF_FUNCTION</a>(my_timer_handler)
</pre></blockquote>
   and in your initialisation code you should lock the memory:
<blockquote class="code"><pre>
      <a href="#LOCK_VARIABLE" class="autotype" title="Locks the memory of a variable used by a timer.">LOCK_VARIABLE</a>(counter);
      <a href="#LOCK_FUNCTION" class="autotype" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>(my_timer_handler);
</pre></blockquote>
   Obviously this can get awkward if you use complicated data structures and 
   call other functions from within your handler, so you should try to keep 
   your interrupt routines as simple as possible.
<p><b>Return value:</b>
   Returns zero on success, or a negative number if there is no room to add
   a new user timer.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#remove_int" title="Removes a timers.">remove_int</a>,
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>,
<a class="xref" href="#install_param_int_ex" title="Adds or modifies a timer with a customizable parameter.">install_param_int_ex</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#extimer" title="Using the timer (delays and interrupts).">extimer</a>,
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>Macro <a name="LOCK_VARIABLE">LOCK_VARIABLE</a>(variable_name);</b></div><br>
   Due to interrupts, you are required to lock all the memory used by your
   timer routines. See the description of install_int_ex() for a more
   detailed explanation and usage example.
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="#extimer" title="Using the timer (delays and interrupts).">extimer</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>Macro <a name="LOCK_FUNCTION">LOCK_FUNCTION</a>(function_name);</b></div><br>
   Due to interrupts, you are required to lock all the memory used by your
   timer routines. See the description of install_int_ex() for a more
   detailed explanation and usage example.
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exkeys" title="How to get input from the keyboard in different ways.">exkeys</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="#extimer" title="Using the timer (delays and interrupts).">extimer</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>Macro <a name="END_OF_FUNCTION">END_OF_FUNCTION</a>(function_name);</b></div><br>
   Due to interrupts, you are required to lock all the code used by your
   timer routines. See the description of install_int_ex() for a more
   detailed explanation and usage example.
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exkeys" title="How to get input from the keyboard in different ways.">exkeys</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="#extimer" title="Using the timer (delays and interrupts).">extimer</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>void <a name="remove_int">remove_int</a>(void (*proc)());</b></div><br>
   Removes a function from the list of user interrupt routines. At program 
   termination, allegro_exit() does this automatically.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>,
<a class="xref" href="#remove_param_int" title="Removes a timer with a customizable parameter.">remove_param_int</a>.</blockquote>
<div class="al-api"><b>int <a name="install_param_int">install_param_int</a>(void (*proc)(void *), void *param, int speed);</b></div><br>
   Like install_int(), but the callback routine will be passed a copy of the 
   specified void pointer parameter. To disable the handler, use 
   remove_param_int() instead of remove_int().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#remove_param_int" title="Removes a timer with a customizable parameter.">remove_param_int</a>,
<a class="xref" href="#install_param_int_ex" title="Adds or modifies a timer with a customizable parameter.">install_param_int_ex</a>,
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>.</blockquote>
<div class="al-api"><b>int <a name="install_param_int_ex">install_param_int_ex</a>(void (*proc)(void *), void *param, int speed);</b></div><br>
   Like install_int_ex(), but the callback routine will be passed a copy of 
   the specified void pointer parameter. To disable the handler, use 
   remove_param_int() instead of remove_int().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#remove_param_int" title="Removes a timer with a customizable parameter.">remove_param_int</a>,
<a class="xref" href="#install_param_int" title="Installs a timer routine with a customizable parameter.">install_param_int</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>.</blockquote>
<div class="al-api"><b>void <a name="remove_param_int">remove_param_int</a>(void (*proc)(void *), void *param);</b></div><br>
   Like remove_int(), but for use with timer callbacks that have parameter 
   values. If there is more than one copy of the same callback active at a 
   time, it identifies which one to remove by checking the parameter value 
   (so you can't have more than one copy of a handler using an identical 
   parameter).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_param_int" title="Installs a timer routine with a customizable parameter.">install_param_int</a>,
<a class="xref" href="#install_param_int_ex" title="Adds or modifies a timer with a customizable parameter.">install_param_int_ex</a>,
<a class="xref" href="#remove_int" title="Removes a timers.">remove_int</a>.</blockquote>
<div class="al-api"><b>extern volatile int <a name="retrace_count">retrace_count</a>;</b></div><br>
   If the retrace simulator is installed, this count is incremented on each
   vertical retrace; otherwise, if the refresh rate is known, the count is
   incremented at the same rate (ignoring retraces); otherwise, it is
   incremented 70 times a second. This provides a way of controlling
   the speed of your program without installing user timer functions.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>,
<a class="eref" href="#exdbuf" title="How to use double buffering to avoid flicker.">exdbuf</a>,
<a class="eref" href="#exflip" title="Comparison of double buffering and page flipping.">exflip</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>.</blockquote>
<div class="al-api"><b>void <a name="rest">rest</a>(unsigned int time);</b></div><br>
   This function waits for the specified number of milliseconds.

<p>
   Passing 0 as parameter will not wait, but just yield. This can be useful
   in order to "play nice" with other processes. Other values will cause
   CPU time to be dropped on most platforms. This will look better to
   users, and also does things like saving battery power and making fans
   less noisy.

<p>
   Note that calling this inside your active game loop is a bad idea, as
   you never know when the OS will give you the CPU back, so you could end
   up missing the vertical retrace and skipping frames. On the other hand,
   on multitasking operating systems it is good form to give up the CPU for
   a while if you will not be using it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#rest_callback" title="Like rest(), but calls the callback during the wait.">rest_callback</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>,
<a class="xref" href="#d_yield_proc" title="Invisible dialog procedure that yields CPU time slices.">d_yield_proc</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exkeys" title="How to get input from the keyboard in different ways.">exkeys</a>,
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>,
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>,
<a class="eref" href="#exsample" title="Playing digital samples.">exsample</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#extimer" title="Using the timer (delays and interrupts).">extimer</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>,
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>void <a name="rest_callback">rest_callback</a>(long time, void (*callback)())</b></div><br>
   Like rest(), but for non-zero values continually calls the specified
   function while it is waiting for the required time to elapse. If the
   provided <tt>`callback'</tt> parameter is NULL, this function does exactly the
   same thing as calling rest().




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#rest" title="Waits a specified number of milliseconds or yields CPU.">rest</a>.</blockquote>
<h1><a name="Keyboard routines">Keyboard routines</a></h1>

<p>
The Allegro keyboard handler provides both buffered input and a set of flags 
storing the current state of each key. Note that it is not possible to 
correctly detect every combination of keys, due to the design of the PC 
keyboard. Up to two or three keys at a time will work fine, but if you press 
more than that the extras are likely to be ignored (exactly which 
combinations are possible seems to vary from one keyboard to another).

<p>
On DOS, Allegro requires the user to specify the language of the keyboard
mapping because it is impossible to obtain this information from the OS,
otherwise the default US keyboard mapping will be used. Allegro comes with a
prepackaged <tt>`keyboard.dat'</tt> file which you can put along with your binary. If
this file is present, Allegro will be able to extract the keyboard mapping
information stored there. However, the end user still needs to select which
keyboard mapping to use. This can be accomplished through the keyboard variable
of the system section in a standard <tt>`allegro.cfg'</tt> configuration file. Read
chapter "Configuration routines" for more information about this.

<p><br>
<div class="al-api"><b>int <a name="install_keyboard">install_keyboard</a>();</b></div><br>
   Installs the Allegro keyboard interrupt handler. You must call this 
   before using any of the keyboard input routines. Once you have set up the 
   Allegro handler, you can no longer use operating system calls or C 
   library functions to access the keyboard.

<p>
   Note that on some platforms the keyboard won't work unless you have set a
   graphics mode, even if this function returns a success value before
   calling set_gfx_mode. This can happen in environments with graphic
   windowed modes, since Allegro usually reads the keyboard through the
   graphical window (which appears after the set_gfx_mode call). Example:
<blockquote class="code"><pre>
      <a href="#allegro_init" class="autotype" title="Macro to initialise the Allegro library.">allegro_init</a>();
      <a href="#install_timer" class="autotype" title="Installs the Allegro timer interrupt handler.">install_timer</a>();
      <a href="#install_keyboard" class="autotype" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>();
      /* We are not 100% sure we can read the keyboard yet! */
      if (<a href="#set_gfx_mode" class="autotype" title="Sets a graphic video mode.">set_gfx_mode</a>(GFX_AUTODETECT, 640, 480, 0, 0) != 0)
         abort_on_error("Couldn't set graphic mode!");

      /* Now we are guaranteed to be able to read the keyboard. */
      <a href="#readkey" class="autotype" title="Returns the next character from the keyboard buffer.">readkey</a>();</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success, or a negative number on failure (but you may
   decide not to check the return value as this function is very unlikely to
   fail).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#remove_keyboard" title="Removes the Allegro keyboard handler.">remove_keyboard</a>,
<a class="xref" href="#poll_keyboard" title="Polls the keyboard.">poll_keyboard</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#ureadkey" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>,
<a class="xref" href="#keyboard_callback" title="User specified keyboard callback handler.">keyboard_callback</a>,
<a class="xref" href="#keyboard_ucallback" title="User specified unicode keyboard callback handler.">keyboard_ucallback</a>,
<a class="xref" href="#keyboard_lowlevel_callback" title="User specified low level keyboard event handler.">keyboard_lowlevel_callback</a>,
<a class="xref" href="#three_finger_flag" title="Flag to deactivate the emergency exit key combination.">three_finger_flag</a>,
<a class="xref" href="#key_led_flag" title="Flag to prevent the keyboard LEDs from being updated.">key_led_flag</a>,
<a class="xref" href="#set_leds" title="Sets the state of the keyboard LED indicators.">set_leds</a>,
<a class="xref" href="#set_keyboard_rate" title="Sets the keyboard repeat rate.">set_keyboard_rate</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="remove_keyboard">remove_keyboard</a>();</b></div><br>
   Removes the keyboard handler, returning control to the operating system. 
   You don't normally need to bother calling this, because allegro_exit() 
   will do it for you. However, you might want to call this during runtime if
   you want to change the keyboard mapping on those platforms were keyboard
   mappings are needed. You would first modify the configuration variable
   holding the keyboard mapping and then reinstall the keyboard handler.
   Example:
<blockquote class="code"><pre>
      <a href="#remove_keyboard" class="autotype" title="Removes the Allegro keyboard handler.">remove_keyboard</a>();
      /* Switch to Spanish keyboard mapping. */
      <a href="#set_config_string" class="autotype" title="Writes a string in the configuration file.">set_config_string</a>("system", "keyboard", "es");
      <a href="#install_keyboard" class="autotype" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>();</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>,
<a class="xref" href="#set_config_string" title="Writes a string in the configuration file.">set_config_string</a>.</blockquote>
<div class="al-api"><b>void <a name="install_keyboard_hooks">install_keyboard_hooks</a>(int (*keypressed)(), int (*readkey)());</b></div><br>
   You should only use this function if you *aren't* using the rest of the 
   keyboard handler. It should be called in the place of install_keyboard(), 
   and lets you provide callback routines to detect and read keypresses, 
   which will be used by the main keypressed() and readkey() functions. This 
   can be useful if you want to use Allegro's GUI code with a custom 
   keyboard handler, as it provides a way for the GUI to get keyboard input 
   from your own code, bypassing the normal Allegro input system.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>.</blockquote>
<div class="al-api"><b>int <a name="poll_keyboard">poll_keyboard</a>();</b></div><br>
   Wherever possible, Allegro will read the keyboard input asynchronously 
   (ie. from inside an interrupt handler), but on some platforms that may 
   not be possible, in which case you must call this routine at regular 
   intervals to update the keyboard state variables.

<p>
   To help you test your keyboard polling code even if you are programming
   on a platform that doesn't require it, after the first time that you
   call this function Allegro will switch into polling mode, so from that
   point onwards you will have to call this routine in order to get any
   keyboard input at all, regardless of whether the current driver actually
   needs to be polled or not.

<p>
   The keypressed(), readkey(), and ureadkey() functions call poll_keyboard()
   automatically, so you only need to use this function when accessing the
   key[] array and key_shifts variable.
<p><b>Return value:</b>
   Returns zero on success, or a negative number on failure (ie. no keyboard
   driver installed).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#keyboard_needs_poll" title="Tells if the keyboard needs polling.">keyboard_needs_poll</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#key_shifts" title="Bitmask containing the current state of modifier keys.">key_shifts</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>,
<a class="eref" href="#exsample" title="Playing digital samples.">exsample</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b>int <a name="keyboard_needs_poll">keyboard_needs_poll</a>();</b></div><br>
   Returns TRUE if the current keyboard driver is operating in polling mode.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#poll_keyboard" title="Polls the keyboard.">poll_keyboard</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>.</blockquote>
<div class="al-api"><b>extern volatile char <a name="key">key</a>[KEY_MAX];</b></div><br>
   Array of flags indicating the state of each key, ordered by scancode. 
   Wherever possible these values will be updated asynchronously, but if 
   keyboard_needs_poll() returns TRUE, you must manually call 
   poll_keyboard() to update them with the current input state. The 
   scancodes are defined in allegro/keyboard.h as a series of KEY_*
   constants (and are also listed below). For example, you could write:
<blockquote class="code"><pre>
      if (<a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>[KEY_SPACE])
         printf("Space is pressed\n");</pre></blockquote>

<p>
   Note that the array is supposed to represent which keys are physically
   held down and which keys are not, so it is semantically read-only.

<p>
   These are the keyboard scancodes:
<blockquote class="text"><pre>
      KEY_A ... KEY_Z,
      KEY_0 ... KEY_9,
      KEY_0_PAD ... KEY_9_PAD,
      KEY_F1 ... KEY_F12,

      KEY_ESC, KEY_TILDE, KEY_MINUS, KEY_EQUALS,
      KEY_BACKSPACE, KEY_TAB, KEY_OPENBRACE, KEY_CLOSEBRACE,
      KEY_ENTER, KEY_COLON, KEY_QUOTE, KEY_BACKSLASH,
      KEY_BACKSLASH2, KEY_COMMA, KEY_STOP, KEY_SLASH,
      KEY_SPACE,

      KEY_INSERT, KEY_DEL, KEY_HOME, KEY_END, KEY_PGUP,
      KEY_PGDN, KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN,

      KEY_SLASH_PAD, KEY_ASTERISK, KEY_MINUS_PAD,
      KEY_PLUS_PAD, KEY_DEL_PAD, KEY_ENTER_PAD,

      KEY_PRTSCR, KEY_PAUSE,

      KEY_ABNT_C1, KEY_YEN, KEY_KANA, KEY_CONVERT, KEY_NOCONVERT,
      KEY_AT, KEY_CIRCUMFLEX, KEY_COLON2, KEY_KANJI,

      KEY_LSHIFT, KEY_RSHIFT,
      KEY_LCONTROL, KEY_RCONTROL,
      KEY_ALT, KEY_ALTGR,
      KEY_LWIN, KEY_RWIN, KEY_MENU,
      KEY_SCRLOCK, KEY_NUMLOCK, KEY_CAPSLOCK

      KEY_EQUALS_PAD, KEY_BACKQUOTE, KEY_SEMICOLON, KEY_COMMAND</pre></blockquote>

<p>
   Finally, you may notice an <tt>`odd'</tt> behaviour of the KEY_PAUSE key. This key
   only generates an interrupt when it is pressed, not when it is released.
   For this reason, Allegro pretends the pause key is a <tt>`state'</tt> key, which
   is the only way to make it usable.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#poll_keyboard" title="Polls the keyboard.">poll_keyboard</a>,
<a class="xref" href="#key_shifts" title="Bitmask containing the current state of modifier keys.">key_shifts</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>extern volatile int <a name="key_shifts">key_shifts</a>;</b></div><br>
   Bitmask containing the current state of shift/ctrl/alt, the special 
   Windows keys, and the accent escape characters. Wherever possible this 
   value will be updated asynchronously, but if keyboard_needs_poll() 
   returns TRUE, you must manually call poll_keyboard() to update it with 
   the current input state. This can contain any of the flags:
<blockquote class="text"><pre>
      KB_SHIFT_FLAG
      KB_CTRL_FLAG
      KB_ALT_FLAG
      KB_LWIN_FLAG
      KB_RWIN_FLAG
      KB_MENU_FLAG
      KB_COMMAND_FLAG
      KB_SCROLOCK_FLAG
      KB_NUMLOCK_FLAG
      KB_CAPSLOCK_FLAG
      KB_INALTSEQ_FLAG
      KB_ACCENT1_FLAG
      KB_ACCENT2_FLAG
      KB_ACCENT3_FLAG
      KB_ACCENT4_FLAG</pre></blockquote>

<p>
   Example:
<blockquote class="code"><pre>
      if (<a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>[KEY_W]) {
         if (<a href="#key_shifts" class="autotype" title="Bitmask containing the current state of modifier keys.">key_shifts</a> &amp; KB_SHIFT_FLAG) {
            /* User is pressing shift + W. */
         } else {
            /* Hmmm... lower case W then. */
         }
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#poll_keyboard" title="Polls the keyboard.">poll_keyboard</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>,
<a class="eref" href="#exkeys" title="How to get input from the keyboard in different ways.">exkeys</a>.</blockquote>
<div class="al-api"><b>int <a name="keypressed">keypressed</a>();</b></div><br>
   Returns TRUE if there are keypresses waiting in the input buffer. You can
   use this to see if the next call to readkey() is going to block or to 
   simply wait for the user to press a key while you still update the screen
   possibly drawing some animation. Example:
<blockquote class="code"><pre>
      while (!<a href="#keypressed" class="autotype" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>()) {
         /* Show cool animated logo. */
      }
      /* So he skipped our title <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>. */</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#ureadkey" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#simulate_keypress" title="Stuffs a key into the keyboard buffer.">simulate_keypress</a>,
<a class="xref" href="#simulate_ukeypress" title="Stuffs an unicode key into the keyboard buffer.">simulate_ukeypress</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>int <a name="readkey">readkey</a>();</b></div><br>
   Returns the next character from the keyboard buffer, in ASCII format. If 
   the buffer is empty, it waits until a key is pressed. You can see if there
   are queued keypresses with keypressed().

<p>
   The low byte of the return value contains the ASCII code of the key, and
   the high byte the scancode. The scancode remains the same whatever the
   state of the shift, ctrl and alt keys, while the ASCII code is affected by
   shift and ctrl in the normal way (shift changes case, ctrl+letter gives
   the position of that letter in the alphabet, eg. ctrl+A = 1, ctrl+B = 2,
   etc). Pressing alt+key returns only the scancode, with a zero ASCII code
   in the low byte. For example:
<blockquote class="code"><pre>
      int val;
      ...
      val = <a href="#readkey" class="autotype" title="Returns the next character from the keyboard buffer.">readkey</a>();
      if ((val &amp; 0xff) == 'd')     /* by ASCII code */
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("You pressed 'd'\n");

      if ((val &gt;&gt; 8) == KEY_SPACE) /* by scancode */
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("You pressed Space\n");

      if ((val &amp; 0xff) == 3)       /* ctrl+letter */
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("You pressed Control+C\n");

      if (val == (KEY_X &lt;&lt; 8))     /* alt+letter */
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("You pressed Alt+X\n");
</pre></blockquote>
   This function cannot return character values greater than 255. If you 
   need to read Unicode input, use ureadkey() instead.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#ureadkey" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#simulate_keypress" title="Stuffs a key into the keyboard buffer.">simulate_keypress</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>int <a name="ureadkey">ureadkey</a>(int *scancode);</b></div><br>
   Returns the next character from the keyboard buffer, in Unicode format. 
   If the buffer is empty, it waits until a key is pressed. You can see if
   there are queued keypresses with keypressed(). The return value contains
   the Unicode value of the key, and if not NULL, the pointer argument will
   be set to the scancode. Unlike readkey(), this function is able to return
   character values greater than 255. Example:
<blockquote class="code"><pre>
      int val, scancode;
      ...
      val = <a href="#ureadkey" class="autotype" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>(&amp;scancode);
      if (val == 0x00F1)
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("You pressed n with tilde\n");

      if (val == 0x00DF)
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("You pressed sharp s\n");
</pre></blockquote>
   You should be able to find Unicode character maps at
   <a href="http://www.unicode.org/">http://www.unicode.org/</a>. Remember that on DOS you must specify a custom
   keyboard map (like those found in <tt>`keyboard.dat'</tt>) usually with the help of
   a configuration file specifying the language mapping (keyboard variable in
   system section of <tt>`allegro.cfg'</tt>), or you will get the default US keyboard
   mapping.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#simulate_ukeypress" title="Stuffs an unicode key into the keyboard buffer.">simulate_ukeypress</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exkeys" title="How to get input from the keyboard in different ways.">exkeys</a>.</blockquote>
<div class="al-api"><b>int <a name="scancode_to_ascii">scancode_to_ascii</a>(int scancode);</b></div><br>
   Converts the given scancode to an ASCII character for that key (mangling
   Unicode values), returning the unshifted uncapslocked result of pressing
   the key, or zero if the key isn't a character-generating key or the lookup
   can't be done. The lookup cannot be done for keys like the F1-F12 keys or the
   cursor keys, and some drivers will only return approximate values. Generally,
   if you want to display the name of a key to the user, you should use the
   scancode_to_name function.

<p>
   Example:
<blockquote class="code"><pre>
      int ascii;
      ...
      ascii = <a href="#scancode_to_ascii" class="autotype" title="Converts a scancode to an ASCII character.">scancode_to_ascii</a>(scancode);
      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("You pressed '%c'\n", ascii);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#scancode_to_name" title="Converts a scancode to a key name.">scancode_to_name</a>.</blockquote>
<div class="al-api"><b>const char *<a name="scancode_to_name">scancode_to_name</a>(int scancode);</b></div><br>
   This function returns a string pointer containing the name of they key with
   the given scancode. This is useful if you e.g. let the user choose a key for
   some action, and want to display something more meaningful than just the
   scancode. Example:
<blockquote class="code"><pre>
      char const *keyname = <a href="#scancode_to_name" class="autotype" title="Converts a scancode to a key name.">scancode_to_name</a>(scancode);
      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("You pressed the %s <a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>.", keyname);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#scancode_to_ascii" title="Converts a scancode to an ASCII character.">scancode_to_ascii</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exkeys" title="How to get input from the keyboard in different ways.">exkeys</a>.</blockquote>
<div class="al-api"><b>void <a name="simulate_keypress">simulate_keypress</a>(int key);</b></div><br>
   Stuffs a key into the keyboard buffer, just as if the user had pressed 
   it. The parameter is in the same format returned by readkey(). Example:
<blockquote class="code"><pre>
      <a href="#simulate_keypress" class="autotype" title="Stuffs a key into the keyboard buffer.">simulate_keypress</a>(KEY_SPACE &lt;&lt; 8);
      if (<a href="#readkey" class="autotype" title="Returns the next character from the keyboard buffer.">readkey</a>() == (KEY_SPACE &lt;&lt; 8))
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("You simulated Alt+Space\n");</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#simulate_ukeypress" title="Stuffs an unicode key into the keyboard buffer.">simulate_ukeypress</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>.</blockquote>
<div class="al-api"><b>void <a name="simulate_ukeypress">simulate_ukeypress</a>(int key, int scancode);</b></div><br>
   Stuffs a key into the keyboard buffer, just as if the user had pressed 
   it. The parameter is in the same format returned by ureadkey(). Example:
<blockquote class="code"><pre>
      /* We ignore the scancode simulation. */
      <a href="#simulate_ukeypress" class="autotype" title="Stuffs an unicode key into the keyboard buffer.">simulate_ukeypress</a>(0x00DF, 0);
      if (<a href="#ureadkey" class="autotype" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>(&amp;scancode) == 0x00DF)
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("You simulated sharp s\n");</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#simulate_keypress" title="Stuffs a key into the keyboard buffer.">simulate_keypress</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#ureadkey" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>.</blockquote>
<div class="al-api"><b>extern int (*<a name="keyboard_callback">keyboard_callback</a>)(int key);</b></div><br>
   If set, this function is called by the keyboard handler in response to 
   every keypress. It is passed a copy of the value that is about to be 
   added into the input buffer, and can either return this value unchanged, 
   return zero to cause the key to be ignored, or return a modified value to 
   change what readkey() will later return. This routine executes in an 
   interrupt context, so it must be in locked memory. Example:
<blockquote class="code"><pre>
      int enigma_scrambler(int <a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>)
      {
         /* Add one to both the scancode and ascii values. */
         return (((<a href="#key" class="autotype" title="Array of flags indicating key state.">key</a> >> 8) + 1) << 8) | ((<a href="#key" class="autotype" title="Array of flags indicating key state.">key</a> &amp; 0xff) + 1);
      }
      <a href="#END_OF_FUNCTION" class="autotype" title="Locks the code used by a timer.">END_OF_FUNCTION</a>(enigma_scrambler)
      
      ...
      
         <a href="#install_timer" class="autotype" title="Installs the Allegro timer interrupt handler.">install_timer</a>();
         <a href="#LOCK_FUNCTION" class="autotype" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>(enigma_scrambler);
         <a href="#install_keyboard" class="autotype" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>();
         <a href="#keyboard_callback" class="autotype" title="User specified keyboard callback handler.">keyboard_callback</a> = enigma_scrambler;</pre></blockquote>

<p>
   Note that this callback will be ignored if you also set the unicode
   keyboard callback.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#ureadkey" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>,
<a class="xref" href="#keyboard_ucallback" title="User specified unicode keyboard callback handler.">keyboard_ucallback</a>,
<a class="xref" href="#keyboard_lowlevel_callback" title="User specified low level keyboard event handler.">keyboard_lowlevel_callback</a>.</blockquote>
<div class="al-api"><b>extern int (*<a name="keyboard_ucallback">keyboard_ucallback</a>)(int key, int *scancode);</b></div><br>
   Unicode-aware version of keyboard_callback(). If set, this function is 
   called by the keyboard handler in response to every keypress. It is 
   passed the character value and scancode that are about to be added into 
   the input buffer, can modify the scancode value, and returns a new or 
   modified key code. If it both sets the scancode to zero and returns zero, 
   the keypress will be ignored. This routine executes in an interrupt 
   context, so it must be in locked memory. Example:
<blockquote class="code"><pre>
      int silence_g_key(int <a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>, int *scancode)
      {
         if (<a href="#key" class="autotype" title="Array of flags indicating key state.">key</a> == 'g') {
            *scancode = 0;
            return 0;
         }
         return <a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>;
      } <a href="#END_OF_FUNCTION" class="autotype" title="Locks the code used by a timer.">END_OF_FUNCTION</a>(silence_g_key)

      ...
      
         <a href="#install_timer" class="autotype" title="Installs the Allegro timer interrupt handler.">install_timer</a>();
         <a href="#LOCK_FUNCTION" class="autotype" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>(silence_g_key);
         <a href="#install_keyboard" class="autotype" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>();
         <a href="#keyboard_ucallback" class="autotype" title="User specified unicode keyboard callback handler.">keyboard_ucallback</a> = silence_g_key;</pre></blockquote>

<p>
   Note that this keyboard callback has priority over the non unicode
   callback. If you set both, only the unicode one will work.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#ureadkey" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>,
<a class="xref" href="#keyboard_callback" title="User specified keyboard callback handler.">keyboard_callback</a>,
<a class="xref" href="#keyboard_lowlevel_callback" title="User specified low level keyboard event handler.">keyboard_lowlevel_callback</a>.</blockquote>
<div class="al-api"><b>extern void (*<a name="keyboard_lowlevel_callback">keyboard_lowlevel_callback</a>)(int scancode);</b></div><br>
   If set, this function is called by the keyboard handler in response to 
   every keyboard event, both presses (including keyboard repeat rate) and
   releases. It will be passed a raw keyboard scancode byte (scancodes are
   7 bits long), with the top bit (8th bit) clear if the key has been
   pressed or set if it was released. This routine executes in an interrupt
   context, so it must be in locked memory. Example:
<blockquote class="code"><pre>
      volatile int key_down, key_up;
      
      void keypress_watcher(int scancode)
      {
         if (scancode &amp; 0x80) {
            key_up = 1;
         } else {
            key_down = 1;
         }
      } <a href="#END_OF_FUNCTION" class="autotype" title="Locks the code used by a timer.">END_OF_FUNCTION</a>(keypress_watcher)

      ...

         <a href="#install_timer" class="autotype" title="Installs the Allegro timer interrupt handler.">install_timer</a>();
         <a href="#LOCK_FUNCTION" class="autotype" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>(silence_g_key);
         <a href="#LOCK_VARIABLE" class="autotype" title="Locks the memory of a variable used by a timer.">LOCK_VARIABLE</a>(key_down);
         <a href="#LOCK_VARIABLE" class="autotype" title="Locks the memory of a variable used by a timer.">LOCK_VARIABLE</a>(key_up);
         <a href="#install_keyboard" class="autotype" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>();
         <a href="#keyboard_lowlevel_callback" class="autotype" title="User specified low level keyboard event handler.">keyboard_lowlevel_callback</a> = keypress_watcher;
         /* Disable keyboard repeat to get typewriter effect. */
         <a href="#set_keyboard_rate" class="autotype" title="Sets the keyboard repeat rate.">set_keyboard_rate</a>(0, 0);

      ...

         while (game_loop) {
            if (key_down) {
               key_down = 0;
               /* Play sample of typewriter <a href="#key" class="autotype" title="Array of flags indicating key state.">key</a> press. */
            }
            if (key_up) {
               key_up = 0;
               /* Play sample of typewriter <a href="#key" class="autotype" title="Array of flags indicating key state.">key</a> release. */
            }
         }</pre></blockquote>
         

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#keyboard_callback" title="User specified keyboard callback handler.">keyboard_callback</a>,
<a class="xref" href="#keyboard_ucallback" title="User specified unicode keyboard callback handler.">keyboard_ucallback</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exkeys" title="How to get input from the keyboard in different ways.">exkeys</a>.</blockquote>
<div class="al-api"><b>void <a name="set_leds">set_leds</a>(int leds);</b></div><br>
   Overrides the state of the keyboard LED indicators. The parameter is a 
   bitmask containing any of the values KB_SCROLOCK_FLAG, KB_NUMLOCK_FLAG, 
   and KB_CAPSLOCK_FLAG, or -1 to restore the default behavior. Example:
<blockquote class="code"><pre>
      /* Cycle led indicators. */
      <a href="#set_leds" class="autotype" title="Sets the state of the keyboard LED indicators.">set_leds</a>(KB_SCROLOCK_FLAG);
      <a href="#rest" class="autotype" title="Waits a specified number of milliseconds or yields CPU.">rest</a>(1000);
      <a href="#set_leds" class="autotype" title="Sets the state of the keyboard LED indicators.">set_leds</a>(KB_CAPSLOCK_FLAG);
      <a href="#rest" class="autotype" title="Waits a specified number of milliseconds or yields CPU.">rest</a>(1000);
      <a href="#set_leds" class="autotype" title="Sets the state of the keyboard LED indicators.">set_leds</a>(KB_NUMLOCK_FLAG);
      <a href="#rest" class="autotype" title="Waits a specified number of milliseconds or yields CPU.">rest</a>(1000);
      <a href="#set_leds" class="autotype" title="Sets the state of the keyboard LED indicators.">set_leds</a>(-1);
</pre></blockquote>
   Note that the led behaviour cannot be guaranteed on some platforms, some
   leds might not react, or none at all. Therefore you shouldn't rely only on
   them to communicate information to the user, just in case it doesn't get
   through.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#key_led_flag" title="Flag to prevent the keyboard LEDs from being updated.">key_led_flag</a>.</blockquote>
<div class="al-api"><b>void <a name="set_keyboard_rate">set_keyboard_rate</a>(int delay, int repeat);</b></div><br>
   Sets the keyboard repeat rate. Times are given in milliseconds. Passing 
   zero times will disable the key repeat.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#ureadkey" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>.</blockquote>
<div class="al-api"><b>void <a name="clear_keybuf">clear_keybuf</a>();</b></div><br>
   Empties the keyboard buffer. Usually you want to use this in your program
   before reading keys to avoid previously buffered keys to be returned by
   calls to readkey() or ureadkey().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#ureadkey" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>extern int <a name="three_finger_flag">three_finger_flag</a>;</b></div><br>
   The DJGPP keyboard handler provides an 'emergency exit' sequence which
   you can use to kill off your program. If you are running under DOS this 
   is the three finger salute, ctrl+alt+del. Most multitasking OS's will 
   trap this combination before it reaches the Allegro handler, in which 
   case you can use the alternative ctrl+alt+end. If you want to disable 
   this behaviour in release versions of your program, set this flag to 
   FALSE.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>.</blockquote>
<div class="al-api"><b>extern int <a name="key_led_flag">key_led_flag</a>;</b></div><br>
   By default, the capslock, numlock, and scroll-lock keys toggle the 
   keyboard LED indicators when they are pressed. If you are using these 
   keys for input in your game (eg. capslock to fire) this may not be 
   desirable, so you can clear this flag to prevent the LED's being updated.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#set_leds" title="Sets the state of the keyboard LED indicators.">set_leds</a>.</blockquote>
<h1><a name="Joystick routines">Joystick routines</a></h1>

<p>
Unlike keyboard or mouse input, which are usually read through hardware
interrupts by Allegro, joystick input functions have to be polled because
there are no hardware interrupts for them on most platforms. This doesn't
mean that you have to poll the joysticks on each line of code you want to
read their values, but you should make sure to poll them at least once per
frame in your game loop. Otherwise you face the possibility of reading stale
incorrect data.

<p><br>
<div class="al-api"><b>int <a name="install_joystick">install_joystick</a>(int type);</b></div><br>
   Installs Allegro's joystick handler, and calibrates the centre position
   values. The type parameter should usually be JOY_TYPE_AUTODETECT, or see
   the platform specific documentation for a list of the available drivers.
   You must call this routine before using any other joystick functions, and
   you should make sure that all joysticks are in the middle position at the
   time. Example:
<blockquote class="code"><pre>
      <a href="#textout_centre_ex" class="autotype" title="Writes a centered string on a bitmap.">textout_centre_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>,
                        "Center the joystick and press a <a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>",
                        <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>/2, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>/2, red_color, -1);
      <a href="#readkey" class="autotype" title="Returns the next character from the keyboard buffer.">readkey</a>();
      if (<a href="#install_joystick" class="autotype" title="Initialises the joystick.">install_joystick</a>(JOY_TYPE_AUTODETECT) != 0)
         abort_on_error("Error initialising joystick!");</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success. As soon as you have installed the joystick 
   module, you will be able to read the button state and digital (on/off 
   toggle) direction information, which may be enough for some games. If you 
   want to get full analogue input, though, you need to use the 
   calibrate_joystick() functions to measure the exact range of the inputs: 
   see below.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#remove_joystick" title="Removes the joystick handler.">remove_joystick</a>,
<a class="xref" href="#num_joysticks" title="Global variable saying how many joysticks there are.">num_joysticks</a>,
<a class="xref" href="#load_joystick_data" title="Loads joystick calibration data.">load_joystick_data</a>,
<a class="xref" href="#calibrate_joystick" title="Calibrates the specified joystick.">calibrate_joystick</a>,
<a class="xref" href="#calibrate_joystick_name" title="Returns the next calibration text string.">calibrate_joystick_name</a>,
<a class="xref" href="#poll_joystick" title="Polls the joystick.">poll_joystick</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>,
<a class="xref" href="#JOY_TYPE_*/DOS" title="Supported DOS joystick drivers.">JOY_TYPE_*/DOS</a>,
<a class="xref" href="#JOY_TYPE_*/Windows" title="Supported Windows joystick drivers.">JOY_TYPE_*/Windows</a>,
<a class="xref" href="#JOY_TYPE_*/Linux" title="Supported Linux joystick drivers.">JOY_TYPE_*/Linux</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exjoy" title="Detecting, calibrating and using joystick input.">exjoy</a>.</blockquote>
<div class="al-api"><b>void <a name="remove_joystick">remove_joystick</a>();</b></div><br>
   Removes the joystick handler. You don't normally need to bother calling 
   this, because allegro_exit() will do it for you.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>.</blockquote>
<div class="al-api"><b>int <a name="poll_joystick">poll_joystick</a>();</b></div><br>
   The joystick handler is not interrupt driven, so you need to call this
   function every now and again to update the global position values. Example:
<blockquote class="code"><pre>
   do {
      /* Get joystick input */
      <a href="#poll_joystick" class="autotype" title="Polls the joystick.">poll_joystick</a>();
      
      /* Process input for the first joystick */
      if (<a href="#joy" class="autotype" title="Global array of joystick state information.">joy</a>[0].button[0].b)
         first_button_pressed();

      if (<a href="#joy" class="autotype" title="Global array of joystick state information.">joy</a>[0].button[1].b)
         second_button_pressed();
      ...
   } while(!done);</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success or a negative number on failure (usually because
   no joystick driver was installed).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>,
<a class="xref" href="#joy" title="Global array of joystick state information.">joy</a>,
<a class="xref" href="#num_joysticks" title="Global variable saying how many joysticks there are.">num_joysticks</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exjoy" title="Detecting, calibrating and using joystick input.">exjoy</a>.</blockquote>
<div class="al-api"><b>extern int <a name="num_joysticks">num_joysticks</a>;</b></div><br>
   Global variable containing the number of active joystick devices. The 
   current drivers support a maximum of eight controllers.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>,
<a class="xref" href="#joy" title="Global array of joystick state information.">joy</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exjoy" title="Detecting, calibrating and using joystick input.">exjoy</a>.</blockquote>
<div class="al-api"><b>extern <a class="autotype" href="#JOYSTICK_INFO" title="Stores information about joysticks.">JOYSTICK_INFO</a> <a name="joy">joy</a>[n];</b></div><br>
   Global array of joystick state information, which is updated by the 
   poll_joystick() function. Only the first num_joysticks elements will 
   contain meaningful information. The JOYSTICK_INFO structure is defined as:
<blockquote class="code"><pre>
      typedef struct <a href="#JOYSTICK_INFO" class="autotype" title="Stores information about joysticks.">JOYSTICK_INFO</a>
      {
         int flags;                       - status flags for this
                                            joystick
         int num_sticks;                  - how many stick inputs?
         int num_buttons;                 - how many buttons?
         <a href="#JOYSTICK_STICK_INFO" class="autotype" title="Stores joystick stick information.">JOYSTICK_STICK_INFO</a> stick[n];    - stick state information
         <a href="#JOYSTICK_BUTTON_INFO" class="autotype" title="Stores joystick button information.">JOYSTICK_BUTTON_INFO</a> button[n];  - button state information
      } <a href="#JOYSTICK_INFO" class="autotype" title="Stores information about joysticks.">JOYSTICK_INFO</a>;
</pre></blockquote>
   The button status is stored in the structure:
<blockquote class="code"><pre>
      typedef struct <a href="#JOYSTICK_BUTTON_INFO" class="autotype" title="Stores joystick button information.">JOYSTICK_BUTTON_INFO</a>
      {
         int b;                           - boolean on/off flag
         char *name;                      - description of this
                                            button
      } <a href="#JOYSTICK_BUTTON_INFO" class="autotype" title="Stores joystick button information.">JOYSTICK_BUTTON_INFO</a>;
</pre></blockquote>
   You may wish to display the button names as part of an input 
   configuration screen to let the user choose what game function will be 
   performed by each button, but in simpler situations you can safely assume 
   that the first two elements in the button array will always be the main 
   trigger controls.

<p>
   Each joystick will provide one or more stick inputs, of varying types. 
   These can be digital controls which snap to specific positions (eg. a 
   gamepad controller, the coolie hat on a Flightstick Pro or Wingman 
   Extreme, or a normal joystick which hasn't yet been calibrated), or they 
   can be full analogue inputs with a smooth range of motion. Sticks may 
   also have different numbers of axes, for example a normal directional 
   control has two, but the Flightstick Pro throttle is only a single axis, 
   and it is possible that the system could be extended in the future to 
   support full 3d controllers. A stick input is described by the structure:
<blockquote class="code"><pre>
      typedef struct <a href="#JOYSTICK_STICK_INFO" class="autotype" title="Stores joystick stick information.">JOYSTICK_STICK_INFO</a>
      {
         int flags;                       - status flags for this
                                            input
         int num_axis;                    - how many axes do we
                                            have? (note the misspelling)
         <a href="#JOYSTICK_AXIS_INFO" class="autotype" title="Stores joystick axis information.">JOYSTICK_AXIS_INFO</a> axis[n];      - axis state information
         char *name;                      - description of this
                                            input
      } <a href="#JOYSTICK_STICK_INFO" class="autotype" title="Stores joystick stick information.">JOYSTICK_STICK_INFO</a>;
</pre></blockquote>
   A single joystick may provide several different stick inputs, but you can 
   safely assume that the first element in the stick array will always be 
   the main directional controller.

<p>
   Information about each of the stick axis is stored in the substructure:
<blockquote class="code"><pre>
      typedef struct <a href="#JOYSTICK_AXIS_INFO" class="autotype" title="Stores joystick axis information.">JOYSTICK_AXIS_INFO</a>
      {
         int pos;                         - analogue axis position
         int d1, d2;                      - digital axis position
         char *name;                      - description of this axis
      } <a href="#JOYSTICK_AXIS_INFO" class="autotype" title="Stores joystick axis information.">JOYSTICK_AXIS_INFO</a>;
</pre></blockquote>
   This provides both analogue input in the pos field (ranging from -128 to 
   128 or from 0 to 255, depending on the type of the control), and digital 
   values in the d1 and d2 fields. For example, when describing the X-axis 
   position, the pos field will hold the horizontal position of the 
   joystick, d1 will be set if it is moved left, and d2 will be set if it is 
   moved right. Allegro will fill in all these values regardless of whether 
   it is using a digital or analogue joystick, emulating the pos field for 
   digital inputs by snapping it to the min, middle, and maximum positions, 
   and emulating the d1 and d2 values for an analogue stick by comparing the 
   current position with the centre point.

<p>
   The joystick flags field may contain any combination of the bit flags:

<p>
   <b>JOYFLAG_DIGITAL</b><br>
      This control is currently providing digital input.

<p>
   <b>JOYFLAG_ANALOGUE</b><br>
      This control is currently providing analogue input.

<p>
   <b>JOYFLAG_CALIB_DIGITAL</b><br>
      This control will be capable of providing digital input once it has 
      been calibrated, but is not doing this at the moment.

<p>
   <b>JOYFLAG_CALIB_ANALOGUE</b><br>
      This control will be capable of providing analogue input once it has 
      been calibrated, but is not doing this at the moment.

<p>
   <b>JOYFLAG_CALIBRATE</b><br>
      Indicates that this control needs to be calibrated. Many devices 
      require multiple calibration steps, so you should call the 
      calibrate_joystick() function from a loop until this flag is cleared.

<p>
   <b>JOYFLAG_SIGNED</b><br>
      Indicates that the analogue axis position is in signed format, ranging 
      from -128 to 128. This is the case for all 2d directional controls.

<p>
   <b>JOYFLAG_UNSIGNED</b><br>
      Indicates that the analogue axis position is in unsigned format, 
      ranging from 0 to 255. This is the case for all 1d throttle controls.

<p>
   Note for people who spell funny: in case you don't like having to type 
   "analogue", there are some #define aliases in allegro/joystick.h that
   will allow you to write "analog" instead.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>,
<a class="xref" href="#poll_joystick" title="Polls the joystick.">poll_joystick</a>,
<a class="xref" href="#num_joysticks" title="Global variable saying how many joysticks there are.">num_joysticks</a>,
<a class="xref" href="#calibrate_joystick" title="Calibrates the specified joystick.">calibrate_joystick</a>,
<a class="xref" href="#calibrate_joystick_name" title="Returns the next calibration text string.">calibrate_joystick_name</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exjoy" title="Detecting, calibrating and using joystick input.">exjoy</a>.</blockquote>
<div class="al-api"><b>const char *<a name="calibrate_joystick_name">calibrate_joystick_name</a>(int n);</b></div><br>
   Pass the number of the joystick you want to calibrate as the parameter.
<p><b>Return value:</b>
   Returns a text description for the next type of calibration that will be
   done on the specified joystick, or NULL if no more calibration is 
   required.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>,
<a class="xref" href="#calibrate_joystick" title="Calibrates the specified joystick.">calibrate_joystick</a>,
<a class="xref" href="#joy" title="Global array of joystick state information.">joy</a>,
<a class="xref" href="#num_joysticks" title="Global variable saying how many joysticks there are.">num_joysticks</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exjoy" title="Detecting, calibrating and using joystick input.">exjoy</a>.</blockquote>
<div class="al-api"><b>int <a name="calibrate_joystick">calibrate_joystick</a>(int n);</b></div><br>
   Most joysticks need to be calibrated before they can provide full 
   analogue input. This function performs the next operation in the 
   calibration series for the specified stick, assuming that the joystick 
   has been positioned in the manner described by a previous call to 
   calibrate_joystick_name(), returning zero on success. For example, a 
   simple routine to fully calibrate all the joysticks might look like:
<blockquote class="code"><pre>
      int i;

      for (i=0; i&lt;;<a href="#num_joysticks" class="autotype" title="Global variable saying how many joysticks there are.">num_joysticks</a>; i++) {
         while (<a href="#joy" class="autotype" title="Global array of joystick state information.">joy</a>[i].flags &amp; JOYFLAG_CALIBRATE) {
            char *msg = <a href="#calibrate_joystick_name" class="autotype" title="Returns the next calibration text string.">calibrate_joystick_name</a>(i);
            <a href="#textprintf_ex" class="autotype" title="Formatted output of a string.">textprintf_ex</a>(..., "%s, and press a <a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>\n", msg);
            <a href="#readkey" class="autotype" title="Returns the next character from the keyboard buffer.">readkey</a>();
            if (<a href="#calibrate_joystick" class="autotype" title="Calibrates the specified joystick.">calibrate_joystick</a>(i) != 0) {
               <a href="#textprintf_ex" class="autotype" title="Formatted output of a string.">textprintf_ex</a>(..., "oops!\n");
               <a href="#readkey" class="autotype" title="Returns the next character from the keyboard buffer.">readkey</a>();
               exit(1);
            }
         }
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success, non-zero if the calibration could not be
   performed successfully.
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>,
<a class="xref" href="#calibrate_joystick_name" title="Returns the next calibration text string.">calibrate_joystick_name</a>,
<a class="xref" href="#joy" title="Global array of joystick state information.">joy</a>,
<a class="xref" href="#num_joysticks" title="Global variable saying how many joysticks there are.">num_joysticks</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exjoy" title="Detecting, calibrating and using joystick input.">exjoy</a>.</blockquote>
<div class="al-api"><b>int <a name="save_joystick_data">save_joystick_data</a>(const char *filename);</b></div><br>
   After all the headache of calibrating the joystick, you may not want to 
   make your poor users repeat the process every time they run your program. 
   Call this function to save the joystick calibration data into the 
   specified configuration file, from which it can later be read by 
   load_joystick_data(). Pass a NULL filename to write the data to the 
   currently selected configuration file.
<p><b>Return value:</b>
   Returns zero on success, non-zero if the data could not be saved.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_joystick_data" title="Loads joystick calibration data.">load_joystick_data</a>,
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>.</blockquote>
<div class="al-api"><b>int <a name="load_joystick_data">load_joystick_data</a>(const char *filename);</b></div><br>
   Restores calibration data previously stored by save_joystick_data() or 
   the setup utility. This sets up all aspects of the joystick code: you 
   don't even need to call install_joystick() if you are using this 
   function. Pass a NULL filename to read the data from the currently 
   selected configuration file.
<p><b>Return value:</b>
   Returns zero on success: if it fails the joystick state is undefined and
   you must reinitialise it from scratch.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>,
<a class="xref" href="#save_joystick_data" title="Saves joystick calibration data.">save_joystick_data</a>,
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>.</blockquote>
<div class="al-api"><b>int <a name="initialise_joystick">initialise_joystick</a>();</b></div><br>
   Deprecated. Use install_joystick() instead.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>.</blockquote>
<h1><a name="Graphics modes">Graphics modes</a></h1>

<p>
Graphics modes are the common denominator for most Allegro programs. While it
is possible to write platform specific programs using Allegro which don't set
a graphic mode through the routines provided in this chapter, these are not
very common.

<p>
The first thing to note is that due to the wide range of supported platforms,
a graphic mode is the only way to safely communicate with the user. When
Allegro was a DOS only library (versions 3.x and previous), it was frequent
for programmers to use functions from the C standard library to communicate
with the user, like calling printf() before setting a graphic mode or maybe
scanf() to read the user's input. However, what would happen for such a game
running under Windows where there is no default console output or it may be
hidden from the user? Even if the game compiled successfully, it would be
unplayable, especially if there was vital information for the user in those
text only messages.

<p>
Allegro provides the allegro_message() function to deal with this problem,
but this is not a very user friendly method of communicating with the user
and its main purpose is displaying small error like messages when no graphic
mode is available. Therefore, the first thing your Allegro program should do
is set a graphic mode, and from there on, use Allegro's text output routines
to display messages to the user, just like <tt>`allegro/examples/exhello.c'</tt> does.

<p>
Setting a graphic mode involves deciding how to allocate the memory of the
video card for your program. On some platforms this means creating a virtual
screen bigger than the physical resolution to do hardware scrolling or page
flipping. Virtual screens can cause a lot of confusion, but they are really
quite simple. Warning: patronising explanation coming up, so you may wish to
skip the rest of this paragraph. Think of video memory as a rectangular piece
of paper which is being viewed through a small hole (your monitor) in a bit of
cardboard. Since the paper is bigger than the hole you can only see part of it
at any one time, but by sliding the cardboard around you can alter which
portion of the image is visible. You could just leave the hole in one position
and ignore the parts of video memory that aren't visible, but you can get all
sorts of useful effects by sliding the screen window around, or by drawing
images in a hidden part of video memory and then flipping across to display
them.

<p>
For example, you could select a 640x480 mode in which the monitor acts as a
window onto a 1024x1024 virtual screen, and then move the visible screen
around in this larger area (hardware scrolling). Initially, with the visible
screen positioned at the top left corner of video memory, this setup would
look like:
<blockquote class="text"><pre>
      (0,0)------------(640,0)----(1024,0)
        |                  |           |
        |  visible screen  |           |
        |                  |           |
      (0,480)----------(640,480)       |
        |                              |
        |   the rest of video memory   |
        |                              |
      (0,1024)--------------------(1024,1024)
</pre></blockquote>
With a virtual screen bigger than the visible screen you can perform smooth
CPU inexpensive scrolling: you draw your graphics once, and then only tell
the video card to show a different portion of the screen. However, virtual
screens are not supported on all platforms, and on some they might be
emulated through software, losing any performance. On top of that, many video
cards only allow horizontal scrolling in steps of 32 bytes. This is not a
problem if your game runs in 24 or 32 bit, but it tends to mean jerky
scrolling for other color depths.

<p>
The other reason you could use virtual screens for is page flipping. This
means showing one portion of the virtual screen while your program draws to
the hidden one. When you finish, you show the part you have been drawing to
and repeat the process with the area now hidden. The result is a perfectly
smooth screen update without flickering or other graphical artifacts.

<p>
Scrolling manually to one part of the video memory is one non portable way to
accomplish this. The portable way is to use functions like
create_system_bitmap(), create_video_bitmap(), show_video_bitmap(), etc. These
functions divide the memory of the video card in areas and switch between
them, a feature supported on all platforms and video cards (given that they
have enough memory for the screen resolutions you asked for).

<p>
The last thing you need to know about setting a graphic mode are drivers.
Each platform has a number of graphic drivers which support a different range
of hardware or behave in different ways. To avoid cluttering your own code
with #ifdefs and dealing with drivers added after you release your program,
Allegro provides several so called magic drivers. These magic drivers don't
really exists, they wrap around a specific kind of functionality.

<p>
The magic drivers you can use are:
<ul><li>
GFX_AUTODETECT:<br>
   Allegro will try to set the specified resolution with the current color
   depth in fullscreen mode. Failing that, it will try to repeat the same
   operation in windowed mode. If the call to set_gfx_mode() succeeds, you
   are guaranteed to have set the specified resolution in the current color
   depth, but you don't know if the program is running fullscreen or
   windowed.
<li>
GFX_AUTODETECT_FULLSCREEN:<br>
   Allegro will try to set the specified resolution with the current color
   depth in fullscreen mode. If that is not possible, set_gfx_mode() will
   fail.
<li>
GFX_AUTODETECT_WINDOWED:<br>
   Allegro will try to set the specified resolution with the current color
   depth in a windowed mode. If that is not possible, set_gfx_mode() will
   fail. When it comes to windowed modes, the `specified resolution' actually
   means the graphic area your program can draw on, without including window
   decorations (if any). Note that in windowed modes running with a color
   depth other than the desktop may result in non optimal performance due to
   internal color conversions in the graphic driver. Use
   desktop_color_depth() to your advantage in these situations.
<li>
GFX_SAFE:<br>
   Using this driver Allegro guarantees that a graphic mode will always be
   set correctly. It will try to select the resolution that you request, and
   if that fails, it will fall back upon whatever mode is known to be
   reliable on the current platform (this is 320x200 VGA mode under DOS, a
   640x480 resolution under Windows, the actual framebuffer's resolution
   under Linux if it's supported, etc). If it absolutely cannot set any
   graphics mode at all, it will return negative as usual, meaning that
   there's no possible video output on the machine, and that you should abort
   your program immediately, possibly after notifying this to the user with
   allegro_message.

   This fake driver is useful for situations where you just want to get into
   some kind of workable display mode, and can't be bothered with trying
   multiple different resolutions and doing all the error checking yourself.
   Note however, that after a successful call to set_gfx_mode with this
   driver, you cannot make any assumptions about the width, height or color
   depth of the screen: your code will have to deal with this little detail.
<li>
   GFX_TEXT:<br>
   Closes any previously opened graphics mode, making you unable to use the
   global variable <tt>`screen'</tt>, and in those environments that have text modes,
   sets one previously used or the closest match to that (usually 80x25).
   With this driver the size parameters of set_gfx_mode don't mean anything,
   so you can leave them all to zero or any other number you prefer.
</ul>

<p><br>
<div class="al-api"><b>void <a name="set_color_depth">set_color_depth</a>(int depth);</b></div><br>
   Sets the pixel format to be used by subsequent calls to set_gfx_mode() 
   and create_bitmap(). Valid depths are 8 (the default), 15, 16, 24, and 32 
   bits. Example:
<blockquote class="code"><pre>
      <a href="#set_color_depth" class="autotype" title="Sets the global pixel color depth.">set_color_depth</a>(32);
      if (<a href="#set_gfx_mode" class="autotype" title="Sets a graphic video mode.">set_gfx_mode</a>(GFX_AUTODETECT, 640, 480, 0, 0) != 0) {
         abort_on_error("Couldn't set a 32 bit color resolution");
      }
</pre></blockquote>
   Note that the screen color depth won't change until the next successful
   call to set_gfx_mode().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_color_depth" title="Returns the current pixel color depth.">get_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#getr" title="Extract a color component from the current pixel format.">getr</a>,
<a class="xref" href="#desktop_color_depth" title="Finds out the desktop color depth.">desktop_color_depth</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>int <a name="get_color_depth">get_color_depth</a>(void);</b></div><br>
   Returns the current pixel format. This can be very useful to know in order
   to write generic functions which select a different code path internally
   depending on the color depth being used.

<p>
   Note that the function returns whatever value you may have set previously
   with set_color_depth(), which can be different from the current color
   depth of the screen global variable. If you really need to know the color
   depth of the screen, use bitmap_color_depth().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>.</blockquote>
<div class="al-api"><b>void <a name="request_refresh_rate">request_refresh_rate</a>(int rate);</b></div><br>
   Requests that the next call to set_gfx_mode() try to use the specified 
   refresh rate, if possible. Not all drivers are able to control this at 
   all, and even when they can, not all rates will be possible on all 
   hardware, so the actual settings may differ from what you requested. 
   After you call set_gfx_mode(), you can use get_refresh_rate() to find out 
   what was actually selected. At the moment only the DOS VESA 3.0, X DGA 2.0
   and some Windows DirectX drivers support this function. The speed is
   specified in Hz, eg. 60, 70. To return to the normal default selection,
   pass a rate value of zero. Example:
<blockquote class="code"><pre>
      <a href="#request_refresh_rate" class="autotype" title="Requests a specific refresh rate during graphic mode switch.">request_refresh_rate</a>(60);
      if (<a href="#set_gfx_mode" class="autotype" title="Sets a graphic video mode.">set_gfx_mode</a>(GFX_AUTODETECT, 640, 480, 0, 0) != 0)
         abort_on_error("Couldn't set graphic mode!");
      if (<a href="#get_refresh_rate" class="autotype" title="Returns the current refresh rate.">get_refresh_rate</a>() != 60)
         abort_on_error("Couldn't set refresh rate to 60Hz!");</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#get_refresh_rate" title="Returns the current refresh rate.">get_refresh_rate</a>.</blockquote>
<div class="al-api"><b>int <a name="get_refresh_rate">get_refresh_rate</a>(void);</b></div><br>
   Returns the current refresh rate, if known (not all drivers are able to 
   report this information). Returns zero if the actual rate is unknown.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#request_refresh_rate" title="Requests a specific refresh rate during graphic mode switch.">request_refresh_rate</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#GFX_MODE_LIST" title="Stores an array of GFX_MODE structures.">GFX_MODE_LIST</a> *<a name="get_gfx_mode_list">get_gfx_mode_list</a>(int card);</b></div><br>
   Attempts to create a list of all the supported video modes for a certain
   graphics driver, made up from the GFX_MODE_LIST structure, which has the
   following definition:
<blockquote class="code"><pre>
      typedef struct <a href="#GFX_MODE_LIST" class="autotype" title="Stores an array of GFX_MODE structures.">GFX_MODE_LIST</a>
      {
         int num_modes;
         <a href="#GFX_MODE" class="autotype" title="Stores video mode information.">GFX_MODE</a> *mode;
      } <a href="#GFX_MODE_LIST" class="autotype" title="Stores an array of GFX_MODE structures.">GFX_MODE_LIST</a>;
</pre></blockquote>
   The mode entry  points to the actual list of video modes.
<blockquote class="code"><pre>
      typedef struct <a href="#GFX_MODE" class="autotype" title="Stores video mode information.">GFX_MODE</a>
      {
         int width, height, bpp;
      } <a href="#GFX_MODE" class="autotype" title="Stores video mode information.">GFX_MODE</a>;
</pre></blockquote>
   This list of video modes is terminated with an { 0, 0, 0 } entry.

<p>
   Note that the card parameter must refer to a _real_ driver. This function
   fails if you pass GFX_SAFE, GFX_AUTODETECT, or any other "magic" driver.
<p><b>Return value:</b>
   Returns a pointer to a list structure of the type GFX_MODE_LIST or NULL
   if the request could not be satisfied.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#destroy_gfx_mode_list" title="Frees the list created by get_gfx_mode_list().">destroy_gfx_mode_list</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_gfx_mode_list">destroy_gfx_mode_list</a>(<a class="autotype" href="#GFX_MODE_LIST" title="Stores an array of GFX_MODE structures.">GFX_MODE_LIST</a> *mode_list);</b></div><br>
   Removes the mode list created by get_gfx_mode_list() from memory. Use this
   once you are done with the generated mode list to avoid memory leaks in
   your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_gfx_mode_list" title="Obtains a list of available video modes.">get_gfx_mode_list</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>
<div class="al-api"><b>int <a name="set_gfx_mode">set_gfx_mode</a>(int card, int w, int h, int v_w, int v_h);</b></div><br>
   Switches into graphics mode. The card parameter should usually be one of
   the Allegro magic drivers (read introduction of chapter "Graphics modes")
   or see the platform specific documentation for a list of the available
   drivers. The w and h parameters specify what screen resolution you want.
   The color depth of the graphic mode has to be specified before calling
   this function with set_color_depth().

<p>
   The v_w and v_h parameters specify the minimum virtual screen size, in 
   case you need a large virtual screen for hardware scrolling or page 
   flipping. You should set them to zero if you don't care about the virtual 
   screen size.
   
<p>
   When you call set_gfx_mode(), the v_w and v_h parameters represent the 
   minimum size of virtual screen that is acceptable for your program. The 
   range of possible sizes is usually very restricted, and Allegro may 
   end up creating a virtual screen much larger than the one you request.
   Allowed sizes are driver dependent and some drivers do not allow virtual 
   screens that are larger than the visible screen at all: don't assume
   that whatever you pass will always work.
   
<p>
   In mode-X the virtual width can be any multiple of eight greater than or 
   equal to the physical screen width, and the virtual height will be set 
   accordingly (the VGA has 256k of vram, so the virtual height will be 
   256*1024/virtual_width).

<p>
   Currently, using a big virtual screen for page flipping is considered bad
   practice.  There are platforms which don't support virtual screens bigger
   than the physical screen but can create different video pages to flip back
   and forth. This means that, if you want page flipping and aren't going to
   use hardware scrolling, you should call set_gfx_mode() with (0,0) as the
   virtual screen size and later create the different video pages with
   create_video_bitmap(). Otherwise your program will be limited to the
   platforms supporting hardware scrolling.

<p>
   After you select a graphics mode, the physical and virtual screen sizes 
   can be checked with the macros SCREEN_W, SCREEN_H, VIRTUAL_W, and 
   VIRTUAL_H.
<p><b>Return value:</b>
   Returns zero on success. On failure returns a negative number and stores a
   description of the problem in allegro_error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#request_refresh_rate" title="Requests a specific refresh rate during graphic mode switch.">request_refresh_rate</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>,
<a class="xref" href="#GFX_*/DOS" title="Supported DOS graphic drivers.">GFX_*/DOS</a>,
<a class="xref" href="#GFX_*/Windows" title="Supported Windows graphic drivers.">GFX_*/Windows</a>,
<a class="xref" href="#GFX_*/X" title="Supported X graphic drivers.">GFX_*/X</a>,
<a class="xref" href="#GFX_*/Linux" title="Supported Linux console graphic drivers.">GFX_*/Linux</a>,
<a class="xref" href="#GFX_*/BeOS" title="Supported BeOS graphic drivers.">GFX_*/BeOS</a>,
<a class="xref" href="#GFX_*/MacOSX" title="Supported MacOSX graphic drivers.">GFX_*/MacOSX</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#get_desktop_resolution" title="Finds out the desktop resolution.">get_desktop_resolution</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#VIRTUAL_W" title="Global define to obtain the virtual size of the screen.">VIRTUAL_W</a>,
<a class="xref" href="#VIRTUAL_H" title="Global define to obtain the virtual size of the screen.">VIRTUAL_H</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>int <a name="set_display_switch_mode">set_display_switch_mode</a>(int mode);</b></div><br>
   Sets how the program should handle being switched into the background, 
   if the user tabs away from it. Not all of the possible modes will be
   supported by every graphics driver on every platform. The available modes
   are:
<ul><li>
   SWITCH_NONE<br>
      Disables switching. This is the default in single-tasking systems like 
      DOS. It may be supported on other platforms, but you should use it 
      with caution, because your users won't be impressed if they want to 
      switch away from your program, but you don't let them!
<li>
   SWITCH_PAUSE<br>
      Pauses the program whenever it is in the background. Execution will be 
      resumed as soon as the user switches back to it. This is the default 
      in most fullscreen multitasking environments, for example the Linux 
      console, but not under Windows.
<li>
   SWITCH_AMNESIA<br>
      Like SWITCH_PAUSE, but this mode doesn't bother to remember the 
      contents of video memory, so the screen, and any video bitmaps that 
      you have created, will be erased after the user switches away and then 
      back to your program. This is not a terribly useful mode to have, but 
      it is the default for the fullscreen drivers under Windows because 
      DirectDraw is too dumb to implement anything better.
<li>
   SWITCH_BACKGROUND<br>
      The program will carry on running in the background, with the screen 
      bitmap temporarily being pointed at a memory buffer for the fullscreen 
      drivers. You must take special care when using this mode, because bad 
      things will happen if the screen bitmap gets changed around when your 
      program isn't expecting it (see below).
<li>
   SWITCH_BACKAMNESIA<br>
      Like SWITCH_BACKGROUND, but this mode doesn't bother to remember the 
      contents of video memory (see SWITCH_AMNESIA). It is again the only 
      mode supported by the fullscreen drivers under Windows that lets the 
      program keep running in the background.
</ul>
   Note that you should be very careful when you are using graphics routines 
   in the switching context: you must always call acquire_screen() before the
   start of any drawing code onto the screen and not release it until you are
   completely finished, because the automatic locking mechanism may not be
   good enough to work when the program runs in the background or has just
   been raised in the foreground.
<p><b>Return value:</b>
   Returns zero on success, invalidating at the same time all callbacks
   previously registered with set_display_switch_callback(). Returns -1 if
   the requested mode is not currently possible.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_display_switch_callback" title="Installs a switching notification callback.">set_display_switch_callback</a>,
<a class="xref" href="#get_display_switch_mode" title="Returns the current display switching mode.">get_display_switch_mode</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>.</blockquote>
<div class="al-api"><b>int <a name="set_display_switch_callback">set_display_switch_callback</a>(int dir, void (*cb)());</b></div><br>
   Installs a notification callback for the switching mode that was 
   previously selected by calling set_display_switch_mode(). The direction 
   parameter can either be SWITCH_IN or SWITCH_OUT, depending whether you 
   want to be notified about switches away from your program or back to your 
   program. You can sometimes install callbacks for both directions at the 
   same time, but not every platform supports this. You can install several
   switch callbacks, but no more than eight on any platform.
<p><b>Return value:</b>
   Returns zero on success, decreasing the number of empty callback slots by
   one. Returns -1 if the request is impossible for the current platform or
   you have reached the maximum number of allowed callbacks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#remove_display_switch_callback" title="Removes a switching notification callback.">remove_display_switch_callback</a>,
<a class="xref" href="#set_display_switch_mode" title="Tells Allegro how the program handles background switching.">set_display_switch_mode</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>.</blockquote>
<div class="al-api"><b>void <a name="remove_display_switch_callback">remove_display_switch_callback</a>(void (*cb)());</b></div><br>
   Removes a notification callback that was previously installed by calling 
   set_display_switch_callback(). All the callbacks will automatically be 
   removed when you call set_display_switch_mode(). You can safely call this
   function even if the callback you want to remove is not installed.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_display_switch_callback" title="Installs a switching notification callback.">set_display_switch_callback</a>.</blockquote>
<div class="al-api"><b>int <a name="get_display_switch_mode">get_display_switch_mode</a>();</b></div><br>
   Returns the current display switching mode, in the same format passed to 
   set_display_switch_mode().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_display_switch_mode" title="Tells Allegro how the program handles background switching.">set_display_switch_mode</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>.</blockquote>
<div class="al-api"><b>int <a name="is_windowed_mode">is_windowed_mode</a>(void);</b></div><br>
   This function can be used to detect whether or not set_gfx_mode() selected
   a windowed mode. Example:
<blockquote class="code"><pre>
      if (<a href="#set_gfx_mode" class="autotype" title="Sets a graphic video mode.">set_gfx_mode</a>(GFX_AUTODETECT, 640, 480, 0, 0) != 0)
         abort_on_error("Couldn't set graphic mode!");
      if (<a href="#is_windowed_mode" class="autotype" title="Tells if you are running in windowed mode.">is_windowed_mode</a>()) {
         /* Windowed mode stuff. */
      } else {
         /* Fullscreen mode stuff. */
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns true if the current graphics mode is a windowed mode, or zero if
   it is a fullscreen mode. You should not call this function if you are not
   in graphics mode.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>.</blockquote>
<div class="al-api"><b>extern int <a name="gfx_capabilities">gfx_capabilities</a>;</b></div><br>
   Bitfield describing the capabilities of the current graphics driver and 
   video hardware. This may contain combination any of the flags:

<p>
   <b>GFX_CAN_SCROLL:</b><br>
      Indicates that the scroll_screen() function may be used with this 
      driver.

<p>
   <b>GFX_CAN_TRIPLE_BUFFER:</b><br>
      Indicates that the request_scroll() and poll_scroll() functions may be 
      used with this driver. If this flag is not set, it is possible that 
      the enable_triple_buffer() function may be able to activate it.

<p>
   <b>GFX_HW_CURSOR:</b><br>
      Indicates that a hardware mouse cursor is in use. When this flag is 
      set, it is safe to draw onto the screen without hiding the mouse 
      pointer first. Note that not every cursor graphic can be implemented 
      in hardware: in particular VBE/AF only supports 2-color images up to 
      32x32 in size, where the second color is an exact inverse of the 
      first. This means that Allegro may need to switch between hardware and 
      software cursors at any point during the execution of your program, so 
      you should not assume that this flag will remain constant for long 
      periods of time. It only tells you whether a hardware cursor is in use 
      at the current time, and may change whenever you hide/redisplay the 
      pointer.
      
<p>
   <b>GFX_SYSTEM_CURSOR</b><br>
      Indicates that the mouse cursor is the default system cursor, not 
      Allegro's custom cursor.

<p>
   <b>GFX_HW_HLINE:</b><br>
      Indicates that the normal opaque version of the hline() function is 
      implemented using a hardware accelerator. This will improve the 
      performance not only of hline() itself, but also of many other 
      functions that use it as a workhorse, for example circlefill(), 
      triangle(), and floodfill().

<p>
   <b>GFX_HW_HLINE_XOR:</b><br>
      Indicates that the XOR version of the hline() function, and any other 
      functions that use it as a workhorse, are implemented using a hardware 
      accelerator.

<p>
   <b>GFX_HW_HLINE_SOLID_PATTERN:</b><br>
      Indicates that the solid and masked pattern modes of the hline() 
      function, and any other functions that use it as a workhorse, are 
      implemented using a hardware accelerator (see note below).

<p>
   <b>GFX_HW_HLINE_COPY_PATTERN:</b><br>
      Indicates that the copy pattern mode of the hline() function, and any 
      other functions that use it as a workhorse, are implemented using a 
      hardware accelerator (see note below).

<p>
   <b>GFX_HW_FILL:</b><br>
      Indicates that the opaque version of the rectfill() function, the 
      clear_bitmap() routine, and clear_to_color(), are implemented using a
      hardware accelerator.

<p>
   <b>GFX_HW_FILL_XOR:</b><br>
      Indicates that the XOR version of the rectfill() function is 
      implemented using a hardware accelerator.

<p>
   <b>GFX_HW_FILL_SOLID_PATTERN:</b><br>
      Indicates that the solid and masked pattern modes of the rectfill() 
      function are implemented using a hardware accelerator (see note below).

<p>
   <b>GFX_HW_FILL_COPY_PATTERN:</b><br>
      Indicates that the copy pattern mode of the rectfill() function is 
      implemented using a hardware accelerator (see note below).

<p>
   <b>GFX_HW_LINE:</b><br>
      Indicates that the opaque mode line() and vline() functions are 
      implemented using a hardware accelerator.

<p>
   <b>GFX_HW_LINE_XOR:</b><br>
      Indicates that the XOR version of the line() and vline() functions are 
      implemented using a hardware accelerator.

<p>
   <b>GFX_HW_TRIANGLE:</b><br>
      Indicates that the opaque mode triangle() function is implemented 
      using a hardware accelerator.

<p>
   <b>GFX_HW_TRIANGLE_XOR:</b><br>
      Indicates that the XOR version of the triangle() function is 
      implemented using a hardware accelerator.

<p>
   <b>GFX_HW_GLYPH:</b><br>
      Indicates that monochrome character expansion (for text drawing) is 
      implemented using a hardware accelerator.

<p>
   <b>GFX_HW_VRAM_BLIT:</b><br>
      Indicates that blitting from one part of the screen to another is 
      implemented using a hardware accelerator. If this flag is set, 
      blitting within the video memory will almost certainly be the fastest 
      possible way to display an image, so it may be worth storing some of 
      your more frequently used graphics in an offscreen portion of the 
      video memory.

<p>
   <b>GFX_HW_VRAM_BLIT_MASKED:</b><br>
      Indicates that the masked_blit() routine is capable of a hardware 
      accelerated copy from one part of video memory to another, and that 
      draw_sprite() will use a hardware copy when given a sub-bitmap of the 
      screen or a video memory bitmap as the source image. If this flag is 
      set, copying within the video memory will almost certainly be the 
      fastest possible way to display an image, so it may be worth storing 
      some of your more frequently used sprites in an offscreen portion of 
      the video memory.

<p>
      Warning: if this flag is not set, masked_blit() and draw_sprite() will 
      not work correctly when used with a video memory source image! You 
      must only try to use these functions to copy within the video memory 
      if they are supported in hardware.

<p>
   <b>GFX_HW_MEM_BLIT:</b><br>
      Indicates that blitting from a memory bitmap onto the screen is being 
      accelerated in hardware.

<p>
   <b>GFX_HW_MEM_BLIT_MASKED:</b><br>
      Indicates that the masked_blit() and draw_sprite() functions are being 
      accelerated in hardware when the source image is a memory bitmap and 
      the destination is the physical screen.

<p>
   <b>GFX_HW_SYS_TO_VRAM_BLIT:</b><br>
      Indicates that blitting from a system bitmap onto the screen is being 
      accelerated in hardware. Note that some acceleration may be present 
      even if this flag is not set, because system bitmaps can benefit from 
      normal memory to screen blitting as well. This flag will only be set 
      if system bitmaps have further acceleration above and beyond what is 
      provided by GFX_HW_MEM_BLIT.

<p>
   <b>GFX_HW_SYS_TO_VRAM_BLIT_MASKED:</b><br>
      Indicates that the masked_blit() and draw_sprite() functions are being 
      accelerated in hardware when the source image is a system bitmap and 
      the destination is the physical screen. Note that some acceleration 
      may be present even if this flag is not set, because system bitmaps 
      can benefit from normal memory to screen blitting as well. This flag 
      will only be set if system bitmaps have further acceleration above and 
      beyond what is provided by GFX_HW_MEM_BLIT_MASKED.

<p>
   <b>GFX_HW_VRAM_STRETCH_BLIT:</b><br>
      Indicates that stretched blitting of video bitmaps onto the screen is
      implemented using hardware acceleration. 

<p>
   <b>GFX_HW_SYS_STRETCH_BLIT:</b><br>
      Indicates that stretched blitting of system bitmaps onto the screen is
      implemented using hardware acceleration. 

<p>
   <b>GFX_HW_VRAM_STRETCH_BLIT_MASKED:</b><br>
      Indicates that masked stretched blitting (including stretch_sprite) of 
      video bitmaps onto the screen is implemented using hardware acceleration.
      NOTE: some display drivers may show artifacts when this function is used.
      If the image does not look correct try updating your video drivers.

<p>
   <b>GFX_HW_SYS_STRETCH_BLIT_MASKED:</b><br>
      Indicates that masked stretched blitting (including stretch_sprite) of 
      system bitmaps onto the screen is implemented using hardware acceleration.
      NOTE: some display drivers may show artefact's when this function is used.
      If the image does not look correct try updating your video drivers.

<p>
   Note: even if the capabilities information says that patterned drawing is 
   supported by the hardware, it will not be possible for every size of 
   pattern. VBE/AF only supports patterns up to 8x8 in size, so Allegro will 
   fall back on the original non-accelerated drawing routines whenever you 
   use a pattern larger than this.

<p>
   Note2: these hardware acceleration features will only take effect when 
   you are drawing directly onto the screen bitmap, a video memory bitmap, 
   or a sub-bitmap thereof. Accelerated hardware is most useful in a page 
   flipping or triple buffering setup, and is unlikely to make any 
   difference to the classic "draw onto a memory bitmap, then blit to the 
   screen" system.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#scroll_screen" title="Requests a hardware scroll request.">scroll_screen</a>,
<a class="xref" href="#request_scroll" title="Queues a hardware scroll request with triple buffering.">request_scroll</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#enable_triple_buffer" title="Enables triple buffering.">enable_triple_buffer</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exaccel" title="Using offscreen video memory to store source graphics for VBE/AF.">exaccel</a>,
<a class="eref" href="#exsyscur" title="">exsyscur</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>int <a name="enable_triple_buffer">enable_triple_buffer</a>();</b></div><br>
   If the GFX_CAN_TRIPLE_BUFFER bit of the gfx_capabilities field is not 
   set, you can attempt to enable it by calling this function. In particular 
   if you are running in mode-X in a clean DOS environment, this routine 
   will enable the timer retrace simulator, which will activate the triple 
   buffering functions.
<p><b>Return value:</b>
   Returns zero if triple buffering is enabled, -1 otherwise.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#request_scroll" title="Queues a hardware scroll request with triple buffering.">request_scroll</a>,
<a class="xref" href="#request_video_bitmap" title="Triple buffering page flip request.">request_video_bitmap</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>int <a name="scroll_screen">scroll_screen</a>(int x, int y);</b></div><br>
   Attempts to scroll the hardware screen to display a different part of the 
   virtual screen (initially it will be positioned at 0, 0, which is the top 
   left corner). You can use this to move the screen display around in a
   large virtual screen space, or to page flip back and forth between two
   non-overlapping areas of the virtual screen. Note that to draw outside the
   original position in the screen bitmap you will have to alter the clipping
   rectangle with set_clip_rect().

<p>
   Mode-X scrolling is reliable and will work on any card, other drivers may
   not work or not work reliably. See the platform-specific section of the docs
   for more information.

<p>
   Allegro will handle any necessary vertical retrace synchronisation when 
   scrolling the screen, so you don't need to call vsync() before it. This 
   means that scroll_screen() has the same time delay effects as vsync().
<p><b>Return value:</b>
   Returns zero on success. Returns non-zero if the graphics driver can't
   handle hardware scrolling or the virtual screen is not large enough.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#show_video_bitmap" title="Flips the hardware screen to use the specified page.">show_video_bitmap</a>,
<a class="xref" href="#request_scroll" title="Queues a hardware scroll request with triple buffering.">request_scroll</a>,
<a class="xref" href="#request_video_bitmap" title="Triple buffering page flip request.">request_video_bitmap</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>.</blockquote>
<div class="al-api"><b>int <a name="request_scroll">request_scroll</a>(int x, int y);</b></div><br>
   This function is used for triple buffering. It requests a hardware scroll 
   to the specified position, but returns immediately rather than waiting 
   for a retrace. The scroll will then take place during the next vertical 
   retrace, but you can carry on running other code in the meantime and use 
   the poll_scroll() routine to detect when the flip has actually taken 
   place.

<p>
   Triple buffering is only possible with certain drivers: you can look at the 
   GFX_CAN_TRIPLE_BUFFER bit in the gfx_capabilities flag to see if it will 
   work with the current driver.
<p><b>Return value:</b>
   This function returns zero on success, non-zero otherwise.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#poll_scroll" title="Checks the status of a scroll request with triple buffering.">poll_scroll</a>,
<a class="xref" href="#request_video_bitmap" title="Triple buffering page flip request.">request_video_bitmap</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#scroll_screen" title="Requests a hardware scroll request.">scroll_screen</a>.</blockquote>
<div class="al-api"><b>int <a name="poll_scroll">poll_scroll</a>();</b></div><br>
   This function is used for triple buffering. It checks the status of a 
   hardware scroll previously initiated by the request_scroll() routine.
<p><b>Return value:</b>
   Returns non-zero if it is still waiting to take place, and zero if the
   requested scroll has already happened.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#request_scroll" title="Queues a hardware scroll request with triple buffering.">request_scroll</a>,
<a class="xref" href="#request_video_bitmap" title="Triple buffering page flip request.">request_video_bitmap</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>int <a name="show_video_bitmap">show_video_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap);</b></div><br>
   Attempts to page flip the hardware screen to display the specified video 
   bitmap object, which must be the same size as the physical screen, and 
   should have been obtained by calling the create_video_bitmap() function. 
   
<p>
   Allegro will handle any necessary vertical retrace synchronisation when 
   page flipping, so you don't need to call vsync() before it. This means
   that show_video_bitmap() has the same time delay effects as vsync() by
   default. This can be adjusted with the "disable_vsync" config key in the
   [graphics] section of allegro.cfg. Example:
<blockquote class="code"><pre>
      int current_page;
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *video_page[2];
      ...
      /* Create pages for page flipping */
      video_page[0] = <a href="#create_video_bitmap" class="autotype" title="Creates a video memory bitmap.">create_video_bitmap</a>(<a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
      video_page[1] = <a href="#create_video_bitmap" class="autotype" title="Creates a video memory bitmap.">create_video_bitmap</a>(<a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
      current_page = 0;
      ...
      /* draw the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> and flip pages */
      draw_screen(video_page[current_page]);
      <a href="#show_video_bitmap" class="autotype" title="Flips the hardware screen to use the specified page.">show_video_bitmap</a>(video_page[current_page]);
      current_page = (current_page+1)%2;
      ...</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success and non-zero on failure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#scroll_screen" title="Requests a hardware scroll request.">scroll_screen</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exaccel" title="Using offscreen video memory to store source graphics for VBE/AF.">exaccel</a>,
<a class="eref" href="#exflip" title="Comparison of double buffering and page flipping.">exflip</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>int <a name="request_video_bitmap">request_video_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap);</b></div><br>
   This function is used for triple buffering. It requests a page flip to 
   display the specified video bitmap object, but returns immediately rather 
   than waiting for a retrace. The flip will then take place during the next 
   vertical retrace, but you can carry on running other code in the meantime 
   and use the poll_scroll() routine to detect when the flip has actually 
   taken place. Triple buffering is only possible on certain hardware: see 
   the comments about request_scroll(). Example:
<blockquote class="code"><pre>
      int current_page;
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *video_page[3];
      ...
      /* Create pages for page flipping */
      video_page[0] = <a href="#create_video_bitmap" class="autotype" title="Creates a video memory bitmap.">create_video_bitmap</a>(<a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
      video_page[1] = <a href="#create_video_bitmap" class="autotype" title="Creates a video memory bitmap.">create_video_bitmap</a>(<a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
      video_page[2] = <a href="#create_video_bitmap" class="autotype" title="Creates a video memory bitmap.">create_video_bitmap</a>(<a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
      current_page = 0;
      ...
      /* draw the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> and flip pages */
      draw_screen(video_page[current_page]);
      do {
      } while (<a href="#poll_scroll" class="autotype" title="Checks the status of a scroll request with triple buffering.">poll_scroll</a>());
      <a href="#request_video_bitmap" class="autotype" title="Triple buffering page flip request.">request_video_bitmap</a>(video_page[current_page]);
      current_page = (current_page+1)%3;
      ...</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success and non-zero on failure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#poll_scroll" title="Checks the status of a scroll request with triple buffering.">poll_scroll</a>,
<a class="xref" href="#request_scroll" title="Queues a hardware scroll request with triple buffering.">request_scroll</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#scroll_screen" title="Requests a hardware scroll request.">scroll_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>void <a name="vsync">vsync</a>();</b></div><br>
   Waits for a vertical retrace to begin. The retrace happens when the
   electron beam in your monitor has reached the bottom of the screen and is
   moving back to the top ready for another scan. During this short period
   the graphics card isn't sending any data to the monitor, so you can do
   things to it that aren't possible at other times, such as altering the
   palette without causing flickering (snow). Allegro will automatically
   wait for a retrace before altering the palette or doing any hardware
   scrolling, though, so you don't normally need to bother with this
   function.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#scroll_screen" title="Requests a hardware scroll request.">scroll_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<h1><a name="Bitmap objects">Bitmap objects</a></h1>

<p>
Once you have selected a graphics mode, you can draw things onto the display 
via the <tt>`screen'</tt> bitmap. All the Allegro graphics routines draw onto BITMAP
structures, which are areas of memory containing rectangular images, stored 
as packed byte arrays (in 8-bit modes one byte per pixel, in 15- and 16-bit
modes two bytes per pixel, in 24-bit modes 3 bytes per pixel and in 32-bit
modes 4 bytes per pixel). You can create and manipulate bitmaps in system
RAM, or you can write to the special <tt>`screen'</tt> bitmap which represents the
video memory in your graphics card.

<p>
Read chapter "Direct access to video memory" for information on how to get
direct access to the image memory in a bitmap.

<p>
Allegro supports several different types of bitmaps:
<ul><li>
   The <tt>`screen'</tt> bitmap, which represents the hardware video memory. Ultimately
   you have to draw onto this in order for your image to be visible. It is
   destroyed by any subsequent calls to set_gfx_mode(), so you should never
   attempt to destroy it yourself.
<li>
   Memory bitmaps, which are located in system RAM and can be used to store
   graphics or as temporary drawing spaces for double buffered systems. These
   can be obtained by calling create_bitmap(), load_pcx(), or by loading a
   grabber datafile.
<li>
   Sub-bitmaps. These share image memory with a parent bitmap (which can be
   the screen, a video or system bitmap, a memory bitmap, or another
   sub-bitmap), so drawing onto them will also change their parent. They can
   be of any size and located anywhere within the parent bitmap, and can have
   their own clipping rectangles, so they are a useful way of dividing a
   bitmap into several smaller units, eg. splitting a large virtual screen
   into multiple sections (see examples/exscroll.c).

   Warning: Make sure not to destroy a bitmap before all of its sub-bitmaps,
   otherwise bad things will happen when you try to access one of these
   sub-bitmaps.
<li>
   Video memory bitmaps. These are created by the create_video_bitmap()
   function, and are usually implemented as sub-bitmaps of the screen object.
   They must be destroyed by destroy_bitmap() before any subsequent calls to
   set_gfx_mode().
<li>
   System bitmaps. These are created by the create_system_bitmap() function,
   and are a sort of halfway house between memory and video bitmaps. They
   live in system memory, so you aren't limited by the amount of video ram in
   your card, but they are stored in a platform-specific format that may
   enable better hardware acceleration than is possible with a normal memory
   bitmap (see the GFX_HW_SYS_TO_VRAM_BLIT and GFX_HW_SYS_TO_VRAM_BLIT_MASKED
   flags in gfx_capabilities). System bitmaps must be accessed in the same way
   as video bitmaps, using the bank switch functions and bmp_write*() macros.
   Not every platform implements this type of bitmap: if they aren't
   available, create_system_bitmap() will function identically to
   create_bitmap(). They must be destroyed by destroy_bitmap() before any
   subsequent calls to set_gfx_mode().
</ul>

<p><br>
<div class="al-api"><b>extern <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="screen">screen</a>;</b></div><br>
   Global pointer to a bitmap, sized VIRTUAL_W x VIRTUAL_H. This is created 
   by set_gfx_mode(), and represents the hardware video memory. Only a part 
   of this bitmap will actually be visible, sized SCREEN_W x SCREEN_H. 
   Normally this is the top left corner of the larger virtual screen, so you 
   can ignore the extra invisible virtual size of the bitmap if you aren't 
   interested in hardware scrolling or page flipping. To move the visible 
   window to other parts of the screen bitmap, call scroll_screen(). 
   Initially the clipping rectangle will be limited to the physical screen 
   size, so if you want to draw onto a larger virtual screen space outside 
   this rectangle, you will need to adjust the clipping.

<p>
   For example, to draw a pixel onto the screen you would write:
<blockquote class="code"><pre>
      <a href="#putpixel" class="autotype" title="Writes a pixel into a bitmap.">putpixel</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, x, y, color);
</pre></blockquote>
   Or to implement a double-buffered system:
<blockquote class="code"><pre>
      /* Make a bitmap in RAM. */
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp = <a href="#create_bitmap" class="autotype" title="Creates a memory bitmap.">create_bitmap</a>(320, 200);
      /* Clean the memory bitmap. */
      <a href="#clear_bitmap" class="autotype" title="Clears the bitmap to color 0.">clear_bitmap</a>(bmp);
      /* Draw onto the memory bitmap. */
      <a href="#putpixel" class="autotype" title="Writes a pixel into a bitmap.">putpixel</a>(bmp, x, y, color);
      /* Copy it to the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>. */
      <a href="#blit" class="autotype" title="Copies a rectangular area from one bitmap to another.">blit</a>(bmp, <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, 0, 0, 0, 320, 200);</pre></blockquote>

<p>
   Warning: be very careful when using this pointer at the same time as any
   bitmaps created by the create_video_bitmap() function (see the description
   of this function for more detailed information). And never try to destroy
   it with destroy_bitmap().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#is_screen_bitmap" title="Tells if a bitmap is the screen bitmap or sub bitmap.">is_screen_bitmap</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#scroll_screen" title="Requests a hardware scroll request.">scroll_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>#define <a name="SCREEN_W">SCREEN_W</a>;</b></div><br>
<div class="al-api-cont"><b>#define <a name="SCREEN_H">SCREEN_H</a>;</b></div><br>
   Global defines that return the width and height of the screen, or zero if
   the screen has not been initialised yet. Example:
<blockquote class="code"><pre>
      char buf[100];
      ...
      <a href="#uszprintf" class="autotype" title="Writes formatted data into a buffer, specifying size.">uszprintf</a>(buf, sizeof(buf),
                "The <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> size is %d x %d pixels",
                <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#VIRTUAL_W" title="Global define to obtain the virtual size of the screen.">VIRTUAL_W</a>,
<a class="xref" href="#VIRTUAL_H" title="Global define to obtain the virtual size of the screen.">VIRTUAL_H</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>#define <a name="VIRTUAL_W">VIRTUAL_W</a>;</b></div><br>
<div class="al-api-cont"><b>#define <a name="VIRTUAL_H">VIRTUAL_H</a>;</b></div><br>
   Global defines that return the width and height of the virtual screen, or
   zero if the screen has not been initialised yet. Example:
<blockquote class="code"><pre>
      char buf[100];
      ...
      <a href="#uszprintf" class="autotype" title="Writes formatted data into a buffer, specifying size.">uszprintf</a>(buf, sizeof(buf),
                "The virtual <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> size is %d x %d pixels",
                <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="create_bitmap">create_bitmap</a>(int width, int height);</b></div><br>
   Creates a memory bitmap sized width by height. The bitmap will have
   clipping turned on, and the clipping rectangle set to the full size of the
   bitmap. The image memory will not be cleared, so it will probably contain
   garbage: you should clear the bitmap before using it. This routine always
   uses the global pixel format, as specified by calling set_color_depth().
   The minimum height of the BITMAP must be 1 and width can't be negative.
   Example:
<blockquote class="code"><pre>
      /* Create a 10 pixel tall bitmap, as wide as the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>. */
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp = <a href="#create_bitmap" class="autotype" title="Creates a memory bitmap.">create_bitmap</a>(<a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, 10);
      if (!bmp)
         abort_on_error("Couldn't create bitmap!");
      /* Use the bitmap. */
      ...
      /* Destroy it when we don't need it any more. */
      <a href="#destroy_bitmap" class="autotype" title="Destroys any type of created bitmap.">destroy_bitmap</a>(bmp);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the created bitmap, or NULL if the bitmap could not
   be created. Remember to free this bitmap later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#create_system_bitmap" title="Creates a system memory bitmap.">create_system_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#is_memory_bitmap" title="Tells if a bitmap is a memory bitmap.">is_memory_bitmap</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="create_bitmap_ex">create_bitmap_ex</a>(int color_depth, int width, int height);</b></div><br>
   Creates a bitmap in a specific color depth (8, 15, 16, 24 or 32 bits per 
   pixel). Example:
<blockquote class="code"><pre>
      /* Create <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> sized bitmap in 32 bits per pixel. */
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp = <a href="#create_bitmap_ex" class="autotype" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>(32, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
      if (!bmp)
         abort_on_error("Couldn't create bitmap!");
      /* Use the bitmap. */
      ...
      /* Destroy it when we don't need it any more. */
      <a href="#destroy_bitmap" class="autotype" title="Destroys any type of created bitmap.">destroy_bitmap</a>(bmp);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the created bitmap, or NULL if the bitmap could not
   be created. Remember to free this bitmap later to avoid memory leaks.
   


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#create_system_bitmap" title="Creates a system memory bitmap.">create_system_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#is_memory_bitmap" title="Tells if a bitmap is a memory bitmap.">is_memory_bitmap</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="create_sub_bitmap">create_sub_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *parent, int x, y, width, height);</b></div><br>
   Creates a sub-bitmap, ie. a bitmap sharing drawing memory with a 
   pre-existing bitmap, but possibly with a different size and clipping 
   settings. When creating a sub-bitmap of the mode-X screen, the x position 
   must be a multiple of four. The sub-bitmap width and height can extend 
   beyond the right and bottom edges of the parent (they will be clipped), 
   but the origin point must lie within the parent region.
<p><b>Return value:</b>
   Returns a pointer to the created sub bitmap, or NULL if the sub bitmap
   could not be created. Remember to free the sub bitmap before freeing
   the parent bitmap to avoid memory leaks and potential crashes accessing
   memory which has been freed.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#is_sub_bitmap" title="Tells if a bitmap is a sub bitmap.">is_sub_bitmap</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>,
<a class="eref" href="#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="create_video_bitmap">create_video_bitmap</a>(int width, int height);</b></div><br>
   Allocates a video memory bitmap of the specified size. This can be used
   to allocate offscreen video memory for storing source graphics ready for
   a hardware accelerated blitting operation, or to create multiple video
   memory pages which can then be displayed by calling show_video_bitmap().
   Read the introduction of this chapter for a comparison with other types
   of bitmaps and other specific details.

<p>
   Warning: video memory bitmaps are usually allocated from the same space
   as the screen bitmap, so they may overlap with it; it is therefore not
   a good idea to use the global screen at the same time as any surfaces
   returned by this function.
<p><b>Return value:</b>
   Returns a pointer to the bitmap on success, or NULL if you have run out
   of video ram. Remember to destroy this bitmap before any subsequent
   call to set_gfx_mode().
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#create_system_bitmap" title="Creates a system memory bitmap.">create_system_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#show_video_bitmap" title="Flips the hardware screen to use the specified page.">show_video_bitmap</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#is_video_bitmap" title="Tells if a bitmap is a screen bitmap, video memory or sub bitmap.">is_video_bitmap</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exaccel" title="Using offscreen video memory to store source graphics for VBE/AF.">exaccel</a>,
<a class="eref" href="#exflip" title="Comparison of double buffering and page flipping.">exflip</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="create_system_bitmap">create_system_bitmap</a>(int width, int height);</b></div><br>
   Allocates a system memory bitmap of the specified size. Read the
   introduction of this chapter for a comparison with other types of bitmaps
   and other specific details.
<p><b>Return value:</b>
   Returns a pointer to the bitmap on success, NULL otherwise. Remember to
   destroy this bitmap before any subsequent call to set_gfx_mode().
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#is_system_bitmap" title="Tells if a bitmap is a system bitmap or sub bitmap.">is_system_bitmap</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_bitmap">destroy_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap);</b></div><br>
   Destroys a memory bitmap, sub-bitmap, video memory bitmap, or system 
   bitmap when you are finished with it. If you pass a NULL pointer this
   function won't do anything. See above for the restrictions as to when you
   are allowed to destroy the various types of bitmaps.

<p>
   The bitmap must not have a mouse cursor shown on it at the time it is
   destroyed.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="lock_bitmap">lock_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap);</b></div><br>
   Under DOS, locks all the memory used by a bitmap. You don't normally need
   to call this function unless you are doing very weird things in your
   program.

<p><br>
<div class="al-api"><b>int <a name="bitmap_color_depth">bitmap_color_depth</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns the color depth of the specified bitmap (8, 15, 16, 24, or 32).
   Example:
<blockquote class="code"><pre>
      switch (<a href="#bitmap_color_depth" class="autotype" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>)) {
         case 8:
            /* Access <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> using optimized 8-bit code. */
            break;
         default:
            /* Use generic slow functions. */
            break;
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>int <a name="bitmap_mask_color">bitmap_mask_color</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns the mask color for the specified bitmap (the value which is 
   skipped when drawing sprites). For 256-color bitmaps this is zero, and 
   for truecolor bitmaps it is bright pink (maximum red and blue, zero
   green). A frequent use of this function is to clear a bitmap with the mask
   color so you can later use this bitmap with masked_blit() or
   draw_sprite() after drawing other stuff on it. Example:
<blockquote class="code"><pre>
      /* Replace mask color with another color. */
      for (y = 0; y < bmp->h; y++)
         for (x = 0; x < bmp->w; x++)
            if (<a href="#getpixel" class="autotype" title="Reads a pixel from a bitmap.">getpixel</a>(bmp, x, y) == <a href="#bitmap_mask_color" class="autotype" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>(bmp))
               <a href="#putpixel" class="autotype" title="Writes a pixel into a bitmap.">putpixel</a>(bmp, x, y, another_color);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#MASK_COLOR_8" title="Constant representing the mask value in sprites.">MASK_COLOR_8</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exmouse" title="Getting input from the mouse.">exmouse</a>,
<a class="eref" href="#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>.</blockquote>
<div class="al-api"><b>int <a name="is_same_bitmap">is_same_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp1, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp2);</b></div><br>
   Returns TRUE if the two bitmaps describe the same drawing surface, ie. 
   the pointers are equal, one is a sub-bitmap of the other, or they are 
   both sub-bitmaps of a common parent.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_planar_bitmap">is_planar_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is a planar (mode-X or Xtended mode) screen bitmap.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#is_linear_bitmap" title="Tells if a bitmap is linear.">is_linear_bitmap</a>,
<a class="xref" href="#is_memory_bitmap" title="Tells if a bitmap is a memory bitmap.">is_memory_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_linear_bitmap">is_linear_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is a linear bitmap, i.e. a bitmap that can be accessed
   linearly within each scanline (for example a memory bitmap, the DOS VGA
   or SVGA screen, Windows bitmaps, etc). Linear bitmaps can be used with the
   _putpixel(), _getpixel(), bmp_write_line(), and bmp_read_line() functions.

<p>
   Historically there were only linear and planar bitmaps for Allegro, so
   is_linear_bitmap() is actually an alias for !is_planar_bitmap().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#is_planar_bitmap" title="Tells if a bitmap is a planar screen bitmap.">is_planar_bitmap</a>,
<a class="xref" href="#is_memory_bitmap" title="Tells if a bitmap is a memory bitmap.">is_memory_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_memory_bitmap">is_memory_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is a memory bitmap, ie. it was created by calling 
   create_bitmap() or loaded from a grabber datafile or image file. Memory 
   bitmaps can be accessed directly via the line pointers in the bitmap 
   structure, eg. bmp-&gt;line[y][x] = color.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#is_linear_bitmap" title="Tells if a bitmap is linear.">is_linear_bitmap</a>,
<a class="xref" href="#is_planar_bitmap" title="Tells if a bitmap is a planar screen bitmap.">is_planar_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_screen_bitmap">is_screen_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is the screen bitmap, or a sub-bitmap of the screen.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_video_bitmap">is_video_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is the screen bitmap, a video memory bitmap, or a 
   sub-bitmap of either.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_system_bitmap">is_system_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is a system bitmap object, or a sub-bitmap of one.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_system_bitmap" title="Creates a system memory bitmap.">create_system_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_sub_bitmap">is_sub_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is a sub-bitmap.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>.</blockquote>
<div class="al-api"><b>void <a name="acquire_bitmap">acquire_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Acquires the specified video bitmap prior to drawing onto it. You never need
   to call the function explicitly as it is low level, and will only give you a
   speed up if you know what you are doing. Using it wrongly may cause slowdown,
   or even lock up your program.

<p>
   Note: You do never need to use acquire_bitmap on a memory bitmap, i.e. a
   normal bitmap created with create_bitmap. It will simply do nothing in that
   case.

<p>
   It still can be useful, because e.g. under the current DirectDraw driver of
   Allegro, most drawing functions need to lock a video bitmap before drawing to
   it. But doing this is very slow, so you will get much better performance if
   you acquire the screen just once at the start of your main redraw function,
   then call multiple drawing operations which need the bitmap locked, and only
   release it when done.

<p>
   Multiple acquire calls may be nested, but you must make sure to match up the
   acquire_bitmap and release_bitmap calls. Be warned that DirectX and X11
   programs activate a mutex lock whenever a surface is locked, which prevents
   them from getting any input messages, so you must be sure to release all your
   bitmaps before using any timer, keyboard, or other non-graphics routines!

<p>
   Note that if you are using hardware accelerated VRAM-&gt;VRAM functions, you
   should not call acquire_bitmap(). Such functions need an unlocked target
   bitmap under DirectX, so there is now just the opposite case from before - if
   the bitmap is already locked with acquire_bitmap, the drawing
   operation has to unlock it.

<p>
   Note: For backwards compatibility, the unlocking behavior of such functions
   is permanent. That is, if you call acquire_bitmap first, then call e.g. an
   accelerated blit, the DirectX bitmap will be unlocked internally (it won't
   affect the nesting counter of acquire/release calls).

<p>
   There is no clear cross-platform way in this Allegro version to know which
   drawing operations need a locked/unlocked state. For example a normal
   rectfill most probably is accelerated under DirectX, and therefore needs the
   screen unlocked, but an XOR rectfill, or one with blending activated, most
   probably is not, and therefore locks the screen. And while the DirectX driver
   will do automatic unlocking, there is no such thing under X11, where the
   function is used to synchronize X11 calls from different threads. Your best
   bet is to never use acquire_bitmap - changes are you are doing something in
   the wrong way if you think you need it.

<p>
   Warning: This function can be very dangerous to use, since the whole program
   may get locked while the bitmap is locked. So the lock should only be held
   for a short time, and you should not call anything but drawing operations
   onto the locked video bitmap while a lock is in place. Especially don't call
   things like show_mouse (or scare_mouse which calls that) or readkey, since
   it will most likely deadlock your entire program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exaccel" title="Using offscreen video memory to store source graphics for VBE/AF.">exaccel</a>,
<a class="eref" href="#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>,
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>,
<a class="eref" href="#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>void <a name="release_bitmap">release_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Releases a bitmap that was previously locked by calling acquire_bitmap(). 
   If the bitmap was locked multiple times, you must release it the same 
   number of times before it will truly be unlocked.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exaccel" title="Using offscreen video memory to store source graphics for VBE/AF.">exaccel</a>,
<a class="eref" href="#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>,
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>,
<a class="eref" href="#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>void <a name="acquire_screen">acquire_screen</a>();</b></div><br>
   Shortcut version of acquire_bitmap(screen);


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="release_screen">release_screen</a>();</b></div><br>
   Shortcut version of release_bitmap(screen);


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="set_clip_rect">set_clip_rect</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int x1, int y1, int x2, int y2);</b></div><br>
   Each bitmap has an associated clipping rectangle, which is the area of 
   the image that it is OK to draw onto. Nothing will be drawn to positions
   outside this space. This function sets the clipping rectangle for the
   specified bitmap. Pass the coordinates of the top-left and bottom-right
   corners of the clipping rectangle in this order; these are both inclusive,
   i.e. set_clip_rect(bitmap, 16, 16, 32, 32) will allow drawing to (16, 16)
   and (32, 32), but not to (15, 15) and (33, 33).

<p>
   Drawing operations will be performed (at least partially) on the bitmap as
   long as the first coordinates of its clipping rectangle are not greater
   than the second coordinates and its intersection with the actual image
   is non-empty. If either condition is not fulfilled, drawing will be turned
   off for the bitmap, e.g.
<blockquote class="code"><pre>
      <a href="#set_clip_rect" class="autotype" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>(bmp, 0, 0, -1, -1); /* disable drawing on bmp */</pre></blockquote>

<p>
   Note that passing "out-of-bitmap" coordinates is allowed, but they are
   likely to be altered (and so the coordinates returned by get_clip_rect()
   will be different). However, such modifications are guaranteed to preserve
   the external effect of the clipping rectangle, that is not to modify the
   actual area of the image that it is OK to draw onto.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_clip_rect" title="Returns the clipping rectangle of a bitmap.">get_clip_rect</a>,
<a class="xref" href="#add_clip_rect" title="Intersects a bitmap's clipping rectangle with the given area.">add_clip_rect</a>,
<a class="xref" href="#set_clip_state" title="Turns on or off the clipping of a bitmap.">set_clip_state</a>,
<a class="xref" href="#get_clip_state" title="Tells if clipping is on for a bitmap.">get_clip_state</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>.</blockquote>
<div class="al-api"><b>void <a name="get_clip_rect">get_clip_rect</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int *x1, int *y1, int *x2, int *y2);</b></div><br>
   Returns the clipping rectangle for the specified bitmap.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#add_clip_rect" title="Intersects a bitmap's clipping rectangle with the given area.">add_clip_rect</a>,
<a class="xref" href="#set_clip_state" title="Turns on or off the clipping of a bitmap.">set_clip_state</a>,
<a class="xref" href="#get_clip_state" title="Tells if clipping is on for a bitmap.">get_clip_state</a>.</blockquote>
<div class="al-api"><b>void <a name="add_clip_rect">add_clip_rect</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int x1, int y1, int x2, int y2);</b></div><br>
   Sets the clipping rectangle of the specified bitmap as the intersection of
   its current clipping rectangle and the rectangle described by the four
   coordinates.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#get_clip_rect" title="Returns the clipping rectangle of a bitmap.">get_clip_rect</a>,
<a class="xref" href="#set_clip_state" title="Turns on or off the clipping of a bitmap.">set_clip_state</a>,
<a class="xref" href="#get_clip_state" title="Tells if clipping is on for a bitmap.">get_clip_state</a>.</blockquote>
<div class="al-api"><b>void <a name="set_clip_state">set_clip_state</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int state)</b></div><br>
   Turns on (if state is non-zero) or off (if state is zero) clipping for the
   specified bitmap. Turning clipping off may slightly speed up some drawing
   operations (usually a negligible  difference, although every little helps)
   but will result in your program dying a horrible death if you try to draw
   beyond the edges of the bitmap.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#get_clip_rect" title="Returns the clipping rectangle of a bitmap.">get_clip_rect</a>,
<a class="xref" href="#add_clip_rect" title="Intersects a bitmap's clipping rectangle with the given area.">add_clip_rect</a>,
<a class="xref" href="#get_clip_state" title="Tells if clipping is on for a bitmap.">get_clip_state</a>.</blockquote>
<div class="al-api"><b>int <a name="get_clip_state">get_clip_state</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap)</b></div><br>
   Returns non-zero if clipping is turned on for the specified bitmap and
   zero otherwise.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#get_clip_rect" title="Returns the clipping rectangle of a bitmap.">get_clip_rect</a>,
<a class="xref" href="#add_clip_rect" title="Intersects a bitmap's clipping rectangle with the given area.">add_clip_rect</a>,
<a class="xref" href="#set_clip_state" title="Turns on or off the clipping of a bitmap.">set_clip_state</a>.</blockquote>
<div class="al-api"><b>int <a name="is_inside_bitmap">is_inside_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int clip);</b></div><br>
   Returns non-zero if point (x, y) lies inside the bitmap. If <tt>`clip'</tt> is
   non-zero, the function compares the coordinates with the clipping
   rectangle, that is it returns non-zero if the point lies inside the
   clipping rectangle or if clipping is disabled for the bitmap. If <tt>`clip'</tt>
   is zero, the function compares the coordinates with the actual dimensions
   of the bitmap.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#set_clip_state" title="Turns on or off the clipping of a bitmap.">set_clip_state</a>,
<a class="xref" href="#getpixel" title="Reads a pixel from a bitmap.">getpixel</a>.</blockquote>
<h1><a name="Loading image files">Loading image files</a></h1>

<p>
Warning: when using truecolor images, you should always set the graphics
mode before loading any bitmap data! Otherwise the pixel format (RGB or BGR)
will not be known, so the file may be converted wrongly.

<p><br>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="load_bitmap">load_bitmap</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   Loads a bitmap from a file. The palette data will be stored in the second
   parameter, which should be an array of 256 RGB structures. At present this
   function supports BMP, LBM, PCX, and TGA files, determining the type from
   the file extension.

<p>
   If the file contains a truecolor image, you must set the video mode or
   call set_color_conversion() before loading it. In this case, if the
   destination color depth is 8-bit, the palette will be generated by calling
   generate_optimized_palette() on the bitmap; otherwise, the returned
   palette will be generated by calling generate_332_palette().

<p>
   The pal argument may be NULL. In this case, the palette data are simply
   not returned. Additionally, if the file is a truecolor image and the
   destination color depth is 8-bit, the color conversion process will use
   the current palette instead of generating an optimized one.

<p>
   Example:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;
      <a href="#PALETTE" class="autotype" title="Stores palette information.">PALETTE</a> palette;
      ...
      bmp = <a href="#load_bitmap" class="autotype" title="Loads any supported bitmap from a file.">load_bitmap</a>("image.pcx", palette);
      if (!bmp)
         abort_on_error("Couldn't load image.pcx!");
      ...
      <a href="#destroy_bitmap" class="autotype" title="Destroys any type of created bitmap.">destroy_bitmap</a>(bmp);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the bitmap or NULL on error. Remember that you are
   responsible for destroying the bitmap when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_bmp" title="Loads a BMP bitmap from a file.">load_bmp</a>,
<a class="xref" href="#load_lbm" title="Loads an LBM bitmap from a file.">load_lbm</a>,
<a class="xref" href="#load_pcx" title="Loads a PCX bitmap from a file.">load_pcx</a>,
<a class="xref" href="#load_tga" title="Loads a TGA bitmap from a file.">load_tga</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#save_bitmap" title="Saves a bitmap into any supported file format.">save_bitmap</a>,
<a class="xref" href="#register_bitmap_file_type" title="Registers custom bitmap loading/saving functions.">register_bitmap_file_type</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#generate_optimized_palette" title="Generates an optimized palette for a bitmap.">generate_optimized_palette</a>,
<a class="xref" href="#generate_332_palette" title="Constructs a fake truecolor palette.">generate_332_palette</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exaccel" title="Using offscreen video memory to store source graphics for VBE/AF.">exaccel</a>,
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#exbitmap" title="Loading and displaying PCX and BMP files.">exbitmap</a>,
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>,
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>,
<a class="eref" href="#exxfade" title="Truecolor image loading and fades.">exxfade</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="load_bmp">load_bmp</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   Loads an 8-bit, 16-bit, 24-bit or 32-bit Windows or OS/2 BMP file.
<p><b>Return value:</b>
   Returns a pointer to the bitmap or NULL on error. Remember that you are
   responsible for destroying the bitmap when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#load_bmp_pf" title="Packfile version of load_bmp.">load_bmp_pf</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="load_bmp_pf">load_bmp_pf</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   A version of load_bmp() which reads from a packfile. Example:
<blockquote class="code"><pre>
      <a href="#PACKFILE" class="autotype" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *packfile;
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;

      packfile = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>("mybitmap.bmp", F_READ);
      if (!packfile)
         abort_on_error("Couldn't open mybitmap.bmp");
         
      bmp = <a href="#load_bmp_pf" class="autotype" title="Packfile version of load_bmp.">load_bmp_pf</a>(packfile, pal);
      if (!bmp)
         abort_on_error("Error loading mybitmap.bmp");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the bitmap or NULL on error. Remember that you are
   responsible for destroying the bitmap when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_bmp" title="Loads a BMP bitmap from a file.">load_bmp</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="load_lbm">load_lbm</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   Loads a 256-color IFF ILBM/PBM file.
<p><b>Return value:</b>
   Returns a pointer to the bitmap or NULL on error. Remember that you are
   responsible for destroying the bitmap when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="load_pcx">load_pcx</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   Loads a 256-color or 24-bit truecolor PCX file.
<p><b>Return value:</b>
   Returns a pointer to the bitmap or NULL on error. Remember that you are
   responsible for destroying the bitmap when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>,
<a class="eref" href="#exscale" title="Loading PCX files and bitmap stretching.">exscale</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="load_pcx_pf">load_pcx_pf</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   A version of load_pcx() which reads from a packfile. Example:
<blockquote class="code"><pre>
      <a href="#PACKFILE" class="autotype" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *packfile;
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;

      packfile = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>("mybitmap.pcx", F_READ);
      if (!packfile)
         abort_on_error("Couldn't open mybitmap.pcx");
         
      bmp = <a href="#load_bmp_pf" class="autotype" title="Packfile version of load_bmp.">load_bmp_pf</a>(packfile, pal);
      if (!bmp)
         abort_on_error("Error loading mybitmap.pcx");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the bitmap or NULL on error. Remember that you are
   responsible for destroying the bitmap when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_pcx" title="Loads a PCX bitmap from a file.">load_pcx</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="load_tga">load_tga</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   Loads a 256-color, 15-bit hicolor, 24-bit truecolor, or 32-bit 
   truecolor+alpha TGA file.
<p><b>Return value:</b>
   Returns a pointer to the bitmap or NULL on error. Remember that you are
   responsible for destroying the bitmap when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="load_tga_pf">load_tga_pf</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   A version of load_tga() which reads from a packfile. Example:
<blockquote class="code"><pre>
      <a href="#PACKFILE" class="autotype" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *packfile;
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;

      packfile = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>("mybitmap.tga", F_READ);
      if (!packfile)
         abort_on_error("Couldn't open mybitmap.tga");
         
      bmp = <a href="#load_bmp_pf" class="autotype" title="Packfile version of load_bmp.">load_bmp_pf</a>(packfile, pal);
      if (!bmp)
         abort_on_error("Error loading mybitmap.tga");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the bitmap or NULL on error. Remember that you are
   responsible for destroying the bitmap when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_tga" title="Loads a TGA bitmap from a file.">load_tga</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>int <a name="save_bitmap">save_bitmap</a>(const char *filename, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   Writes a bitmap into a file, using the specified palette, which should be 
   an array of 256 RGB structures. The output format is determined from the
   filename extension: at present this function supports BMP, PCX and TGA
   formats.

<p>
   Two things to watch out for: on some video cards it may be faster to copy
   the screen to a memory bitmap and save the latter, and if you use this to
   dump the screen into a file you may end up with an image much larger than
   you were expecting, because Allegro often creates virtual screens larger
   than the visible screen. You can get around this by using a sub-bitmap to
   specify which part of the screen to save, eg:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;
      <a href="#PALETTE" class="autotype" title="Stores palette information.">PALETTE</a> pal;
      ...
      <a href="#get_palette" class="autotype" title="Retrieves the entire palette of 256 colors.">get_palette</a>(pal);
      bmp = <a href="#create_sub_bitmap" class="autotype" title="Creates a memory sub bitmap.">create_sub_bitmap</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, 0, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
      <a href="#save_bitmap" class="autotype" title="Saves a bitmap into any supported file format.">save_bitmap</a>("dump.pcx", bmp, pal);
      <a href="#destroy_bitmap" class="autotype" title="Destroys any type of created bitmap.">destroy_bitmap</a>(bmp);</pre></blockquote>
<p><b>Return value:</b>
   Returns non-zero on error.
      

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#save_bmp" title="Saves a bitmap into a BMP file.">save_bmp</a>,
<a class="xref" href="#save_pcx" title="Saves a bitmap into a PCX file.">save_pcx</a>,
<a class="xref" href="#save_tga" title="Saves a bitmap into a TGA file.">save_tga</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#register_bitmap_file_type" title="Registers custom bitmap loading/saving functions.">register_bitmap_file_type</a>.</blockquote>
<div class="al-api"><b>int <a name="save_bmp">save_bmp</a>(const char *filename, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   Writes a bitmap into a 256-color or 24-bit truecolor BMP file.
<p><b>Return value:</b>
   Returns non-zero on error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#save_bitmap" title="Saves a bitmap into any supported file format.">save_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="save_bmp_pf">save_bmp_pf</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   A version of save_bmp which writes to a packfile.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#save_bmp" title="Saves a bitmap into a BMP file.">save_bmp</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>int <a name="save_pcx">save_pcx</a>(const char *filename, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   Writes a bitmap into a 256-color or 24-bit truecolor PCX file.
<p><b>Return value:</b>
   Returns non-zero on error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#save_bitmap" title="Saves a bitmap into any supported file format.">save_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="save_pcx_pf">save_pcx_pf</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   A version of save_pcx which writes to a packfile.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#save_pcx" title="Saves a bitmap into a PCX file.">save_pcx</a>.</blockquote>
<div class="al-api"><b>int <a name="save_tga">save_tga</a>(const char *filename, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   Writes a bitmap into a 256-color, 15-bit hicolor, 24-bit truecolor, or
   32-bit truecolor+alpha TGA file.
<p><b>Return value:</b>
   Returns non-zero on error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#save_bitmap" title="Saves a bitmap into any supported file format.">save_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="save_tga_pf">save_tga_pf</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal);</b></div><br>
   A version of save_tga which writes to a packfile.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#save_tga" title="Saves a bitmap into a TGA file.">save_tga</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>void <a name="register_bitmap_file_type">register_bitmap_file_type</a>(const char *ext,
          <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *(*load)(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal),
          int (*save)(const char *filename, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal));</b></div><br>
   Informs the load_bitmap() and save_bitmap() functions of a new file type, 
   providing routines to read and write images in this format (either 
   function may be NULL). The functions you supply must follow the same
   prototype as load_bitmap() and save_bitmap(). Example:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *load_dump(const char *filename, <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a> *pal)
      {
         ...
      }
      
      int save_dump(const char *filename, <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a> *pal)
      {
         ...
      }

         <a href="#register_bitmap_file_type" class="autotype" title="Registers custom bitmap loading/saving functions.">register_bitmap_file_type</a>("dump", load_dump, save_dump);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#save_bitmap" title="Saves a bitmap into any supported file format.">save_bitmap</a>.</blockquote>
<div class="al-api"><b>void <a name="set_color_conversion">set_color_conversion</a>(int mode);</b></div><br>
   Specifies how to convert images between the various color depths when 
   reading graphics from external bitmap files or datafiles. The mode is a 
   bitmask specifying which types of conversion are allowed. If the 
   appropriate bit is set, data will be converted into the current pixel 
   format (selected by calling the set_color_depth() function), otherwise it 
   will be left in the same format as the disk file, leaving you to convert 
   it manually before the graphic can be displayed. The default mode is 
   total conversion, so that all images will be loaded in the appropriate
   format for the current video mode. Valid bit flags are:
<blockquote class="text"><pre>
      COLORCONV_NONE                // disable all format
                                    // conversions
      COLORCONV_8_TO_15             // expand 8-bit to 15-bit
      COLORCONV_8_TO_16             // expand 8-bit to 16-bit
      COLORCONV_8_TO_24             // expand 8-bit to 24-bit
      COLORCONV_8_TO_32             // expand 8-bit to 32-bit
      COLORCONV_15_TO_8             // reduce 15-bit to 8-bit
      COLORCONV_15_TO_16            // expand 15-bit to 16-bit
      COLORCONV_15_TO_24            // expand 15-bit to 24-bit
      COLORCONV_15_TO_32            // expand 15-bit to 32-bit
      COLORCONV_16_TO_8             // reduce 16-bit to 8-bit
      COLORCONV_16_TO_15            // reduce 16-bit to 15-bit
      COLORCONV_16_TO_24            // expand 16-bit to 24-bit
      COLORCONV_16_TO_32            // expand 16-bit to 32-bit
      COLORCONV_24_TO_8             // reduce 24-bit to 8-bit
      COLORCONV_24_TO_15            // reduce 24-bit to 15-bit
      COLORCONV_24_TO_16            // reduce 24-bit to 16-bit
      COLORCONV_24_TO_32            // expand 24-bit to 32-bit
      COLORCONV_32_TO_8             // reduce 32-bit RGB to 8-bit
      COLORCONV_32_TO_15            // reduce 32-bit RGB to 15-bit
      COLORCONV_32_TO_16            // reduce 32-bit RGB to 16-bit
      COLORCONV_32_TO_24            // reduce 32-bit RGB to 24-bit
      COLORCONV_32A_TO_8            // reduce 32-bit RGBA to 8-bit
      COLORCONV_32A_TO_15           // reduce 32-bit RGBA to 15-bit
      COLORCONV_32A_TO_16           // reduce 32-bit RGBA to 16-bit
      COLORCONV_32A_TO_24           // reduce 32-bit RGBA to 24-bit
      COLORCONV_DITHER_PAL          // dither when reducing to 8-bit
      COLORCONV_DITHER_HI           // dither when reducing to
                                    // hicolor
      COLORCONV_KEEP_TRANS          // keep original transparency
</pre></blockquote>
   For convenience, the following macros can be used to select common 
   combinations of these flags:
<blockquote class="text"><pre>
      COLORCONV_EXPAND_256          // expand 256-color to hi/truecolor
      COLORCONV_REDUCE_TO_256       // reduce hi/truecolor to 256-color
      COLORCONV_EXPAND_15_TO_16     // expand 15-bit hicolor to 16-bit
      COLORCONV_REDUCE_16_TO_15     // reduce 16-bit hicolor to 15-bit
      COLORCONV_EXPAND_HI_TO_TRUE   // expand 15/16-bit to 24/32-bit
      COLORCONV_REDUCE_TRUE_TO_HI   // reduce 24/32-bit to 15/16-bit
      COLORCONV_24_EQUALS_32        // convert between 24- and 32-bit
      COLORCONV_TOTAL               // everything to current format
      COLORCONV_PARTIAL             // convert 15 &lt;-&gt; 16-bit and
                                    // 24 &lt;-&gt; 32-bit
      COLORCONV_MOST                // all but hi/truecolor &lt;-&gt; 256
      COLORCONV_DITHER              // dither during all color reductions
      COLORCONV_KEEP_ALPHA          // convert everything to current format
                                    // unless it would lose alpha information
</pre></blockquote>
   If you enable the COLORCONV_DITHER flag, dithering will be performed 
   whenever truecolor graphics are converted into a hicolor or paletted 
   format, including by the blit() function, and any automatic conversions 
   that take place while reading graphics from disk. This can produce much 
   better looking results, but is obviously slower than a direct conversion.

<p>
   If you intend using converted bitmaps with functions like masked_blit() 
   or draw_sprite(), you should specify the COLORCONV_KEEP_TRANS flag. It 
   will ensure that the masked areas in the bitmap before and after the 
   conversion stay exactly the same, by mapping transparent colors to each 
   other and adjusting colors which would be converted to the transparent 
   color otherwise. It affects every blit() operation between distinct pixel 
   formats and every automatic conversion.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#fixup_datafile" title="Fixes truecolor images in compiled datafiles.">fixup_datafile</a>,
<a class="xref" href="#makecol15_dither" title="Calculates a dithered 15 or 16-bit RGB value.">makecol15_dither</a>,
<a class="xref" href="#get_color_conversion" title="Returns the current color conversion mode.">get_color_conversion</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>,
<a class="eref" href="#exdata" title="Accessing the contents of datafiles.">exdata</a>,
<a class="eref" href="#exexedat" title="Appending datafiles onto your executable.">exexedat</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exxfade" title="Truecolor image loading and fades.">exxfade</a>.</blockquote>
<div class="al-api"><b>int <a name="get_color_conversion">get_color_conversion</a>();</b></div><br>
   Returns the current color conversion mode.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>.</blockquote>
<h1><a name="Palette routines">Palette routines</a></h1>

<p>
All the Allegro drawing functions use integer parameters to represent 
colors. In truecolor resolutions these numbers encode the color directly as 
a collection of red, green, and blue bits, but in a regular 256-color mode 
the values are treated as indexes into the current palette, which is a table 
listing the red, green and blue intensities for each of the 256 possible 
colors.

<p>
Palette entries are stored in an RGB structure, which contains red, green 
and blue intensities in the VGA hardware format, ranging from 0-63, and is 
defined as:
<blockquote class="code"><pre>
   typedef struct <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a>
   {
      unsigned char r, g, b;
   } <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a>;
</pre></blockquote>
It contains an additional field for the purpose of padding but you should
not usually care about it. For example:
<blockquote class="code"><pre>
   <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a> black = { 0,  0,  0  };
   <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a> white = { 63, 63, 63 };
   <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a> green = { 0,  63, 0  };
   <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a> grey  = { 32, 32, 32 };
</pre></blockquote>
The type PALETTE is defined to be an array of PAL_SIZE RGB structures, where
PAL_SIZE is a preprocessor constant equal to 256.

<p>
You may notice that a lot of the code in Allegro spells 'palette' as 
'pallete'. This is because the headers from my old Mark Williams compiler on 
the Atari spelt it with two l's, so that is what I'm used to. Allegro will 
happily accept either spelling, due to some #defines in allegro/alcompat.h
(which can be turned off by defining the ALLEGRO_NO_COMPATIBILITY symbol
before including Allegro headers).

<p><br>
<div class="al-api"><b>void <a name="set_color">set_color</a>(int index, const <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *p);</b></div><br>
   Sets the specified palette entry to the specified RGB triplet. Unlike the 
   other palette functions this doesn't do any retrace synchronisation, so 
   you should call vsync() before it to prevent snow problems. Example:
<blockquote class="code"><pre>
      <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a> rgb;
      ...
      <a href="#vsync" class="autotype" title="Waits for a vertical retrace to begin.">vsync</a>();
      <a href="#set_color" class="autotype" title="Sets the specified palette entry to the specified RGB triplet.">set_color</a>(192, &amp;rgb);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#get_color" title="Retrieves the specified palette entry.">get_color</a>,
<a class="xref" href="#_set_color" title="Inline version of set_color().">_set_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>,
<a class="eref" href="#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>.</blockquote>
<div class="al-api"><b>void <a name="_set_color">_set_color</a>(int index, const <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *p);</b></div><br>
   This is an inline version of set_color(), intended for use in the
   vertical retrace simulator callback function (retrace_proc, which is now
   deprecated).

<p>
   If you really must use _set_color from retrace_proc, note that it should
   only be used under DOS, in VGA mode 13h and mode-X. Some SVGA chipsets
   aren't VGA compatible (set_color() and set_palette() will use VESA calls on
   these cards, but _set_color() doesn't know about that).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_color" title="Sets the specified palette entry to the specified RGB triplet.">set_color</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>.</blockquote>
<div class="al-api"><b>void <a name="set_palette">set_palette</a>(const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> p);</b></div><br>
   Sets the entire palette of 256 colors. You should provide an array of 256 
   RGB structures. Unlike set_color(), there is no need to call vsync() 
   before this function. Example:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;
      <a href="#PALETTE" class="autotype" title="Stores palette information.">PALETTE</a> palette;
      ...
      bmp = <a href="#load_bitmap" class="autotype" title="Loads any supported bitmap from a file.">load_bitmap</a>(filename, palette);
      if (!bmp)
         abort_on_error("Couldn't load bitmap!");
      <a href="#set_palette" class="autotype" title="Sets the entire palette of 256 colors.">set_palette</a>(palette);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette_range" title="Sets a specific range of the palette.">set_palette_range</a>,
<a class="xref" href="#set_color" title="Sets the specified palette entry to the specified RGB triplet.">set_color</a>,
<a class="xref" href="#get_palette" title="Retrieves the entire palette of 256 colors.">get_palette</a>,
<a class="xref" href="#select_palette" title="Sets the internal palette for color conversion.">select_palette</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="set_palette_range">set_palette_range</a>(const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> p, int from, int to, int vsync);</b></div><br>
   Sets the palette entries between from and to (inclusive: pass 0 and 255 
   to set the entire palette). If vsync is set it waits for the vertical 
   retrace, otherwise it sets the colors immediately. Example:
<blockquote class="code"><pre>
      <a href="#PALETTE" class="autotype" title="Stores palette information.">PALETTE</a> palette;
      ...
      /* Modify the first 16 entries. */
      change_first_16_colors(palette);
      /* Now update them waiting for <a href="#vsync" class="autotype" title="Waits for a vertical retrace to begin.">vsync</a>. */
      <a href="#set_palette_range" class="autotype" title="Sets a specific range of the palette.">set_palette_range</a>(palette, 0, 15, 1);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#get_palette_range" title="Retrieves a specific palette range.">get_palette_range</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>void <a name="get_color">get_color</a>(int index, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *p);</b></div><br>
   Retrieves the specified palette entry. Example:
<blockquote class="code"><pre>
      <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a> color;
      ...
      <a href="#get_color" class="autotype" title="Retrieves the specified palette entry.">get_color</a>(11, &amp;color);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_palette" title="Retrieves the entire palette of 256 colors.">get_palette</a>,
<a class="xref" href="#set_color" title="Sets the specified palette entry to the specified RGB triplet.">set_color</a>.</blockquote>
<div class="al-api"><b>void <a name="get_palette">get_palette</a>(<a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> p);</b></div><br>
   Retrieves the entire palette of 256 colors. You should provide an array 
   of 256 RGB structures to store it in. Example:
<blockquote class="code"><pre>
      <a href="#PALETTE" class="autotype" title="Stores palette information.">PALETTE</a> pal;
      ...
      <a href="#get_palette" class="autotype" title="Retrieves the entire palette of 256 colors.">get_palette</a>(pal);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_palette_range" title="Retrieves a specific palette range.">get_palette_range</a>,
<a class="xref" href="#get_color" title="Retrieves the specified palette entry.">get_color</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>.</blockquote>
<div class="al-api"><b>void <a name="get_palette_range">get_palette_range</a>(<a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> p, int from, int to);</b></div><br>
   Retrieves the palette entries between from and to (inclusive: pass 0 and 
   255 to get the entire palette).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_palette" title="Retrieves the entire palette of 256 colors.">get_palette</a>,
<a class="xref" href="#set_palette_range" title="Sets a specific range of the palette.">set_palette_range</a>.</blockquote>
<div class="al-api"><b>void <a name="fade_interpolate">fade_interpolate</a>(const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> source, const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> dest,
                      <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> output, int pos, int from, int to);</b></div><br>
   Calculates a temporary palette part way between source and dest, 
   returning it in the output parameter. The position between the two 
   extremes is specified by the pos value: 0 returns an exact copy of 
   source, 64 returns dest, 32 returns a palette half way between the two, 
   etc. This routine only affects colors between from and to (inclusive: 
   pass 0 and 255 to interpolate the entire palette).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fade_in" title="Gradually fades the palette from black.">fade_in</a>,
<a class="xref" href="#fade_out" title="Gradually fades the palette to black.">fade_out</a>,
<a class="xref" href="#fade_from" title="Gradually fades the palette between two others.">fade_from</a>.</blockquote>
<div class="al-api"><b>void <a name="fade_from_range">fade_from_range</a>(const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> source, const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> dest,
                     int speed, int from, int to);</b></div><br>
   Gradually fades a part of the palette from the source palette to the dest 
   palette. The speed is from 1 (the slowest) up to 64 (instantaneous). This 
   routine only affects colors between from and to (inclusive: pass 0 and 
   255 to fade the entire palette).

<p>
   Note that this function will block your game while the fade is in effect,
   and it won't work right visually if you are not in an 8 bit color depth
   resolution.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fade_from" title="Gradually fades the palette between two others.">fade_from</a>.</blockquote>
<div class="al-api"><b>void <a name="fade_in_range">fade_in_range</a>(const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> p, int speed, int from, int to);</b></div><br>
   Gradually fades a part of the palette from a black screen to the 
   specified palette. The speed is from 1 (the slowest) up to 64 
   (instantaneous). This routine only affects colors between from and to 
   (inclusive: pass 0 and 255 to fade the entire palette).

<p>
   Note that this function will block your game while the fade is in effect,
   and it won't work right visually if you are not in an 8 bit color depth
   resolution.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fade_in" title="Gradually fades the palette from black.">fade_in</a>.</blockquote>
<div class="al-api"><b>void <a name="fade_out_range">fade_out_range</a>(int speed, int from, int to);</b></div><br>
   Gradually fades a part of the palette from the current palette to a black 
   screen. The speed is from 1 (the slowest) up to 64 (instantaneous). This 
   routine only affects colors between from and to (inclusive: pass 0 and 
   255 to fade the entire palette).

<p>
   Note that this function will block your game while the fade is in effect,
   and it won't work right visually if you are not in an 8 bit color depth
   resolution.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fade_out" title="Gradually fades the palette to black.">fade_out</a>.</blockquote>
<div class="al-api"><b>void <a name="fade_from">fade_from</a>(const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> source, const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> dest, int speed);</b></div><br>
   Fades gradually from the source palette to the dest palette. The speed is 
   from 1 (the slowest) up to 64 (instantaneous).

<p>
   Note that this function will block your game while the fade is in effect,
   and it won't work right visually if you are not in an 8 bit color depth
   resolution.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fade_in" title="Gradually fades the palette from black.">fade_in</a>,
<a class="xref" href="#fade_out" title="Gradually fades the palette to black.">fade_out</a>,
<a class="xref" href="#fade_interpolate" title="Calculates a new palette interpolated between two others.">fade_interpolate</a>,
<a class="xref" href="#fade_from_range" title="Gradually fades a part of the palette between two others.">fade_from_range</a>.</blockquote>
<div class="al-api"><b>void <a name="fade_in">fade_in</a>(const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> p, int speed);</b></div><br>
   Fades gradually from a black screen to the specified palette. The speed 
   is from 1 (the slowest) up to 64 (instantaneous).

<p>
   Note that this function will block your game while the fade is in effect,
   and it won't work right visually if you are not in an 8 bit color depth
   resolution.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fade_out" title="Gradually fades the palette to black.">fade_out</a>,
<a class="xref" href="#fade_from" title="Gradually fades the palette between two others.">fade_from</a>,
<a class="xref" href="#fade_interpolate" title="Calculates a new palette interpolated between two others.">fade_interpolate</a>,
<a class="xref" href="#fade_in_range" title="Gradually fades a part of the palette from black.">fade_in_range</a>.</blockquote>
<div class="al-api"><b>void <a name="fade_out">fade_out</a>(int speed);</b></div><br>
   Fades gradually from the current palette to a black screen. The speed is 
   from 1 (the slowest) up to 64 (instantaneous).

<p>
   Note that this function will block your game while the fade is in effect,
   and it won't work right visually if you are not in an 8 bit color depth
   resolution.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fade_in" title="Gradually fades the palette from black.">fade_in</a>,
<a class="xref" href="#fade_from" title="Gradually fades the palette between two others.">fade_from</a>,
<a class="xref" href="#fade_interpolate" title="Calculates a new palette interpolated between two others.">fade_interpolate</a>,
<a class="xref" href="#fade_in_range" title="Gradually fades a part of the palette from black.">fade_in_range</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>.</blockquote>
<div class="al-api"><b>void <a name="select_palette">select_palette</a>(const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> p);</b></div><br>
   Ugly hack for use in various dodgy situations where you need to convert 
   between paletted and truecolor image formats. Sets the internal palette 
   table in the same way as the set_palette() function, so the conversion 
   will use the specified palette, but without affecting the display 
   hardware in any way. The previous palette settings are stored in an 
   internal buffer, and can be restored by calling unselect_palette(). If
   you call select_palette() again, however, the internal buffer will be
   overwritten.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#unselect_palette" title="Restores the palette before last call to select_palette().">unselect_palette</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>.</blockquote>
<div class="al-api"><b>void <a name="unselect_palette">unselect_palette</a>();</b></div><br>
   Restores the palette tables that were in use before the last call to 
   select_palette().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#select_palette" title="Sets the internal palette for color conversion.">select_palette</a>.</blockquote>
<div class="al-api"><b>void <a name="generate_332_palette">generate_332_palette</a>(<a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal);</b></div><br>
   Constructs a fake truecolor palette, using three bits for red and green 
   and two for the blue. The load_bitmap() function fills the palette
   parameter with this if the file does not contain a palette itself (ie. you
   are reading a truecolor bitmap).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#generate_optimized_palette" title="Generates an optimized palette for a bitmap.">generate_optimized_palette</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>,
<a class="eref" href="#extruec" title="Truecolor pixel format conversions.">extruec</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>int <a name="generate_optimized_palette">generate_optimized_palette</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal,
                               const char rsvd[PAL_SIZE]);</b></div><br>
   Generates a 256-color palette suitable for making a reduced color version 
   of the specified truecolor image. The rsvd parameter points to a table 
   indicating which colors it is allowed to modify: zero for free colors
   which may be set to whatever the optimiser likes, negative values for
   reserved colors which cannot be used, and positive values for fixed
   palette entries that must not be changed, but can be used in the
   optimisation.
<p><b>Return value:</b>
   Returns the number of different colors recognised in the provided bitmap,
   zero if the bitmap is not a truecolor image or there wasn't enough memory
   to perform the operation, and negative if there was any internal error in
   the color reduction code.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#generate_332_palette" title="Constructs a fake truecolor palette.">generate_332_palette</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>
<div class="al-api"><b>extern <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> <a name="default_palette">default_palette</a>;</b></div><br>
   The default IBM BIOS palette. This will be automatically selected 
   whenever you set a new graphics mode. The palette contains 16 basic
   colors plus many gradients between them. If you want to see the values,
   you can write a small Allegro program which saves a screenshot with this
   palette, or open the grabber tool provided with Allegro and create a new
   palette object, which will use this palette by default.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#black_palette" title="A palette containing solid black colors.">black_palette</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exjoy" title="Detecting, calibrating and using joystick input.">exjoy</a>.</blockquote>
<div class="al-api"><b>extern <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> <a name="black_palette">black_palette</a>;</b></div><br>
   A palette containing solid black colors, used by the fade routines.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#default_palette" title="The default IBM BIOS palette.">default_palette</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expal" title="Palette effects and color cycling.">expal</a>.</blockquote>
<div class="al-api"><b>extern <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> <a name="desktop_palette">desktop_palette</a>;</b></div><br>
   The palette used by the Atari ST low resolution desktop. I'm not quite 
   sure why this is still here, except that the grabber and test programs 
   use it. It is probably the only Atari legacy code left in Allegro, and it 
   would be a shame to remove it :-)

<p>
   The contents of this palette are 16 colors repeated 16 times. Color entry
   zero is equal to color entry 16, which is equal to color entry 24, etc.
<blockquote class="text"><pre>
       Index      Color       RGB values
         0     White          63  63  63
         1     Red            63   0   0
         2     Green           0  63   0
         3     Yellow         63  63   0
         4     Blue            0   0  63
         5     Pink           63   0  63
         6     Cyan            0  63  63
         7     Grey           16  16  16
         8     Light grey     31  31  31
         9     Light red      63  31  31
        10     Light green    31  63  31
        11     Light yellow   63  63  31
        12     Light blue     31  31  63
        13     Light pink     63  31  63
        14     Light cyan     31  63  63
        15     Black           0   0   0</pre></blockquote>




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#default_palette" title="The default IBM BIOS palette.">default_palette</a>,
<a class="xref" href="#black_palette" title="A palette containing solid black colors.">black_palette</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<h1><a name="Truecolor pixel formats">Truecolor pixel formats</a></h1>

<p>
In a truecolor video mode the red, green, and blue components for each pixel 
are packed directly into the color value, rather than using a palette lookup 
table. In a 15-bit mode there are 5 bits for each color, in 16-bit modes 
there are 5 bits each of red and blue and six bits of green, and both 24 and 
32-bit modes use 8 bits for each color (the 32-bit pixels simply have an 
extra padding byte to align the data nicely). The layout of these components 
can vary depending on your hardware, but will generally either be RGB or 
BGR. Since the layout is not known until you select the video mode you will 
be using, you must call set_gfx_mode() before using any of the following 
routines!

<p><br>
<div class="al-api"><b>int <a name="makecol8">makecol8</a>(int r, int g, int b);</b></div><br>
<div class="al-api-cont"><b>int <a name="makecol15">makecol15</a>(int r, int g, int b);</b></div><br>
<div class="al-api-cont"><b>int <a name="makecol16">makecol16</a>(int r, int g, int b);</b></div><br>
<div class="al-api-cont"><b>int <a name="makecol24">makecol24</a>(int r, int g, int b);</b></div><br>
<div class="al-api-cont"><b>int <a name="makecol32">makecol32</a>(int r, int g, int b);</b></div><br>
   These functions convert colors from a hardware independent form (red, 
   green, and blue values ranging 0-255) into various display dependent 
   pixel formats. Converting to 15, 16, 24, or 32-bit formats only takes a 
   few shifts, so it is fairly efficient. Converting to an 8-bit color 
   involves searching the palette to find the closest match, which is quite 
   slow unless you have set up an RGB mapping table (see below). Example:
<blockquote class="code"><pre>
      /* 16 bit color version of green. */
      int green_color = <a href="#makecol16" class="autotype" title="Converts an RGB value into a display dependent pixel format.">makecol16</a>(0, 255, 0);</pre></blockquote>
<p><b>Return value:</b>
   Returns the requested RGB triplet in the specified color depth.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#makeacol32" title="Converts an RGBA color into a 32-bit display pixel format.">makeacol32</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#makecol_depth" title="Converts an RGB value into the specified pixel format.">makecol_depth</a>,
<a class="xref" href="#makecol15_dither" title="Calculates a dithered 15 or 16-bit RGB value.">makecol15_dither</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>,
<a class="xref" href="#bestfit_color" title="Finds a palette color fitting the requested RGB values.">bestfit_color</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>.</blockquote>
<div class="al-api"><b>int <a name="makeacol32">makeacol32</a>(int r, int g, int b, int a);</b></div><br>
   Converts an RGBA color into a 32-bit display pixel format, which includes 
   an alpha (transparency) value. There are no versions of this routine for 
   other color depths, because only the 32-bit format has enough room to 
   store a proper alpha channel. You should only use RGBA format colors as 
   the input to draw_trans_sprite() or draw_trans_rle_sprite() after calling 
   set_alpha_blender(), rather than drawing them directly to the screen.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#makeacol" title="Converts RGBA colors into display dependent pixel formats.">makeacol</a>,
<a class="xref" href="#set_alpha_blender" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>,
<a class="xref" href="#set_write_alpha_blender" title="Enables the special alpha-channel editing mode.">set_write_alpha_blender</a>.</blockquote>
<div class="al-api"><b>int <a name="makecol">makecol</a>(int r, int g, int b);</b></div><br>
   Converts colors from a hardware independent format (red, green, and blue 
   values ranging 0-255) to the pixel format required by the current video 
   mode, calling the preceding 8, 15, 16, 24, or 32-bit makecol functions as 
   appropriate. Example:
<blockquote class="code"><pre>
      /* Regardless of color depth, this will look green. */
      int green_color = <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 255, 0);</pre></blockquote>
<p><b>Return value:</b>
   Returns the requested RGB triplet in the current color depth.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#makeacol" title="Converts RGBA colors into display dependent pixel formats.">makeacol</a>,
<a class="xref" href="#makecol8" title="Converts an RGB value into a display dependent pixel format.">makecol8</a>,
<a class="xref" href="#makecol_depth" title="Converts an RGB value into the specified pixel format.">makecol_depth</a>,
<a class="xref" href="#makecol15_dither" title="Calculates a dithered 15 or 16-bit RGB value.">makecol15_dither</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>int <a name="makecol_depth">makecol_depth</a>(int color_depth, int r, int g, int b);</b></div><br>
   Converts colors from a hardware independent format (red, green, and blue 
   values ranging 0-255) to the pixel format required by the specified color 
   depth. Example:
<blockquote class="code"><pre>
      /* Compose the green color for 15 bit color depth. */
      int green_15bit = <a href="#makecol_depth" class="autotype" title="Converts an RGB value into the specified pixel format.">makecol_depth</a>(15, 0, 255, 0);</pre></blockquote>
<p><b>Return value:</b>
   Returns the requested RGB triplet in the specified color depth.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#makeacol" title="Converts RGBA colors into display dependent pixel formats.">makeacol</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#makecol8" title="Converts an RGB value into a display dependent pixel format.">makecol8</a>,
<a class="xref" href="#makecol15_dither" title="Calculates a dithered 15 or 16-bit RGB value.">makecol15_dither</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>
<div class="al-api"><b>int <a name="makeacol">makeacol</a>(int r, int g, int b, int a);</b></div><br>
<div class="al-api-cont"><b>int <a name="makeacol_depth">makeacol_depth</a>(int color_depth, int r, int g, int b, int a);</b></div><br>
   Convert RGBA colors into display dependent pixel formats. In anything 
   less than a 32-bit mode, these are the same as calling makecol() or 
   makecol_depth(), but by using these routines it is possible to create 
   32-bit color values that contain a true 8 bit alpha channel along with 
   the red, green, and blue components. You should only use RGBA format 
   colors as the input to draw_trans_sprite() or draw_trans_rle_sprite() 
   after calling set_alpha_blender(), rather than drawing them directly to 
   the screen.
<p><b>Return value:</b>
   Returns the requested RGBA quadruplet.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#makecol_depth" title="Converts an RGB value into the specified pixel format.">makecol_depth</a>,
<a class="xref" href="#set_alpha_blender" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>,
<a class="xref" href="#set_write_alpha_blender" title="Enables the special alpha-channel editing mode.">set_write_alpha_blender</a>.</blockquote>
<div class="al-api"><b>int <a name="makecol15_dither">makecol15_dither</a>(int r, int g, int b, int x, int y);</b></div><br>
<div class="al-api-cont"><b>int <a name="makecol16_dither">makecol16_dither</a>(int r, int g, int b, int x, int y);</b></div><br>
   Given both a color value and a pixel coordinate, calculate a dithered 15 
   or 16-bit RGB value. This can produce better results when reducing images 
   from truecolor to hicolor. In addition to calling these functions 
   directly, hicolor dithering can be automatically enabled when loading 
   graphics by calling the set_color_conversion() function, for example 
   set_color_conversion(COLORCONV_REDUCE_TRUE_TO_HI | COLORCONV_DITHER).
   
<p>
   Example:
<blockquote class="code"><pre>
      int pixel1, pixel2;

      /* The following two color values MAY be different. */
      pixel1 = <a href="#makecol16_dither" class="autotype" title="Calculates a dithered 15 or 16-bit RGB value.">makecol16_dither</a>(255, 192, 64, 0, 0);
      pixel2 = <a href="#makecol16_dither" class="autotype" title="Calculates a dithered 15 or 16-bit RGB value.">makecol16_dither</a>(255, 192, 64, 1, 0);</pre></blockquote>
<p><b>Return value:</b>
   Returns the RGB value dithered for the specified coordinate.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#makecol8" title="Converts an RGB value into a display dependent pixel format.">makecol8</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>.</blockquote>
<div class="al-api"><b>int <a name="getr8">getr8</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getg8">getg8</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getb8">getb8</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getr15">getr15</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getg15">getg15</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getb15">getb15</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getr16">getr16</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getg16">getg16</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getb16">getb16</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getr24">getr24</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getg24">getg24</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getb24">getb24</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getr32">getr32</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getg32">getg32</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getb32">getb32</a>(int c);</b></div><br>
   Given a color in a display dependent format, these functions extract one 
   of the red, green, or blue components (ranging 0-255). Example:
<blockquote class="code"><pre>
      int r, g, b, color_value;

      color_value = <a href="#_getpixel15" class="autotype" title="Faster specific version of getpixel().">_getpixel15</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 100, 100);
      r = <a href="#getr15" class="autotype" title="Extract a color component from the specified pixel format.">getr15</a>(color_value);
      g = <a href="#getg15" class="autotype" title="Extract a color component from the specified pixel format.">getg15</a>(color_value);
      b = <a href="#getb15" class="autotype" title="Extract a color component from the specified pixel format.">getb15</a>(color_value);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#geta32" title="Extract the alpha component form a 32-bit pixel format color.">geta32</a>,
<a class="xref" href="#getr" title="Extract a color component from the current pixel format.">getr</a>,
<a class="xref" href="#getr_depth" title="Extract a color component from a color in a specified pixel format.">getr_depth</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>
<div class="al-api"><b>int <a name="geta32">geta32</a>(int c);</b></div><br>
   Given a color in a 32-bit pixel format, this function extracts the alpha 
   component (ranging 0-255).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#getr8" title="Extract a color component from the specified pixel format.">getr8</a>.</blockquote>
<div class="al-api"><b>int <a name="getr">getr</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getg">getg</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getb">getb</a>(int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="geta">geta</a>(int c);</b></div><br>
   Given a color in the format being used by the current video mode, these 
   functions extract one of the red, green, blue, or alpha components 
   (ranging 0-255), calling the preceding 8, 15, 16, 24, or 32-bit get 
   functions as appropriate. The alpha part is only meaningful for 32-bit 
   pixels. Example:
<blockquote class="code"><pre>
      int r, g, b, color_value;

      color_value = <a href="#getpixel" class="autotype" title="Reads a pixel from a bitmap.">getpixel</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 100, 100);
      r = <a href="#getr" class="autotype" title="Extract a color component from the current pixel format.">getr</a>(color_value);
      g = <a href="#getg" class="autotype" title="Extract a color component from the current pixel format.">getg</a>(color_value);
      b = <a href="#getb" class="autotype" title="Extract a color component from the current pixel format.">getb</a>(color_value);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#getr8" title="Extract a color component from the specified pixel format.">getr8</a>,
<a class="xref" href="#getr_depth" title="Extract a color component from a color in a specified pixel format.">getr_depth</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>.</blockquote>
<div class="al-api"><b>int <a name="getr_depth">getr_depth</a>(int color_depth, int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getg_depth">getg_depth</a>(int color_depth, int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="getb_depth">getb_depth</a>(int color_depth, int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="geta_depth">geta_depth</a>(int color_depth, int c);</b></div><br>
   Given a color in the format being used by the specified color depth, 
   these functions extract one of the red, green, blue, or alpha components 
   (ranging 0-255). The alpha part is only meaningful for 32-bit pixels.
   Example:
<blockquote class="code"><pre>
      int r, g, b, color_value, bpp;

      bpp = <a href="#bitmap_color_depth" class="autotype" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>(bitmap);
      color_value = <a href="#getpixel" class="autotype" title="Reads a pixel from a bitmap.">getpixel</a>(bitmap, 100, 100);
      r = <a href="#getr_depth" class="autotype" title="Extract a color component from a color in a specified pixel format.">getr_depth</a>(bpp, color_value);
      g = <a href="#getg_depth" class="autotype" title="Extract a color component from a color in a specified pixel format.">getg_depth</a>(bpp, color_value);
      b = <a href="#getb_depth" class="autotype" title="Extract a color component from a color in a specified pixel format.">getb_depth</a>(bpp, color_value);</pre></blockquote>
      

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#getr" title="Extract a color component from the current pixel format.">getr</a>,
<a class="xref" href="#getr8" title="Extract a color component from the specified pixel format.">getr8</a>,
<a class="xref" href="#geta32" title="Extract the alpha component form a 32-bit pixel format color.">geta32</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>.</blockquote>
<div class="al-api"><b>extern int <a name="palette_color">palette_color</a>[256];</b></div><br>
   Table mapping palette index colors (0-255) into whatever pixel format is 
   being used by the current display mode. In a 256-color mode this just 
   maps onto the array index. In truecolor modes it looks up the specified 
   entry in the current palette, and converts that RGB value into the 
   appropriate packed pixel format. Example:
<blockquote class="code"><pre>
      <a href="#set_color_depth" class="autotype" title="Sets the global pixel color depth.">set_color_depth</a>(32);
      ...
      <a href="#set_palette" class="autotype" title="Sets the entire palette of 256 colors.">set_palette</a>(<a href="#desktop_palette" class="autotype" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>);
      /* Put a pixel with the color 2 (green) of the palette */
      <a href="#putpixel" class="autotype" title="Writes a pixel into a bitmap.">putpixel</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 100, 100, <a href="#palette_color" class="autotype" title="Maps palette indexes into the current pixel format colors.">palette_color</a>[2]);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>#define <a name="MASK_COLOR_8">MASK_COLOR_8</a> 0</b></div><br>
<div class="al-api-cont"><b>#define <a name="MASK_COLOR_15">MASK_COLOR_15</a> (5.5.5 pink)</b></div><br>
<div class="al-api-cont"><b>#define <a name="MASK_COLOR_16">MASK_COLOR_16</a> (5.6.5 pink)</b></div><br>
<div class="al-api-cont"><b>#define <a name="MASK_COLOR_24">MASK_COLOR_24</a> (8.8.8 pink)</b></div><br>
<div class="al-api-cont"><b>#define <a name="MASK_COLOR_32">MASK_COLOR_32</a> (8.8.8 pink)</b></div><br>
   Constants representing the colors used to mask transparent sprite pixels 
   for each color depth. In 256-color resolutions this is zero, and in 
   truecolor modes it is bright pink (maximum red and blue, zero green).




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#masked_blit" title="Copies a rectangle skipping pixels with the mask color.">masked_blit</a>.</blockquote>
<h1><a name="Drawing primitives">Drawing primitives</a></h1>

<p>
Except for _putpixel(), all these routines are affected by the current 
drawing mode and the clipping rectangle of the destination bitmap. Unless
specified otherwise, all coordinates for drawing operations are inclusive,
and they, as well as lengths, are specified in pixel units.

<p><br>
<div class="al-api"><b>void <a name="clear_bitmap">clear_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap);</b></div><br>
   Clears the bitmap to color 0.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="clear_to_color">clear_to_color</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int color);</b></div><br>
   Clears the bitmap to the specified color. Example:
<blockquote class="code"><pre>
      /* Clear the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> to red. */
      <a href="#clear_to_color" class="autotype" title="Clears the bitmap to the specified color.">clear_to_color</a>(bmp, <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(255, 0, 0));</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="putpixel">putpixel</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color);</b></div><br>
   Writes a pixel to the specified position in the bitmap, using the current 
   drawing mode and the bitmap's clipping rectangle. Example: 
<blockquote class="code"><pre>
      <a href="#putpixel" class="autotype" title="Writes a pixel into a bitmap.">putpixel</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 10, 30, some_color);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#getpixel" title="Reads a pixel from a bitmap.">getpixel</a>,
<a class="xref" href="#_putpixel" title="Faster specific version of putpixel().">_putpixel</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#exflame" title="How to write directly to video memory improving performance.">exflame</a>,
<a class="eref" href="#exjoy" title="Detecting, calibrating and using joystick input.">exjoy</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>.</blockquote>
<div class="al-api"><b>void <a name="_putpixel">_putpixel</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color);</b></div><br>
<div class="al-api-cont"><b>void <a name="_putpixel15">_putpixel15</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color);</b></div><br>
<div class="al-api-cont"><b>void <a name="_putpixel16">_putpixel16</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color);</b></div><br>
<div class="al-api-cont"><b>void <a name="_putpixel24">_putpixel24</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color);</b></div><br>
<div class="al-api-cont"><b>void <a name="_putpixel32">_putpixel32</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color);</b></div><br>
   Like the regular putpixel(), but much faster because they are implemented 
   as an inline assembler functions for specific color depths. These won't 
   work in mode-X graphics modes, don't perform any clipping (they will 
   crash if you try to draw outside the bitmap!), and ignore the drawing 
   mode.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#putpixel" title="Writes a pixel into a bitmap.">putpixel</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>
<div class="al-api"><b>int <a name="getpixel">getpixel</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y);</b></div><br>
   Reads a pixel from point (x, y) in the bitmap.
<p><b>Return value:</b>
   Returns -1 if the point lies outside the bitmap (ignoring the clipping
   rectangle), otherwise the value of the pixel in the color format of the
   bitmap.

<p>
   Warning: -1 is also a valid value for pixels contained in 32-bit bitmaps
   with alpha channel (when R,G,B,A are all equal to 255) so you can't use
   the test against -1 as a predicate for such bitmaps. In this cases, the
   only reliable predicate is is_inside_bitmap().

<p>
   To extract the individual color components, use the getr() / getg() /
   getb() / geta() family of functions.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#putpixel" title="Writes a pixel into a bitmap.">putpixel</a>,
<a class="xref" href="#_getpixel" title="Faster specific version of getpixel().">_getpixel</a>,
<a class="xref" href="#is_inside_bitmap" title="Tells if a point is inside a bitmap.">is_inside_bitmap</a>,
<a class="xref" href="#getr" title="Extract a color component from the current pixel format.">getr</a>,
<a class="xref" href="#getg" title="Extract a color component from the current pixel format.">getg</a>,
<a class="xref" href="#getb" title="Extract a color component from the current pixel format.">getb</a>,
<a class="xref" href="#geta" title="Extract a color component from the current pixel format.">geta</a>,
<a class="xref" href="#Truecolor pixel formats" title="">Truecolor pixel formats</a>,
<a class="xref" href="#Palette routines" title="">Palette routines</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#exflame" title="How to write directly to video memory improving performance.">exflame</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>.</blockquote>
<div class="al-api"><b>int <a name="_getpixel">_getpixel</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y);</b></div><br>
<div class="al-api-cont"><b>int <a name="_getpixel15">_getpixel15</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y);</b></div><br>
<div class="al-api-cont"><b>int <a name="_getpixel16">_getpixel16</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y);</b></div><br>
<div class="al-api-cont"><b>int <a name="_getpixel24">_getpixel24</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y);</b></div><br>
<div class="al-api-cont"><b>int <a name="_getpixel32">_getpixel32</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y);</b></div><br>
   Faster inline versions of getpixel() for specific color depths. These 
   won't work in mode-X, and don't do any clipping, so you must make sure 
   the point lies inside the bitmap.
<p><b>Return value:</b>
   Returns the value of the pixel in the color format you specified.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#getpixel" title="Reads a pixel from a bitmap.">getpixel</a>.</blockquote>
<div class="al-api"><b>void <a name="vline">vline</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y1, int y2, int color);</b></div><br>
   Draws a vertical line onto the bitmap, from point (x, y1) to (x, y2).

<p>
   Note: vline() is implemented as an alias to another function.
   See ALLEGRO_NO_VHLINE_ALIAS in the `Differences between platforms'
   section for details.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#hline" title="Draws a horizontal line onto the bitmap.">hline</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#Differences between platforms" title="">Differences between platforms</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>,
<a class="eref" href="#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>,
<a class="eref" href="#extruec" title="Truecolor pixel format conversions.">extruec</a>.</blockquote>
<div class="al-api"><b>void <a name="hline">hline</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x1, int y, int x2, int color);</b></div><br>
   Draws a horizontal line onto the bitmap, from point (x1, y) to (x2, y).

<p>
   Note: hline() is implemented as an alias to another function.
   See ALLEGRO_NO_VHLINE_ALIAS in the `Differences between platforms'
   section for details.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#vline" title="Draws a vertical line onto the bitmap.">vline</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#Differences between platforms" title="">Differences between platforms</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>.</blockquote>
<div class="al-api"><b>void <a name="do_line">do_line</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x1, y1, x2, y2, int d, 
             void (*proc)(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int d));</b></div><br>
   Calculates all the points along a line from point (x1, y1) to (x2, y2), 
   calling the supplied function for each one. This will be passed a copy of 
   the bmp parameter, the x and y position, and a copy of the d parameter, 
   so it is suitable for use with putpixel(). Example:
<blockquote class="code"><pre>
      void draw_dust_particle(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int d)
      {
         ...
      }
      
         <a href="#do_line" class="autotype" title="Calculates all the points along a line.">do_line</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, 0, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>-1, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>-2,
                 dust_strength, draw_dust_particle);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#do_circle" title="Calculates all the points in a circle.">do_circle</a>,
<a class="xref" href="#do_ellipse" title="Calculates all the points in an ellipse.">do_ellipse</a>,
<a class="xref" href="#do_arc" title="Calculates all the points in a circular arc.">do_arc</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>.</blockquote>
<div class="al-api"><b>void <a name="line">line</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x1, int y1, int x2, int y2, int color);</b></div><br>
   Draws a line onto the bitmap, from point (x1, y1) to (x2, y2).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fastline" title="Faster version of line().">fastline</a>,
<a class="xref" href="#hline" title="Draws a horizontal line onto the bitmap.">hline</a>,
<a class="xref" href="#vline" title="Draws a vertical line onto the bitmap.">vline</a>,
<a class="xref" href="#do_line" title="Calculates all the points along a line.">do_line</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="fastline">fastline</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x1, int y1, int x2, int y2, int color);</b></div><br>
   Faster version of the previous function. Note that pixel correctness is
   not guaranteed for this function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#hline" title="Draws a horizontal line onto the bitmap.">hline</a>,
<a class="xref" href="#vline" title="Draws a vertical line onto the bitmap.">vline</a>,
<a class="xref" href="#do_line" title="Calculates all the points along a line.">do_line</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="triangle">triangle</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x1, y1, x2, y2, x3, y3, int color);</b></div><br>
   Draws a filled triangle between the three points.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#polygon" title="Draws a filled polygon.">polygon</a>,
<a class="xref" href="#triangle3d" title="Draws a 3d triangle onto the specified bitmap.">triangle3d</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>void <a name="polygon">polygon</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int vertices, const int *points, int color);</b></div><br>
   Draws a filled polygon with an arbitrary number of corners. Pass the 
   number of vertices and an array containing a series of x, y points (a 
   total of vertices*2 values). Example:
<blockquote class="code"><pre>
      int points[12] = { 50, 50,   100, 100,  100, 150,
                         50, 200,  0,   150,  0,   100 };
      ...
      <a href="#clear_to_color" class="autotype" title="Clears the bitmap to the specified color.">clear_to_color</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(255, 255, 255));
      <a href="#polygon" class="autotype" title="Draws a filled polygon.">polygon</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 6, points, <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 0, 0));</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#triangle" title="Draws a filled triangle.">triangle</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>.</blockquote>
<div class="al-api"><b>void <a name="rect">rect</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x1, int y1, int x2, int y2, int color);</b></div><br>
   Draws an outline rectangle with the two points as its opposite corners.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>.</blockquote>
<div class="al-api"><b>void <a name="rectfill">rectfill</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x1, int y1, int x2, int y2, int color);</b></div><br>
   Draws a solid, filled rectangle with the two points as its opposite 
   corners.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rect" title="Draws an outline rectangle.">rect</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>,
<a class="eref" href="#exkeys" title="How to get input from the keyboard in different ways.">exkeys</a>,
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>,
<a class="eref" href="#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>,
<a class="eref" href="#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="do_circle">do_circle</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int radius, int d,
               void (*proc)(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int d));</b></div><br>
   Calculates all the points in a circle around point (x, y) with radius r, 
   calling the supplied function for each one. This will be passed a copy of 
   the bmp parameter, the x and y position, and a copy of the d parameter, 
   so it is suitable for use with putpixel(). Example:
<blockquote class="code"><pre>
      void draw_explosion_ring(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int d)
      {
         ...
      }
      
         <a href="#do_circle" class="autotype" title="Calculates all the points in a circle.">do_circle</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>/2, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>/2,
                   <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>/16, flame_color,
                   draw_explosion_ring);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#do_ellipse" title="Calculates all the points in an ellipse.">do_ellipse</a>,
<a class="xref" href="#do_arc" title="Calculates all the points in a circular arc.">do_arc</a>,
<a class="xref" href="#do_line" title="Calculates all the points along a line.">do_line</a>,
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>.</blockquote>
<div class="al-api"><b>void <a name="circle">circle</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int radius, int color);</b></div><br>
   Draws a circle with the specified centre and radius.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ellipse" title="Draws an ellipse.">ellipse</a>,
<a class="xref" href="#arc" title="Draws a circular arc.">arc</a>,
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>,
<a class="xref" href="#do_circle" title="Calculates all the points in a circle.">do_circle</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>,
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exjoy" title="Detecting, calibrating and using joystick input.">exjoy</a>,
<a class="eref" href="#exmem" title="Drawing onto memory bitmaps and then blitting them to the screen.">exmem</a>,
<a class="eref" href="#exmouse" title="Getting input from the mouse.">exmouse</a>,
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>.</blockquote>
<div class="al-api"><b>void <a name="circlefill">circlefill</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int radius, int color);</b></div><br>
   Draws a filled circle with the specified centre and radius.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ellipsefill" title="Draws a filled ellipse.">ellipsefill</a>,
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#do_circle" title="Calculates all the points in a circle.">do_circle</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>,
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exdbuf" title="How to use double buffering to avoid flicker.">exdbuf</a>,
<a class="eref" href="#exflip" title="Comparison of double buffering and page flipping.">exflip</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#expal" title="Palette effects and color cycling.">expal</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="do_ellipse">do_ellipse</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int rx, ry, int d,
                void (*proc)(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int d));</b></div><br>
   Calculates all the points in an ellipse around point (x, y) with radius 
   rx and ry, calling the supplied function for each one. This will be 
   passed a copy of the bmp parameter, the x and y position, and a copy of 
   the d parameter, so it is suitable for use with putpixel(). Example:
<blockquote class="code"><pre>
      void draw_explosion_ring(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int d)
      {
         ...
      }
      
         <a href="#do_ellipse" class="autotype" title="Calculates all the points in an ellipse.">do_ellipse</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>/2, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>/2,
                   <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>/16, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>/32, flame_color,
                   draw_explosion_ring);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#do_circle" title="Calculates all the points in a circle.">do_circle</a>,
<a class="xref" href="#do_arc" title="Calculates all the points in a circular arc.">do_arc</a>,
<a class="xref" href="#do_line" title="Calculates all the points along a line.">do_line</a>,
<a class="xref" href="#ellipse" title="Draws an ellipse.">ellipse</a>,
<a class="xref" href="#ellipsefill" title="Draws a filled ellipse.">ellipsefill</a>.</blockquote>
<div class="al-api"><b>void <a name="ellipse">ellipse</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int rx, int ry, int color);</b></div><br>
   Draws an ellipse with the specified centre and radius.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#arc" title="Draws a circular arc.">arc</a>,
<a class="xref" href="#ellipsefill" title="Draws a filled ellipse.">ellipsefill</a>,
<a class="xref" href="#do_ellipse" title="Calculates all the points in an ellipse.">do_ellipse</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>
<div class="al-api"><b>void <a name="ellipsefill">ellipsefill</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int rx, int ry, int color);</b></div><br>
   Draws a filled ellipse with the specified centre and radius.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>,
<a class="xref" href="#ellipse" title="Draws an ellipse.">ellipse</a>,
<a class="xref" href="#do_ellipse" title="Calculates all the points in an ellipse.">do_ellipse</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>.</blockquote>
<div class="al-api"><b>void <a name="do_arc">do_arc</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> a1, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> a2, int r, int d,
            void (*proc)(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int d));</b></div><br>
   Calculates all the points in a circular arc around point (x, y) with 
   radius r, calling the supplied function for each one. This will be passed 
   a copy of the bmp parameter, the x and y position, and a copy of the d
   parameter, so it is suitable for use with putpixel(). The arc will be 
   plotted in an anticlockwise direction starting from the angle a1 and 
   ending when it reaches a2. These values are specified in 16.16 fixed 
   point format, with 256 equal to a full circle, 64 a right angle, etc. 
   Zero is to the right of the centre point, and larger values rotate 
   anticlockwise from there. Example:
<blockquote class="code"><pre>
      void draw_explosion_ring(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int d)
      {
         ...
      }
         <a href="#do_arc" class="autotype" title="Calculates all the points in a circular arc.">do_arc</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>/2, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>/2,
             <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-21), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(43), 50, flame_color,
             draw_explosion_ring);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#do_circle" title="Calculates all the points in a circle.">do_circle</a>,
<a class="xref" href="#do_ellipse" title="Calculates all the points in an ellipse.">do_ellipse</a>,
<a class="xref" href="#do_line" title="Calculates all the points along a line.">do_line</a>,
<a class="xref" href="#arc" title="Draws a circular arc.">arc</a>.</blockquote>
<div class="al-api"><b>void <a name="arc">arc</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> ang1, ang2, int r, int color);</b></div><br>
   Draws a circular arc with centre x, y and radius r, in an anticlockwise 
   direction starting from the angle a1 and ending when it reaches a2. These 
   values are specified in 16.16 fixed point format, with 256 equal to a 
   full circle, 64 a right angle, etc. Zero is to the right of the centre 
   point, and larger values rotate anticlockwise from there. Example:
<blockquote class="code"><pre>
      /* Draw a black <a href="#arc" class="autotype" title="Draws a circular arc.">arc</a> from 4 to 1 o'clock. */
      <a href="#arc" class="autotype" title="Draws a circular arc.">arc</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>/2, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>/2,
          <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-21), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(43), 50, <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 0, 0));</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#ellipse" title="Draws an ellipse.">ellipse</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>
<div class="al-api"><b>void <a name="calc_spline">calc_spline</a>(const int points[8], int npts, int *x, int *y);</b></div><br>
   Calculates a series of npts values along a Bezier spline, storing them in 
   the output x and y arrays. The Bezier curve is specified by the four x/y 
   control points in the points array: points[0] and points[1] contain the 
   coordinates of the first control point, points[2] and points[3] are the 
   second point, etc. Control points 0 and 3 are the ends of the spline, and 
   points 1 and 2 are guides. The curve probably won't pass through points 1 
   and 2, but they affect the shape of the curve between points 0 and 3 (the 
   lines p0-p1 and p2-p3 are tangents to the spline). The easiest way to 
   think of it is that the curve starts at p0, heading in the direction of 
   p1, but curves round so that it arrives at p3 from the direction of p2. 
   In addition to their role as graphics primitives, spline curves can be 
   useful for constructing smooth paths around a series of control points, 
   as in exspline.c.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#spline" title="Draws a Bezier spline using four control points.">spline</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>.</blockquote>
<div class="al-api"><b>void <a name="spline">spline</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const int points[8], int color);</b></div><br>
   Draws a Bezier spline using the four control points specified in the 
   points array. Read the description of calc_spline() for information on
   how to build the points array.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#calc_spline" title="Calculates a series of values along a Bezier spline.">calc_spline</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>.</blockquote>
<div class="al-api"><b>void <a name="floodfill">floodfill</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color);</b></div><br>
   Floodfills an enclosed area, starting at point (x, y), with the specified 
   color.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>
<h1><a name="Blitting and sprites">Blitting and sprites</a></h1>

<p>
As far as Allegro is concerned, a bitmap and a sprite are the same thing,
but to many people the two words imply slightly different things.  The
function draw_sprite() is called so rather than draw_bitmap() partly because
it indicates that it uses a masked drawing mode (if it existed, you could
expect draw_bitmap() to be a simple block copy), and partly for historical
reasons. In Allegro 1.0 there were actually different structures for sprites
and bitmaps, each with their own set of abilities. Allegro 2.0 merged these
into a single more flexible structure, but retained some names like
draw_sprite().

<p>
In wider (non-Allegro) terms, the two words can mean quite different things.
Generally you can say that sprites are a subset of bitmaps, but even that
isn't true in 100% of cases.

<p>
BITMAP: a widely accepted term that will be understood by anyone even
remotely connected with computer graphics. It simply means an image built up
from a grid of pixels, ie. just about any picture that you are likely to come
across on a computer (vector graphics formats are the exception, but those
must be rendered into a bitmap format before they can be displayed by most
hardware). A more accurate term but slightly rarer term with the same meaning
is "pixmap" (pixel-map).

<p>
SPRITE: a particular usage of bitmapped images, restricted to video games
(other types of programmer probably won't be familiar with this term).
Originally on machines like the C64, sprites were a hardware feature that
allowed a number of small bitmap images to be loaded into special registers,
and they could then be superimposed over the main graphics display and moved
around just by modifying the position register. They were used for the moving
objects (player and enemy characters), and enabled the C64 to do much more
impressive things than would have been possible if all the drawing had to be
done directly by the puny CPU.

<p>
Later on, a lot of old C64 programmers upgraded to machines like the Atari
ST, which didn't have any special sprite hardware, but they carried on
referring to their main moving objects as sprites (the routine to draw such a
thing would obviously be called draw_sprite()).  A sprite is really just a
bitmap graphic which is drawn onto the screen, but when you call it a sprite
rather than a bitmap, this suggests it is a gameplay element that can move
freely around the world rather than being a static part of the environment,
and that it will be drawn in a masked overlay mode rather than as a solid
rectangle (there is also a strong implication that a sprite will be animated
by cycling through a number of frames, but that isn't always the case).

<p>
In recent years some people have started using "sprite" to refer to any
character graphics, even if they are not in fact drawn as 2d bitmaps, eg.
"this game uses 3d polygonal player sprites". This is a confusing misuse of
the word (Doom uses sprites, Quake does not), but it does happen.

<p>
The origin of the term "blit" is also rather interesting. This was originally
BitBlt, an abbreviation of BITmap BLock Transfer, which was a function
designed (possibly) by the people at Xerox who did so much of the pioneering
work on graphics display systems, and subsequently copied by virtually
everybody doing computer graphics (the Microsoft Windows GDI still provides a
BitBlt function with identical functionality to the original). This routine
was a workhorse for all sorts of drawing operations, basically copying bitmap
graphics from one place to another, but including a number of different ROP
modes (Raster OPerations) for doing things like XOR, inverting pixels, etc.
A whole family of related words grew up around the BitBlt function, but "blt"
is impossible to speak (try saying "bltter" or "bltting" :-) so people added
the vowel to make it easier to pronounce.

<p>
Therefore, the act of calling the BitBlt function came to be known as "doing a
blit". The obvious next step was to rename the function itself to blit(),
which generally took place at the same time as people decided to simplify the
original, removing the different ROP modes on the grounds that they aren't
needed for games coding and don't work well with anything higher than
monochrome images in any case. This leaves us with a function called blit(),
which is an abbreviation for "block transfer". A strong case could be made
for calling this blot() instead, but somehow that just doesn't sound the
same!

<p>
Anyway, all the routines in this chapter are affected by the
clipping rectangle of the destination bitmap.

<p><br>
<div class="al-api"><b>void <a name="blit">blit</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *source, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *dest, int source_x, int source_y,
          int dest_x, int dest_y, int width, int height);</b></div><br>
   Copies a rectangular area of the source bitmap to the destination bitmap. 
   The source_x and source_y parameters are the top left corner of the area 
   to copy from the source bitmap, and dest_x and dest_y are the 
   corresponding position in the destination bitmap. This routine respects 
   the destination clipping rectangle, and it will also clip if you try to 
   blit from areas outside the source bitmap. Example:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;
      ...
      /* Blit src on the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>. */
      <a href="#blit" class="autotype" title="Copies a rectangular area from one bitmap to another.">blit</a>(bmp, <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, 0, 0, 0, bmp-&gt;w, bmp-&gt;h);
      
      /* Now copy a chunk to a corner, slightly outside. /*
      <a href="#blit" class="autotype" title="Copies a rectangular area from one bitmap to another.">blit</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 100, 100, -10, -10, 25, 30);
</pre></blockquote>
   You can blit between any parts of any two bitmaps, even if the two memory 
   areas overlap (ie. source and dest are the same, or one is sub-bitmap of 
   the other). You should be aware, however, that a lot of SVGA cards don't 
   provide separate read and write banks, which means that blitting from one 
   part of the screen to another requires the use of a temporary bitmap in 
   memory, and is therefore extremely slow. As a general rule you should 
   avoid blitting from the screen onto itself in SVGA modes.

<p>
   In mode-X, on the other hand, blitting from one part of the screen to 
   another can be significantly faster than blitting from memory onto the 
   screen, as long as the source and destination are correctly aligned with 
   each other. Copying between overlapping screen rectangles is slow, but if 
   the areas don't overlap, and if they have the same plane alignment (ie. 
   (source_x%4) == (dest_x%4)), the VGA latch registers can be used for a 
   very fast data transfer. To take advantage of this, in mode-X it is often 
   worth storing tile graphics in a hidden area of video memory (using a 
   large virtual screen), and blitting them from there onto the visible part 
   of the screen.

<p>
   If the GFX_HW_VRAM_BLIT bit in the gfx_capabilities flag is set, the 
   current driver supports hardware accelerated blits from one part of the 
   screen onto another. This is extremely fast, so when this flag is set it 
   may be worth storing some of your more frequently used graphics in an 
   offscreen portion of the video memory.

<p>
   Unlike most of the graphics routines, blit() allows the source and
   destination bitmaps to be of different color depths, so it can be
   used to convert images from one pixel format to another. In this
   case, the behavior is affected by the COLORCONV_KEEP_TRANS and
   COLORCONV_DITHER* flags of the current color conversion mode: see
   set_color_conversion() for more information.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#masked_blit" title="Copies a rectangle skipping pixels with the mask color.">masked_blit</a>,
<a class="xref" href="#stretch_blit" title="Scales a rectangular area from one bitmap to another.">stretch_blit</a>,
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="stretch_blit">stretch_blit</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *source, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *dest,
                  int source_x, source_y, source_width, source_height,
                  int dest_x, dest_y, dest_width, dest_height);</b></div><br>
   Like blit(), except it can scale images (so the source and destination 
   rectangles don't need to be the same size) and requires the source and 
   destination bitmaps to be of the same color depth. This routine doesn't 
   do as much safety checking as the regular blit(): in particular you must 
   take care not to copy from areas outside the source bitmap, and you 
   cannot blit between overlapping regions, ie. you must use different 
   bitmaps for the source and the destination. Moreover, the source must 
   be a memory bitmap. Example:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;
      ...
      /* Stretch bmp to fill the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>. */
      <a href="#stretch_blit" class="autotype" title="Scales a rectangular area from one bitmap to another.">stretch_blit</a>(bmp, <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, 0, bmp-&gt;w, bmp-&gt;h,
                   0, 0, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#masked_stretch_blit" title="Scales a rectangular area skipping pixels with the mask color.">masked_stretch_blit</a>,
<a class="xref" href="#stretch_sprite" title="Stretches a sprite to the destination bitmap.">stretch_sprite</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#exconfig" title="Using the configuration routines.">exconfig</a>,
<a class="eref" href="#exscale" title="Loading PCX files and bitmap stretching.">exscale</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="masked_blit">masked_blit</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *source, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *dest, int source_x, int source_y,
                 int dest_x, int dest_y, int width, int height);</b></div><br>
   Like blit(), but skips transparent pixels, which are marked by a zero in 
   256-color modes or bright pink for truecolor data (maximum red and blue, 
   zero green), and requires the source and destination bitmaps to be of 
   the same color depth. The source and destination regions must not overlap.
   Example:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *hud_overlay;
      ...
      /* Paint hud overlay on the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>. */
      <a href="#masked_blit" class="autotype" title="Copies a rectangle skipping pixels with the mask color.">masked_blit</a>(hud_overlay, <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, 0, 0, 0,
                  hud_overlay-&gt;w, hud_overlay-&gt;h);</pre></blockquote>

<p>
   If the GFX_HW_VRAM_BLIT_MASKED bit in the gfx_capabilities flag is set, 
   the current driver supports hardware accelerated masked blits from one 
   part of the screen onto another. This is extremely fast, so when this 
   flag is set it may be worth storing some of your more frequently used 
   sprites in an offscreen portion of the video memory.

<p>
   Warning: if the hardware acceleration flag is not set, masked_blit() will 
   not work correctly when used with a source image in system or video 
   memory so the latter must be a memory bitmap.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#masked_stretch_blit" title="Scales a rectangular area skipping pixels with the mask color.">masked_stretch_blit</a>,
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>.</blockquote>
<div class="al-api"><b>void <a name="masked_stretch_blit">masked_stretch_blit</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *source, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *dest,
                         int source_x, source_y, source_w, source_h,
                         int dest_x, dest_y, dest_w, dest_h);</b></div><br>
   Like masked_blit(), except it can scale images (so the source and 
   destination rectangles don't need to be the same size). This routine 
   doesn't do as much safety checking as the regular masked_blit(): in 
   particular you must take care not to copy from areas outside the source 
   bitmap. Moreover, the source must be a memory bitmap. Example:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *hud_overlay;
      ...
      /* Stretch hud overlay over the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>. */
      <a href="#masked_stretch_blit" class="autotype" title="Scales a rectangular area skipping pixels with the mask color.">masked_stretch_blit</a>(hud_overlay, <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, 0,
                          hud_overlay-&gt;w, hud_overlay-&gt;h,
                          0, 0, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#masked_blit" title="Copies a rectangle skipping pixels with the mask color.">masked_blit</a>,
<a class="xref" href="#stretch_blit" title="Scales a rectangular area from one bitmap to another.">stretch_blit</a>,
<a class="xref" href="#stretch_sprite" title="Stretches a sprite to the destination bitmap.">stretch_sprite</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_sprite">draw_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y);</b></div><br>
   Draws a copy of the sprite bitmap onto the destination bitmap at the 
   specified position. This is almost the same as blit(sprite, bmp, 0, 0, x, 
   y, sprite-&gt;w, sprite-&gt;h), but it uses a masked drawing mode where 
   transparent pixels are skipped, so the background image will show through 
   the masked parts of the sprite. Transparent pixels are marked by a zero 
   in 256-color modes or bright pink for truecolor data (maximum red and 
   blue, zero green). Example:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *spaceship;
      ...
      <a href="#draw_sprite" class="autotype" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, spaceship, x, y);</pre></blockquote>

<p>
   If the GFX_HW_VRAM_BLIT_MASKED bit in the gfx_capabilities flag is set, 
   the current driver supports hardware accelerated sprite drawing when the 
   source image is a video memory bitmap or a sub-bitmap of the screen. This 
   is extremely fast, so when this flag is set it may be worth storing some 
   of your more frequently used sprites in an offscreen portion of the video 
   memory.

<p>
   Warning: if the hardware acceleration flag is not set, draw_sprite() will 
   not work correctly when used with a sprite image in system or video 
   memory so the latter must be a memory bitmap.

<p>
   Although generally not supporting graphics of mixed color depths, as a 
   special case this function can be used to draw 256-color source images 
   onto truecolor destination bitmaps, so you can use palette effects on 
   specific sprites within a truecolor program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_sprite_v_flip" title="Draws the sprite transformed to the destination bitmap.">draw_sprite_v_flip</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#draw_gouraud_sprite" title="Draws a sprite with gouraud shading.">draw_gouraud_sprite</a>,
<a class="xref" href="#stretch_sprite" title="Stretches a sprite to the destination bitmap.">stretch_sprite</a>,
<a class="xref" href="#rotate_sprite" title="Rotates a sprite.">rotate_sprite</a>,
<a class="xref" href="#draw_character_ex" title="Draws non transparent pixels of the sprite with a color.">draw_character_ex</a>,
<a class="xref" href="#draw_rle_sprite" title="Draws an RLE sprite.">draw_rle_sprite</a>,
<a class="xref" href="#draw_compiled_sprite" title="Draws a compiled sprite.">draw_compiled_sprite</a>,
<a class="xref" href="#masked_blit" title="Copies a rectangle skipping pixels with the mask color.">masked_blit</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>.</blockquote>
<div class="al-api"><b>void <a name="stretch_sprite">stretch_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y, int w, int h);</b></div><br>
   Like draw_sprite(), except it can stretch the sprite image to the 
   specified width and height and requires the sprite image and destination 
   bitmap to be of the same color depth. Moreover, the sprite image must 
   be a memory bitmap. Example:
<blockquote class="code"><pre>
      /* Create tunnel like effect. */
      for (step = 1; step < 16; step++) {
         int width = <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a> / step;
         int height = <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a> / step;
         <a href="#stretch_sprite" class="autotype" title="Stretches a sprite to the destination bitmap.">stretch_sprite</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, image, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a> / 2 - width / 2,
                        <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a> / 2 - height / 2, width, height);
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#stretch_blit" title="Scales a rectangular area from one bitmap to another.">stretch_blit</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_sprite_v_flip">draw_sprite_v_flip</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y);</b></div><br>
<div class="al-api-cont"><b>void <a name="draw_sprite_h_flip">draw_sprite_h_flip</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y);</b></div><br>
<div class="al-api-cont"><b>void <a name="draw_sprite_vh_flip">draw_sprite_vh_flip</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y);</b></div><br>
   These are like draw_sprite(), but they additionally flip the image
   vertically, horizontally, or both, respectively. Flipping vertically
   means that the y-axis is reversed, while flipping horizontally means
   that the x-axis is reversed, between the source and the destination.
   This produces exact mirror images, which is not the same as rotating the
   sprite (and it is a lot faster than the rotation routine). The sprite
   must be a memory bitmap. Example:
<blockquote class="code"><pre>
      if (<a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>[KEY_RIGHT])
         <a href="#draw_sprite" class="autotype" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, hero_right, pos_x, pos_y);
      else if (<a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>[KEY_LEFT])
         <a href="#draw_sprite_h_flip" class="autotype" title="Draws the sprite transformed to the destination bitmap.">draw_sprite_h_flip</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, hero_right, pos_x, pos_y);
      else
         <a href="#draw_sprite" class="autotype" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, hero_idle, pos_x, pos_y);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_trans_sprite">draw_trans_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y);</b></div><br>
   Uses the global color_map table or truecolor blender functions to overlay
   the sprite on top of the existing image. This must only be used after you 
   have set up the color mapping table (for 256-color modes) or blender 
   functions (for truecolor modes). Because it involves reading as well as 
   writing the bitmap memory, translucent drawing is very slow if you draw 
   directly to video RAM, so wherever possible you should use a memory 
   bitmap instead. Example:
<blockquote class="code"><pre>
      /* Some one time initialisation code. */
      <a href="#COLOR_MAP" class="autotype" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> global_trans_table;
      <a href="#create_trans_table" class="autotype" title="Fills a color mapping table for translucency effects.">create_trans_table</a>(&global_trans_table, my_palette,
                         128, 128, 128, NULL);
      ...
      if (<a href="#get_color_depth" class="autotype" title="Returns the current pixel color depth.">get_color_depth</a>() == 8)
         <a href="#color_map" class="autotype" title="Global pointer to the color mapping table.">color_map</a> = &global_trans_table;
      else
         <a href="#set_trans_blender" class="autotype" title="Enables a truecolor blender.">set_trans_blender</a>(128, 128, 128, 128);

      <a href="#draw_trans_sprite" class="autotype" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>(buffer, ghost_sprite, x, y);</pre></blockquote>

<p>
   The bitmap and sprite must normally be in the same color depth, but as a
   special case you can draw 32 bit RGBA format sprites onto any hicolor or
   truecolor bitmap, as long as you call set_alpha_blender() first, and you
   can draw 8-bit alpha images onto a 32-bit RGBA destination, as long as you
   call set_write_alpha_blender() first. As draw_sprite() this function skips
   transparent pixels, except if the source sprite is an 8-bit image; if this
   is the case, you should pay attention to properly set up your color map
   table for index 0.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#draw_trans_rle_sprite" title="Draws a translucent RLE sprite.">draw_trans_rle_sprite</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#set_alpha_blender" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>,
<a class="xref" href="#set_write_alpha_blender" title="Enables the special alpha-channel editing mode.">set_write_alpha_blender</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>,
<a class="eref" href="#exxfade" title="Truecolor image loading and fades.">exxfade</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_lit_sprite">draw_lit_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y, int color);</b></div><br>
   In 256-color modes, uses the global color_map table to tint the sprite
   image to the specified color or to light it to the level specified by
   'color', depending on the function which was used to build the table
   (create_trans_table or create_light_table), and draws the resulting image
   to the destination bitmap. In truecolor modes, uses the blender functions
   to light the sprite image using the alpha level specified by 'color' (the
   alpha level which was passed to the blender functions is ignored) and
   draws the resulting image to the destination bitmap. The 'color' parameter
   must be in the range [0-255] whatever its actual meaning is. This must
   only be used after you have set up the color mapping table (for 256-color
   modes) or blender functions (for truecolor modes). Example:
<blockquote class="code"><pre>
      /* Some one time initialisation code. */
      <a href="#COLOR_MAP" class="autotype" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> global_light_table;
      <a href="#create_light_table" class="autotype" title="Fills a color mapping table for lighting effects.">create_light_table</a>(&global_trans_table, my_palette,
                         10, 10, 60, NULL);
      ...
      if (<a href="#get_color_depth" class="autotype" title="Returns the current pixel color depth.">get_color_depth</a>() == 8)
         <a href="#color_map" class="autotype" title="Global pointer to the color mapping table.">color_map</a> = &global_light_table;
      else
         <a href="#set_trans_blender" class="autotype" title="Enables a truecolor blender.">set_trans_blender</a>(40, 40, 255, 255);

      /* Lit the cape with a blueish light. */
      <a href="#draw_lit_sprite" class="autotype" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>(buffer, colored_cape, x, y, 64);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#draw_gouraud_sprite" title="Draws a sprite with gouraud shading.">draw_gouraud_sprite</a>,
<a class="xref" href="#draw_lit_rle_sprite" title="Draws a tinted RLE sprite.">draw_lit_rle_sprite</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_gouraud_sprite">draw_gouraud_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y,
                         int c1, int c2, int c3, int c4);</b></div><br>
   More sophisticated version of draw_lit_sprite(): the 'color' parameter is
   not constant across the sprite image anymore but interpolated between the
   four specified corner colors. The corner values passed to this function
   indicate the strength of the color applied on them, ranging from 0 (no
   strength) to 255 (full strength). Example:
<blockquote class="code"><pre>
      /* Some one time initialisation code. */
      <a href="#COLOR_MAP" class="autotype" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> global_light_table;
      <a href="#create_light_table" class="autotype" title="Fills a color mapping table for lighting effects.">create_light_table</a>(&global_trans_table, my_palette,
                         0, 0, 0, NULL);
      ...
      if (<a href="#get_color_depth" class="autotype" title="Returns the current pixel color depth.">get_color_depth</a>() == 8)
         <a href="#color_map" class="autotype" title="Global pointer to the color mapping table.">color_map</a> = &global_light_table;
      else
         <a href="#set_trans_blender" class="autotype" title="Enables a truecolor blender.">set_trans_blender</a>(0, 0, 0, 128);

      /* Enemies are in shadow unless lit by torch. */
      <a href="#draw_gouraud_sprite" class="autotype" title="Draws a sprite with gouraud shading.">draw_gouraud_sprite</a>(buffer, menacing_spy, x, y,
                          light_strength_on_corner_1,
                          light_strength_on_corner_2,
                          light_strength_on_corner_3,
                          light_strength_on_corner_4);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_character_ex">draw_character_ex</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y,
                       color, bg);</b></div><br>
   Draws a copy of the sprite bitmap onto the destination bitmap at the 
   specified position, drawing transparent pixels in the background color
   (or skipping them if the background color is -1) and setting all other
   pixels to the specified color. Transparent pixels are marked by a zero
   in 256-color modes or bright pink for truecolor data (maximum red and
   blue, zero green). The sprite must be an 8-bit image, even if the
   destination is a truecolor bitmap. Example:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *logo;
      ...
      /* Draw the logo silhouette in red. */
      <a href="#draw_character_ex" class="autotype" title="Draws non transparent pixels of the sprite with a color.">draw_character_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, logo, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a> / 2, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a> / 2,
                        <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(255, 0, 0), -1);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>
<div class="al-api"><b>void <a name="rotate_sprite">rotate_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> angle);</b></div><br>
   Draws the sprite image onto the bitmap. It is placed with its top left
   corner at the specified position, then rotated by the specified angle
   around its centre. The angle is a fixed point 16.16 number in the same
   format used by the fixed point trig routines, with 256 equal to a full
   circle, 64 a right angle, etc. All rotation functions can draw between any
   two bitmaps, even screen bitmaps or bitmaps of different color depth.

<p>
   Positive increments of the angle will make the sprite rotate clockwise
   on the screen, as demonstrated by the Allegro example.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#rotate_scaled_sprite" title="Rotates and stretches a sprite.">rotate_scaled_sprite</a>,
<a class="xref" href="#rotate_sprite_v_flip" title="Rotates and flips a sprite.">rotate_sprite_v_flip</a>,
<a class="xref" href="#rotate_scaled_sprite_v_flip" title="Rotates, stretches and flips a sprite.">rotate_scaled_sprite_v_flip</a>,
<a class="xref" href="#pivot_sprite" title="Rotates a sprite around a specified point.">pivot_sprite</a>,
<a class="xref" href="#pivot_sprite_v_flip" title="Rotates and flips a sprite around a specified point.">pivot_sprite_v_flip</a>,
<a class="xref" href="#pivot_scaled_sprite" title="Rotates and stretches a sprite around a specified point.">pivot_scaled_sprite</a>,
<a class="xref" href="#pivot_scaled_sprite_v_flip" title="Rotates, stretches and flips a sprite around a specified point.">pivot_scaled_sprite_v_flip</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>.</blockquote>
<div class="al-api"><b>void <a name="rotate_sprite_v_flip">rotate_sprite_v_flip</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> angle);</b></div><br>
   Like rotate_sprite, but flips the image vertically before rotating it. To
   flip horizontally, use this routine but add itofix(128) to the angle. To
   flip in both directions, use rotate_sprite() and add itofix(128) to its
   angle.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rotate_sprite" title="Rotates a sprite.">rotate_sprite</a>,
<a class="xref" href="#rotate_scaled_sprite_v_flip" title="Rotates, stretches and flips a sprite.">rotate_scaled_sprite_v_flip</a>,
<a class="xref" href="#pivot_sprite_v_flip" title="Rotates and flips a sprite around a specified point.">pivot_sprite_v_flip</a>,
<a class="xref" href="#pivot_scaled_sprite_v_flip" title="Rotates, stretches and flips a sprite around a specified point.">pivot_scaled_sprite_v_flip</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>.</blockquote>
<div class="al-api"><b>void <a name="rotate_scaled_sprite">rotate_scaled_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y,
                          <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> angle, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> scale);</b></div><br>
   Like rotate_sprite(), but stretches or shrinks the image at the same time 
   as rotating it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rotate_sprite" title="Rotates a sprite.">rotate_sprite</a>,
<a class="xref" href="#rotate_scaled_sprite_v_flip" title="Rotates, stretches and flips a sprite.">rotate_scaled_sprite_v_flip</a>,
<a class="xref" href="#pivot_scaled_sprite" title="Rotates and stretches a sprite around a specified point.">pivot_scaled_sprite</a>,
<a class="xref" href="#pivot_scaled_sprite_v_flip" title="Rotates, stretches and flips a sprite around a specified point.">pivot_scaled_sprite_v_flip</a>.</blockquote>
<div class="al-api"><b>void <a name="rotate_scaled_sprite_v_flip">rotate_scaled_sprite_v_flip</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y,
                                 <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> angle, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> scale);</b></div><br>
   Draws the sprite, similar to rotate_scaled_sprite() except that it flips
   the sprite vertically first.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rotate_sprite" title="Rotates a sprite.">rotate_sprite</a>,
<a class="xref" href="#rotate_scaled_sprite" title="Rotates and stretches a sprite.">rotate_scaled_sprite</a>,
<a class="xref" href="#rotate_sprite_v_flip" title="Rotates and flips a sprite.">rotate_sprite_v_flip</a>.</blockquote>
<div class="al-api"><b>void <a name="pivot_sprite">pivot_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y,
                  int cx, int cy, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> angle);</b></div><br>
   Like rotate_sprite(), but aligns the point in the sprite given by (cx, cy)
   to (x, y) in the bitmap, then rotates around this point.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rotate_sprite" title="Rotates a sprite.">rotate_sprite</a>,
<a class="xref" href="#pivot_scaled_sprite" title="Rotates and stretches a sprite around a specified point.">pivot_scaled_sprite</a>,
<a class="xref" href="#pivot_sprite_v_flip" title="Rotates and flips a sprite around a specified point.">pivot_sprite_v_flip</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>.</blockquote>
<div class="al-api"><b>void <a name="pivot_sprite_v_flip">pivot_sprite_v_flip</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y,
                         int cx, int cy, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> angle);</b></div><br>
   Like rotate_sprite_v_flip(), but aligns the point in the sprite given by
   (cx, cy) to (x, y) in the bitmap, then rotates around this point.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rotate_sprite" title="Rotates a sprite.">rotate_sprite</a>,
<a class="xref" href="#rotate_sprite_v_flip" title="Rotates and flips a sprite.">rotate_sprite_v_flip</a>,
<a class="xref" href="#pivot_sprite" title="Rotates a sprite around a specified point.">pivot_sprite</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>.</blockquote>
<div class="al-api"><b>void <a name="pivot_scaled_sprite">pivot_scaled_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y,
                         int cx, int cy, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> angle, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> scale);</b></div><br>
   Like rotate_scaled_sprite(), but aligns the point in the sprite given by
   (cx, cy) to (x, y) in the bitmap, then rotates and scales around this
   point.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rotate_sprite" title="Rotates a sprite.">rotate_sprite</a>,
<a class="xref" href="#rotate_scaled_sprite" title="Rotates and stretches a sprite.">rotate_scaled_sprite</a>,
<a class="xref" href="#pivot_sprite" title="Rotates a sprite around a specified point.">pivot_sprite</a>,
<a class="xref" href="#pivot_scaled_sprite_v_flip" title="Rotates, stretches and flips a sprite around a specified point.">pivot_scaled_sprite_v_flip</a>.</blockquote>
<div class="al-api"><b>void <a name="pivot_scaled_sprite_v_flip">pivot_scaled_sprite_v_flip</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *sprite, int x, int y,
                                int cx, int cy, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> angle, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> scale);</b></div><br>
   Like rotate_scaled_sprite_v_flip(), but aligns the point in the sprite
   given by (cx, cy) to (x, y) in the bitmap, then rotates and scales around
   this point.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rotate_sprite" title="Rotates a sprite.">rotate_sprite</a>,
<a class="xref" href="#rotate_scaled_sprite_v_flip" title="Rotates, stretches and flips a sprite.">rotate_scaled_sprite_v_flip</a>,
<a class="xref" href="#rotate_sprite_v_flip" title="Rotates and flips a sprite.">rotate_sprite_v_flip</a>,
<a class="xref" href="#pivot_sprite" title="Rotates a sprite around a specified point.">pivot_sprite</a>,
<a class="xref" href="#pivot_scaled_sprite" title="Rotates and stretches a sprite around a specified point.">pivot_scaled_sprite</a>.</blockquote>
<h1><a name="RLE sprites">RLE sprites</a></h1>

<p>
Because bitmaps can be used in so many different ways, the bitmap structure 
is quite complicated, and it contains a lot of data. In many situations, 
though, you will find yourself storing images that are only ever copied to 
the screen, rather than being drawn onto or used as filling patterns, etc. 
If this is the case you may be better off storing your images in RLE_SPRITE 
(read chapter "Structures and types defined by Allegro" for an internal
description of the RLE_SPRITE structure) or COMPILED_SPRITE (see next
chapter) structures rather than regular bitmaps.

<p>
RLE sprites store the image in a simple run-length encoded format, where 
repeated zero pixels are replaced by a single length count, and strings of 
non-zero pixels are preceded by a counter giving the length of the solid 
run. RLE sprites are usually much smaller than normal bitmaps, both because
of the run length compression, and because they avoid most of the overhead 
of the bitmap structure. They are often also faster than normal bitmaps, 
because rather than having to compare every single pixel with zero to 
determine whether it should be drawn, it is possible to skip over a whole 
run of zeros with a single add, or to copy a long run of non-zero pixels 
with fast string instructions.

<p>
Every silver lining has a cloud, though, and in the case of RLE sprites it 
is a lack of flexibility. You can't draw onto them, and you can't flip them, 
rotate them, or stretch them. In fact the only thing you can do with them is 
to blast them onto a bitmap with the draw_rle_sprite() function, which is 
equivalent to using draw_sprite() with a regular bitmap. You can convert 
bitmaps into RLE sprites at runtime, or you can create RLE sprite structures 
in grabber datafiles by making a new object of type 'RLE sprite'.

<p><br>
<div class="al-api"><b><a class="autotype" href="#RLE_SPRITE" title="Stores the contents of an RLE sprite.">RLE_SPRITE</a> *<a name="get_rle_sprite">get_rle_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap);</b></div><br>
   Creates an RLE sprite based on the specified bitmap (which must be a 
   memory bitmap). Remember to free this RLE sprite later to avoid memory
   leaks. Example:
<blockquote class="code"><pre>
      <a href="#RLE_SPRITE" class="autotype" title="Stores the contents of an RLE sprite.">RLE_SPRITE</a> *rle;
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;
      ...
      /* Create RLE sprite from an existent bitmap. */
      rle = <a href="#get_rle_sprite" class="autotype" title="Creates an RLE sprite using a bitmap as source.">get_rle_sprite</a>(bmp);
      if (!rle)
         abort_on_error("Couldn't create RLE sprite!");
         
      /* We don't need the bitmap any more.*/
      <a href="#destroy_bitmap" class="autotype" title="Destroys any type of created bitmap.">destroy_bitmap</a>(bmp);
      
      /* Use the RLE sprite. */
      ...
      /* Destroy it when we don't need it any more. */
      <a href="#destroy_rle_sprite" class="autotype" title="Destroys an RLE sprite.">destroy_rle_sprite</a>(rle);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the created RLE sprite, or NULL if the RLE sprite
   could not be created. Remember to free this RLE sprite later to avoid
   memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_rle_sprite" title="Draws an RLE sprite.">draw_rle_sprite</a>,
<a class="xref" href="#destroy_rle_sprite" title="Destroys an RLE sprite.">destroy_rle_sprite</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_rle_sprite">destroy_rle_sprite</a>(<a class="autotype" href="#RLE_SPRITE" title="Stores the contents of an RLE sprite.">RLE_SPRITE</a> *sprite);</b></div><br>
   Destroys an RLE sprite structure previously returned by get_rle_sprite().
   If you pass a NULL pointer this function won't do anything. Use this once
   you are done with an RLE sprite to avoid memory leaks in your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_rle_sprite" title="Creates an RLE sprite using a bitmap as source.">get_rle_sprite</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_rle_sprite">draw_rle_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#RLE_SPRITE" title="Stores the contents of an RLE sprite.">RLE_SPRITE</a> *sprite,
                     int x, int y);</b></div><br>
   Draws an RLE sprite onto a bitmap at the specified position. Example:
<blockquote class="code"><pre>
      <a href="#RLE_SPRITE" class="autotype" title="Stores the contents of an RLE sprite.">RLE_SPRITE</a> *rle_sprite;
      ...
      <a href="#draw_rle_sprite" class="autotype" title="Draws an RLE sprite.">draw_rle_sprite</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, rle_sprite, 100, 100);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_rle_sprite" title="Creates an RLE sprite using a bitmap as source.">get_rle_sprite</a>,
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#draw_compiled_sprite" title="Draws a compiled sprite.">draw_compiled_sprite</a>,
<a class="xref" href="#draw_trans_rle_sprite" title="Draws a translucent RLE sprite.">draw_trans_rle_sprite</a>,
<a class="xref" href="#draw_lit_rle_sprite" title="Draws a tinted RLE sprite.">draw_lit_rle_sprite</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_trans_rle_sprite">draw_trans_rle_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#RLE_SPRITE" title="Stores the contents of an RLE sprite.">RLE_SPRITE</a> *sprite,
                           int x, int y);</b></div><br>
   Translucent version of draw_rle_sprite(). See the description of 
   draw_trans_sprite(). This must only be used after you have set up the 
   color mapping table (for 256-color modes) or blender functions (for 
   truecolor modes). The bitmap and sprite must normally be in the same 
   color depth, but as a special case you can draw 32-bit RGBA format 
   sprites onto any hicolor or truecolor bitmap, as long as you call 
   set_alpha_blender() first. Example:
<blockquote class="code"><pre>
      /* Some one time initialisation code. */
      <a href="#COLOR_MAP" class="autotype" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> global_trans_table;
      <a href="#create_trans_table" class="autotype" title="Fills a color mapping table for translucency effects.">create_trans_table</a>(&global_trans_table, my_palette,
                         128, 128, 128, NULL);
      ...
      if (<a href="#get_color_depth" class="autotype" title="Returns the current pixel color depth.">get_color_depth</a>() == 8)
         <a href="#color_map" class="autotype" title="Global pointer to the color mapping table.">color_map</a> = &global_trans_table;
      else
         <a href="#set_trans_blender" class="autotype" title="Enables a truecolor blender.">set_trans_blender</a>(128, 128, 128, 128);

      <a href="#draw_trans_rle_sprite" class="autotype" title="Draws a translucent RLE sprite.">draw_trans_rle_sprite</a>(buffer, rle_ghost_sprite, x, y);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_rle_sprite" title="Draws an RLE sprite.">draw_rle_sprite</a>,
<a class="xref" href="#draw_lit_rle_sprite" title="Draws a tinted RLE sprite.">draw_lit_rle_sprite</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#set_alpha_blender" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_lit_rle_sprite">draw_lit_rle_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#RLE_SPRITE" title="Stores the contents of an RLE sprite.">RLE_SPRITE</a> *sprite,
                         int x, y, color);</b></div><br>
   Tinted version of draw_rle_sprite(). See the description of
   draw_lit_sprite(). This must only be used after you have set up the color 
   mapping table (for 256-color modes) or blender functions (for truecolor 
   modes). Example:
<blockquote class="code"><pre>
      /* Some one time initialisation code. */
      <a href="#COLOR_MAP" class="autotype" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> global_light_table;
      <a href="#create_light_table" class="autotype" title="Fills a color mapping table for lighting effects.">create_light_table</a>(&global_trans_table, my_palette,
                         10, 10, 60, NULL);
      ...
      if (<a href="#get_color_depth" class="autotype" title="Returns the current pixel color depth.">get_color_depth</a>() == 8)
         <a href="#color_map" class="autotype" title="Global pointer to the color mapping table.">color_map</a> = &global_light_table;
      else
         <a href="#set_trans_blender" class="autotype" title="Enables a truecolor blender.">set_trans_blender</a>(40, 40, 255, 255);

      /* Lit the cape with a blueish light. */
      <a href="#draw_lit_rle_sprite" class="autotype" title="Draws a tinted RLE sprite.">draw_lit_rle_sprite</a>(buffer, rle_colored_cape, x, y, 64);</pre></blockquote>




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_rle_sprite" title="Draws an RLE sprite.">draw_rle_sprite</a>,
<a class="xref" href="#draw_trans_rle_sprite" title="Draws a translucent RLE sprite.">draw_trans_rle_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>
<h1><a name="Compiled sprites">Compiled sprites</a></h1>

<p>
Compiled sprites are stored as actual machine code instructions that draw a 
specific image onto a bitmap, using mov instructions with immediate data 
values. This is the fastest way to draw a masked image: on slow machines,
up to and including a 486, drawing compiled sprites can be about to five
times as fast as using draw_sprite() with a regular bitmap. On newer
machines the difference is usually negligible.

<p>
Compiled sprites are big, so if memory is tight you should use RLE sprites
instead, and what you can do with them is even more restricted than with RLE
sprites, because they don't support clipping. If you try to draw one off the
edge of a bitmap, you will corrupt memory and probably crash the system. You
can convert bitmaps into compiled sprites at runtime, or you can create
compiled sprite structures in grabber datafiles by making a new object of
type 'Compiled sprite' or 'Compiled x-sprite'.

<p><br>
<div class="al-api"><b><a class="autotype" href="#COMPILED_SPRITE" title="Stores the contents of a compiled sprite.">COMPILED_SPRITE</a> *<a name="get_compiled_sprite">get_compiled_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int planar);</b></div><br>
   Creates a compiled sprite based on the specified bitmap (which must be a 
   memory bitmap). Compiled sprites are device-dependent, so you have to 
   specify whether to compile it into a linear or planar format. Pass FALSE
   as the second parameter if you are going to be drawing it onto memory 
   bitmaps or mode 13h and SVGA screen bitmaps, and pass TRUE if you are 
   going to draw it onto mode-X or Xtended mode screen bitmaps. Example:
<blockquote class="code"><pre>
      <a href="#COMPILED_SPRITE" class="autotype" title="Stores the contents of a compiled sprite.">COMPILED_SPRITE</a> *cspr;
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;
      ...
      /* Create compiled sprite from an existent bitmap. */
      cspr = <a href="#get_compiled_sprite" class="autotype" title="Creates a compiled sprite using a bitmap as source.">get_compiled_sprite</a>(bmp, 0);
      if (!cspr)
         abort_on_error("Couldn't create compiled sprite!");
      
      /* We don't need the bitmap any more.*/
      <a href="#destroy_bitmap" class="autotype" title="Destroys any type of created bitmap.">destroy_bitmap</a>(bmp);
      
      /* Use the compiled sprite. */
      ...
      /* Destroy it when we don't need it any more. */
      <a href="#destroy_compiled_sprite" class="autotype" title="Destroys a compiled sprite.">destroy_compiled_sprite</a>(cspr);
</pre></blockquote>
   Returns a pointer to the created compiled sprite, or NULL if the compiled
   sprite could not be created. Remember to free this compiled sprite later
   to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_compiled_sprite" title="Draws a compiled sprite.">draw_compiled_sprite</a>,
<a class="xref" href="#destroy_compiled_sprite" title="Destroys a compiled sprite.">destroy_compiled_sprite</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_compiled_sprite">destroy_compiled_sprite</a>(<a class="autotype" href="#COMPILED_SPRITE" title="Stores the contents of a compiled sprite.">COMPILED_SPRITE</a> *sprite);</b></div><br>
   Destroys a compiled sprite structure previously returned by 
   get_compiled_sprite(). If you pass a NULL pointer this function won't do
   anything. Use this once you are done with a compiled sprite to avoid
   memory leaks in your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_compiled_sprite" title="Creates a compiled sprite using a bitmap as source.">get_compiled_sprite</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_compiled_sprite">draw_compiled_sprite</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#COMPILED_SPRITE" title="Stores the contents of a compiled sprite.">COMPILED_SPRITE</a> *sprite,
                          int x, int y);</b></div><br>
   Draws a compiled sprite onto a bitmap at the specified position. The 
   sprite must have been compiled for the correct type of bitmap (linear or 
   planar). This function does not support clipping.

<p>
   Hint: if not being able to clip compiled sprites is a problem, a neat 
   trick is to set up a work surface (memory bitmap, mode-X virtual screen, 
   or whatever) a bit bigger than you really need, and use the middle of it 
   as your screen. That way you can draw slightly off the edge without any 
   trouble... 




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_compiled_sprite" title="Creates a compiled sprite using a bitmap as source.">get_compiled_sprite</a>,
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#draw_rle_sprite" title="Draws an RLE sprite.">draw_rle_sprite</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>
<h1><a name="Fonts">Fonts</a></h1>

<p>
Allegro provides routines for loading fonts directly from GRX format .fnt
files, 8x8 or 8x16 BIOS format .fnt files, from bitmap images, from datafiles
or you can import a multiple-range Unicode font by writing a .txt script that
specifies a number of different source files for each range of characters.

<p>
By default, Allegro can only use bitmapped (non-scalable) fonts. If you want
to use TrueType fonts, you will need to use an add-on library which allows
you to load them on the fly (like AllegTTF or Glyph Keeper, listed among
others at <a href="http://www.allegro.cc/">http://www.allegro.cc/</a>) and render them directly, or generate a
bitmapped version of a TrueType font with tools like TTF2PCX
(<a href="http://www.talula.demon.co.uk/ttf2pcx/index.html">http://www.talula.demon.co.uk/ttf2pcx/index.html</a>).

<p><br>
<div class="al-api"><b>void <a name="register_font_file_type">register_font_file_type</a>(const char *ext,
          <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *(*load)(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal, void *param));</b></div><br>
   Informs the load_font() functions of a new file type, providing a routine 
   to read fonts in this format. The function you supply must follow the 
   following prototype:
<blockquote class="code"><pre>
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *load_my_font(const char *filename, <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a> *pal, void *param)
      {
         ...
      }
</pre></blockquote>
   The pal parameter can optionally be used to return a palette for the FONT.
   The parameter param can be anything you like: you can use this to pass
   information to your loading routine, such as for instance the font height,
   the character range to load or the index number of a font in a datafile.
   If you choose to write your own font loading code, your function should be
   prepared to deal with a value of NULL for either of these parameters.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_font" title="Loads a font from a file.">load_font</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="load_font">load_font</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal, void *param);</b></div><br>
   Loads a font from a file. At present, this supports loading fonts from
   a GRX format .fnt file, a 8x8 or 8x16 BIOS format .fnt file, a datafile or
   any bitmap format that can be loaded by load_bitmap().
   
<p>
   If the font contains palette information, then the palette is returned in
   the second parameter, which should be an array of 256 RGB structures 
   (a PALETTE). The pal argument may be NULL. In this case, the palette data,
   if present, is simply not returned.
   
<p>
   The third parameter can be used to pass specific information to a custom
   loader routine. Normally, you can just leave this as NULL. Note that
   another way of loading fonts is embedding them into a datafile and using
   the datafile related functions.

<p>
   Example:
<blockquote class="code"><pre>
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *myfont;
      <a href="#PALETTE" class="autotype" title="Stores palette information.">PALETTE</a> palette;
      ...
      myfont = <a href="#load_font" class="autotype" title="Loads a font from a file.">load_font</a>("my_font.pcx", palette, NULL);
      if (!myfont)
         abort_on_error("Couldn't load <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>!");
      ...
      <a href="#textout_centre_ex" class="autotype" title="Writes a centered string on a bitmap.">textout_centre_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, myfont, "This is my own pretty <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>!",
                        <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a> / 2, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a> / 2, white, black);
      ...
      <a href="#destroy_font" class="autotype" title="Frees the memory being used by a font structure.">destroy_font</a>(myfont);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the font or NULL on error. Remember that you are
   responsible for destroying the font when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#register_font_file_type" title="Register a new font loading function.">register_font_file_type</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#load_dat_font" title="Loads a FONT from an Allegro datafile.">load_dat_font</a>,
<a class="xref" href="#load_bios_font" title="Loads a 8x8 or 8x16 BIOS format font.">load_bios_font</a>,
<a class="xref" href="#load_grx_font" title="Loads a GRX format font.">load_grx_font</a>,
<a class="xref" href="#load_grx_or_bios_font" title="Loads either a BIOS or GRX format font.">load_grx_or_bios_font</a>,
<a class="xref" href="#load_bitmap_font" title="Grabs a font from a bitmap file.">load_bitmap_font</a>,
<a class="xref" href="#load_txt_font" title="Loads a font script.">load_txt_font</a>,
<a class="xref" href="#destroy_font" title="Frees the memory being used by a font structure.">destroy_font</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exfont" title="">exfont</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_font">destroy_font</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f);</b></div><br>
   Frees the memory being used by a font structure. Don't use this on the
   default global Allegro font or any text routines using it could crash. You
   should use this only on fonts you have loaded manually after you are done
   with them, to prevent memory leaks in your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_datafile_object" title="Loads a specific object from a datafile.">load_datafile_object</a>,
<a class="xref" href="#load_font" title="Loads a font from a file.">load_font</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exfont" title="">exfont</a>.</blockquote>
<div class="al-api"><b>void <a name="make_trans_font">make_trans_font</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f);</b></div><br>
   This function converts a font to use transparency for drawing. That is, each
   glyph in the font will be drawn with draw_trans_sprite, so you can use the
   same blenders as with draw_trans_sprite to draw the font. One common use of
   this is to load a bitmap font with an alpha channel, and therefore get
   anti-aliased text output by using Allegro's alpha blender. Here's an example
   how to do that:

   <blockquote class="code"><pre>
   <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *f = <a href="#load_font" class="autotype" title="Loads a font from a file.">load_font</a>("alphafont.tga", NULL, NULL);
   <a href="#make_trans_font" class="autotype" title="Makes a font use transparency.">make_trans_font</a>(f);
   <a href="#set_alpha_blender" class="autotype" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>();
   <a href="#textprintf_centre_ex" class="autotype" title="Formatted centered output of a string.">textprintf_centre_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, f, 320, 240, -1, -1, "Anti-aliased Font!");</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#is_trans_font" title="Returns TRUE if a font uses transparency.">is_trans_font</a>,
<a class="xref" href="#set_alpha_blender" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>,
<a class="xref" href="#load_font" title="Loads a font from a file.">load_font</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>.</blockquote>
<div class="al-api"><b>int <a name="is_trans_font">is_trans_font</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f)</b></div><br>
   This function checks if the given font is a color font using
   draw_trans_sprite to render glyphs.
<p><b>Return value:</b>
   Returns TRUE if the font uses transparency, FALSE if it does not.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#make_trans_font" title="Makes a font use transparency.">make_trans_font</a>,
<a class="xref" href="#is_color_font" title="Returns TRUE if a font is a color font.">is_color_font</a>,
<a class="xref" href="#is_mono_font" title="Returns TRUE if a font is a monochrome font.">is_mono_font</a>.</blockquote>
<div class="al-api"><b>int <a name="is_color_font">is_color_font</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f)</b></div><br>
   This function checks if the given font is a color font, as opposed to a
   monochrome font.
<p><b>Return value:</b>
   Returns TRUE if the font is a color font, FALSE if it is not.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#is_trans_font" title="Returns TRUE if a font uses transparency.">is_trans_font</a>,
<a class="xref" href="#is_mono_font" title="Returns TRUE if a font is a monochrome font.">is_mono_font</a>.</blockquote>
<div class="al-api"><b>int <a name="is_mono_font">is_mono_font</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f)</b></div><br>
   This function checks if the given font is a mono font, as opposed to a
   color font.
<p><b>Return value:</b>
   Returns TRUE if the font is a monochrome font, FALSE if it is not.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#is_trans_font" title="Returns TRUE if a font uses transparency.">is_trans_font</a>,
<a class="xref" href="#is_color_font" title="Returns TRUE if a font is a color font.">is_color_font</a>.</blockquote>
<div class="al-api"><b>int <a name="font_has_alpha">font_has_alpha</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f)</b></div><br>
   This function goes through all pixels of all glyphs in the font and looks for
   alpha values.
<p><b>Return value:</b>
   Returns TRUE if any alpha pixels are found, else FALSE.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#is_trans_font" title="Returns TRUE if a font uses transparency.">is_trans_font</a>.</blockquote>
<div class="al-api"><b>int *<a name="is_compatible_font">is_compatible_font</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f1, <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f2)</b></div><br>
   This function compares the two fonts, which you can use to find out if
   Allegro is capable of merging them.
<p><b>Return value:</b>
   Returns TRUE if the two fonts are of the same general type (both are color
   fonts or both are monochrome fonts, for instance).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#merge_fonts" title="Merges two fonts into one font.">merge_fonts</a>,
<a class="xref" href="#is_trans_font" title="Returns TRUE if a font uses transparency.">is_trans_font</a>,
<a class="xref" href="#is_color_font" title="Returns TRUE if a font is a color font.">is_color_font</a>,
<a class="xref" href="#is_mono_font" title="Returns TRUE if a font is a monochrome font.">is_mono_font</a>.</blockquote>
<div class="al-api"><b>int <a name="get_font_ranges">get_font_ranges</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f)</b></div><br>
   Use this function to find out the number of character ranges in a font. You
   should query each of these ranges with get_font_range_begin() and
   get_font_range_end() to find out what characters are available in the
   font. Example:
<blockquote class="code"><pre>
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *f;
      int range;
      int n;
      ...
      
      range = <a href="#get_font_ranges" class="autotype" title="Returns the number of character ranges in a font.">get_font_ranges</a>(f);
      printf("The <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a> has %d character ranges:\n", range);
      for (n = 0; n &lt; range; n++)
         printf("Range %d from 0x%03x - 0x%03x\n",
                <a href="#get_font_range_begin" class="autotype" title="Returns the start of a character range in a font.">get_font_range_begin</a>(f, n),
                <a href="#get_font_range_end" class="autotype" title="Returns the last character of a character range in a font.">get_font_range_end</a>(f, n));</pre></blockquote>
<p><b>Return value:</b>
   Returns the number of continuous character ranges in a font, or -1 if that
   information is not available.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_font_range_begin" title="Returns the start of a character range in a font.">get_font_range_begin</a>,
<a class="xref" href="#get_font_range_end" title="Returns the last character of a character range in a font.">get_font_range_end</a>,
<a class="xref" href="#transpose_font" title="Transposes all characters in a font.">transpose_font</a>.</blockquote>
<div class="al-api"><b>int <a name="get_font_range_begin">get_font_range_begin</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, int range)</b></div><br>
   This function allows you to find out the start of a specific character
   range for a font. You can pass -1 for the <tt>`range'</tt> parameter if you want to
   know the start of the whole font range, or a number from 0 to (but not
   including) get_font_ranges(f) to get the start of a specific character
   range in the font. Example:
<blockquote class="code"><pre>
      printf("The <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a> has a character range of %d - %d\n",
             <a href="#get_font_range_begin" class="autotype" title="Returns the start of a character range in a font.">get_font_range_begin</a>(<a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, -1),
             <a href="#get_font_range_end" class="autotype" title="Returns the last character of a character range in a font.">get_font_range_end</a>(<a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, -1));</pre></blockquote>
<p><b>Return value:</b>
   Returns the first character in the font range, or -1 if that information
   is not available.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_font_ranges" title="Returns the number of character ranges in a font.">get_font_ranges</a>,
<a class="xref" href="#get_font_range_end" title="Returns the last character of a character range in a font.">get_font_range_end</a>,
<a class="xref" href="#transpose_font" title="Transposes all characters in a font.">transpose_font</a>.</blockquote>
<div class="al-api"><b>int <a name="get_font_range_end">get_font_range_end</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, int range)</b></div><br>
   This function allows you to find out the index to the last character of a
   character range for a font. You can pass -1 for the range parameter if you
   want to know the start of the whole font range, or a number from 0 to (but
   not including) get_font_ranges(f) to get the start of a specific character
   range in the font. You should check the start and end of all font ranges to
   see if a specific character is actually available in the font. Not all
   characters in the range returned by get_font_range_begin(f, -1) and
   get_font_range_end(f, -1) need to be available! Example:
<blockquote class="code"><pre>
      printf("The <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a> has a character range of %d - %d\n",
             <a href="#get_font_range_begin" class="autotype" title="Returns the start of a character range in a font.">get_font_range_begin</a>(<a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, -1),
             <a href="#get_font_range_end" class="autotype" title="Returns the last character of a character range in a font.">get_font_range_end</a>(<a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, -1));</pre></blockquote>
<p><b>Return value:</b>
   Returns the last character in the font range, or -1 if that information is
   not available.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_font_ranges" title="Returns the number of character ranges in a font.">get_font_ranges</a>,
<a class="xref" href="#get_font_range_begin" title="Returns the start of a character range in a font.">get_font_range_begin</a>,
<a class="xref" href="#transpose_font" title="Transposes all characters in a font.">transpose_font</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="extract_font_range">extract_font_range</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, int begin, int end)</b></div><br>
   This function extracts a character range from a font and returns a new font
   that contains only the range of characters selected by this function. You
   can pass -1 for either the lower or upper bound if you want to select all
   characters from the start or to the end of the font.
   Example:
<blockquote class="code"><pre>
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *myfont;
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *capitals;
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *fontcopy;
      ...
      /* Create a <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a> of only capital letters */
      capitals = <a href="#extract_font_range" class="autotype" title="Extracts a range of characters from a font.">extract_font_range</a>(myfont, 'A', 'Z');

      /* Create a copy of the <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a> */
      fontcopy = <a href="#extract_font_range" class="autotype" title="Extracts a range of characters from a font.">extract_font_range</a>(myfont, -1, -1);
      ...
      <a href="#destroy_font" class="autotype" title="Frees the memory being used by a font structure.">destroy_font</a>(capitals);
      <a href="#destroy_font" class="autotype" title="Frees the memory being used by a font structure.">destroy_font</a>(fontcopy);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the new font or NULL on error. Remember that you are
   responsible for destroying the font when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_font_range_begin" title="Returns the start of a character range in a font.">get_font_range_begin</a>,
<a class="xref" href="#get_font_range_end" title="Returns the last character of a character range in a font.">get_font_range_end</a>,
<a class="xref" href="#merge_fonts" title="Merges two fonts into one font.">merge_fonts</a>,
<a class="xref" href="#transpose_font" title="Transposes all characters in a font.">transpose_font</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exfont" title="">exfont</a>.</blockquote>
<div class="al-api"><b>int <a name="transpose_font">transpose_font</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, int drange)</b></div><br>
   This function transposes all characters in a font, effectively remapping the
   font. Example:
<blockquote class="code"><pre>
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *myfont;
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *capitals;
      ...
      /* Create a <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a> of only capital letters */
      capitals = <a href="#extract_font_range" class="autotype" title="Extracts a range of characters from a font.">extract_font_range</a>(myfont, 'A', 'Z');

      /* Now transpose the characters in the <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a> so that they will be used */
      /*  for the lower case letters a-z */
      <a href="#transpose_font" class="autotype" title="Transposes all characters in a font.">transpose_font</a>(capitals, 'a'-'A');
      <a href="#textout_ex" class="autotype" title="Writes a string on a bitmap.">textout_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, capitals, "allcaps",
                 100, 100, <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(255,255,255), 0);</pre></blockquote>
<p><b>Return value:</b>
   Returns 0 on success, -1 on failure.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_font_range_begin" title="Returns the start of a character range in a font.">get_font_range_begin</a>,
<a class="xref" href="#get_font_range_end" title="Returns the last character of a character range in a font.">get_font_range_end</a>,
<a class="xref" href="#merge_fonts" title="Merges two fonts into one font.">merge_fonts</a>,
<a class="xref" href="#extract_font_range" title="Extracts a range of characters from a font.">extract_font_range</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="merge_fonts">merge_fonts</a>(<a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f1, <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f2)</b></div><br>
   This function merges the character ranges from two fonts and returns a new
   font containing all characters in the old fonts. In general, you cannot
   merge fonts of different types (eg, TrueType fonts and bitmapped fonts),
   but as a special case, this function can promote a monochrome bitmapped
   font to a color font and merge those. Example:
<blockquote class="code"><pre>
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *myfont;
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *myfancy_font;
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *lower_range;
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *upper_range;
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *capitals;
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *combined_font;
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *tempfont;
      ...
      /* Create a <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a> that contains the capitals from  */
      /* the fancy <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a> but other characters from myfont */
      lower_range = <a href="#extract_font_range" class="autotype" title="Extracts a range of characters from a font.">extract_font_range</a>(myfont, -1, 'A'-1);
      upper_range = <a href="#extract_font_range" class="autotype" title="Extracts a range of characters from a font.">extract_font_range</a>(myfont, 'Z'+1, -1);
      capitals = <a href="#extract_font_range" class="autotype" title="Extracts a range of characters from a font.">extract_font_range</a>(myfancy_font, 'A', 'Z');

      tempfont = <a href="#merge_fonts" class="autotype" title="Merges two fonts into one font.">merge_fonts</a>(lower_range, capitals);
      combined_font = <a href="#merge_fonts" class="autotype" title="Merges two fonts into one font.">merge_fonts</a>(tempfont, upper_range);

      /* Clean up temporary fonts */
      <a href="#destroy_font" class="autotype" title="Frees the memory being used by a font structure.">destroy_font</a>(lower_range);
      <a href="#destroy_font" class="autotype" title="Frees the memory being used by a font structure.">destroy_font</a>(upper_range);
      <a href="#destroy_font" class="autotype" title="Frees the memory being used by a font structure.">destroy_font</a>(capitals);
      <a href="#destroy_font" class="autotype" title="Frees the memory being used by a font structure.">destroy_font</a>(tempfont);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the new font or NULL on error. Remember that you are
   responsible for destroying the font when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#extract_font_range" title="Extracts a range of characters from a font.">extract_font_range</a>,
<a class="xref" href="#is_trans_font" title="Returns TRUE if a font uses transparency.">is_trans_font</a>,
<a class="xref" href="#is_color_font" title="Returns TRUE if a font is a color font.">is_color_font</a>,
<a class="xref" href="#is_mono_font" title="Returns TRUE if a font is a monochrome font.">is_mono_font</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exfont" title="">exfont</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="load_dat_font">load_dat_font</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal, void *param)</b></div><br>
   Loads a FONT from an Allegro datafile. You can set param parameter to
   point to an array that holds two strings that identify the font and the 
   palette in the datafile by name.
   The first string in this list is the name of the font. You can pass NULL
   here to just load the first font found in the datafile. The second string
   can be used to specify the name of the palette associated with the font.
   This is only returned if the pal parameter is not NULL. If you pass NULL
   for the name of the palette, the last palette found before the font was
   found is returned.
   You can also pass NULL for param, which is treated as if you had passed
   NULL for both strings separately. In this case, the function will simply
   load the first font it finds from the datafile and the palette that
   precedes it.

<p>
   For example, suppose you have a datafile named <tt>`fonts.dat'</tt> with the
   following contents:
<blockquote class="text"><pre>
      FONT  FONT_1_DATA
      FONT  FONT_2_DATA
      FONT  FONT_3_DATA
      PAL   FONT_1_PALETTE
      PAL   FONT_2_PALETTE
</pre></blockquote>
   Then the following code will load FONT_1_DATA as a FONT and return
   FONT_1_PALETTE as the palette:
<blockquote class="code"><pre>
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *f;
      <a href="#PALETTE" class="autotype" title="Stores palette information.">PALETTE</a> pal;
      char *names[] = { "FONT_1_DATA", "FONT_1_PALETTE" }
      
      f = <a href="#load_dat_font" class="autotype" title="Loads a FONT from an Allegro datafile.">load_dat_font</a>("fonts.dat", pal, names);
</pre></blockquote>
   If instead you want to load the second font, FONT_2, from the datafile,
   you would use:
<blockquote class="code"><pre>
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *f;
      <a href="#PALETTE" class="autotype" title="Stores palette information.">PALETTE</a> pal;
      char *names[] = { "FONT_2_DATA", "FONT_2_PALETTE" }
      
      f = <a href="#load_dat_font" class="autotype" title="Loads a FONT from an Allegro datafile.">load_dat_font</a>("fonts.dat", pal, names);
</pre></blockquote>
   If you want to load the third font, but not bother with a palette, use:
<blockquote class="code"><pre>
      <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *f;
      char *names[] = { "FONT_3_DATA", NULL }
      
      f = <a href="#load_dat_font" class="autotype" title="Loads a FONT from an Allegro datafile.">load_dat_font</a>("fonts.dat", NULL, names);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the font or NULL on error. Remember that you are
   responsible for destroying the font when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#register_font_file_type" title="Register a new font loading function.">register_font_file_type</a>,
<a class="xref" href="#load_font" title="Loads a font from a file.">load_font</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="load_bios_font">load_bios_font</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal, void *param)</b></div><br>
   Loads a 8x8 or 8x16 BIOS format font. You shouldn't normally call this 
   routine directly.
<p><b>Return value:</b>
   Returns a pointer to the font or NULL on error. Remember that you are
   responsible for destroying the font when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#register_font_file_type" title="Register a new font loading function.">register_font_file_type</a>,
<a class="xref" href="#load_font" title="Loads a font from a file.">load_font</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="load_grx_font">load_grx_font</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal, void *param)</b></div><br>
   Loads a GRX format font. You shouldn't normally call this routine
   directly.
<p><b>Return value:</b>
   Returns a pointer to the font or NULL on error. Remember that you are
   responsible for destroying the font when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#register_font_file_type" title="Register a new font loading function.">register_font_file_type</a>,
<a class="xref" href="#load_font" title="Loads a font from a file.">load_font</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="load_grx_or_bios_font">load_grx_or_bios_font</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal, void *param)</b></div><br>
   Loads either a BIOS or GRX format font. You shouldn't normally call this 
   routine directly.
<p><b>Return value:</b>
   Returns a pointer to the font or NULL on error. Remember that you are
   responsible for destroying the font when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#register_font_file_type" title="Register a new font loading function.">register_font_file_type</a>,
<a class="xref" href="#load_font" title="Loads a font from a file.">load_font</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="load_bitmap_font">load_bitmap_font</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal, void *param)</b></div><br>
   Tries to grab a font from a bitmap. The bitmap can be in any format that
   load_bitmap understands.

<p>
   The size of each character is determined by the layout of the image, which
   should be a rectangular grid containing all the ASCII characters from
   space (32) up to the tilde (126). The way the characters are separated
   depends on the color depth of the image file:
<ul><li>
   paletted (8 bit) image file
      Use color 0 for the transparent portions of the characters and fill the 
      spaces between each letter with color 255.  
<li>
   High (15/16 bit) and true (24/32 bit) color image file
      Use bright pink (maximum red and blue, zero green) for the transparent
      portions of the characters and fill the spaces between each letter with
      bright yellow (maximum red and green, zero blue).
</ul>
   
<p>
   Note that in each horizontal row the bounding boxes around the characters 
   should align and have the same height.
   
<p>
   Probably the easiest way to get to grips with how this works is to load up 
   the <tt>`demo.dat'</tt> file and export the TITLE_FONT into a PCX file. Have a look
   at the resulting picture in your paint program: that is the format a font
   should be in.

<p>
   Take care with high and true color fonts: Allegro will convert these to the
   current color depth when you load the font. If you try to use a font on
   a bitmap with a different color depth Allegro will do color conversions on
   the fly, which will be rather slow. For optimal performance you should
   set the color depth to the color depth you want to use before loading any
   fonts.
<p><b>Return value:</b>
   Returns a pointer to the font or NULL on error. Remember that you are
   responsible for destroying the font when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#register_font_file_type" title="Register a new font loading function.">register_font_file_type</a>,
<a class="xref" href="#load_font" title="Loads a font from a file.">load_font</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#grab_font_from_bitmap" title="Grabs a font from a bitmap">grab_font_from_bitmap</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="grab_font_from_bitmap">grab_font_from_bitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp)</b></div><br>
   This function is the work-horse of load_bitmap_font, and can be used to
   grab a font from a bitmap in memory. You can use this if you want to
   generate or modify a font at runtime. The bitmap should follow the layout
   described for load_bitmap_font.
<p><b>Return value:</b>
   Returns a pointer to the font or NULL on error. Remember that you are
   responsible for destroying the font when you are finished with it to
   avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_bitmap_font" title="Grabs a font from a bitmap file.">load_bitmap_font</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="load_txt_font">load_txt_font</a>(const char *filename, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *pal, void *param)</b></div><br>
   This function can be used to load scripted fonts. The script file
   contains a number of lines in the format "filename start end", which
   specify the source file for that range of characters, the Unicode value of
   the first character in the range, and the end character in the range
   (optional, if left out, the entire input file will be grabbed). If the
   filename is replaced by a hyphen, more characters will be grabbed from the
   previous input file.
   For example, the script:
   <blockquote class="text"><pre>
      ascii.fnt 0x20 0x7F
      - 0xA0 0xFF
      dingbats.fnt 0x1000
   </pre></blockquote>
   would import the first 96 characters from ascii.fnt as the range
   0x20-0x7F, the next 96 characters from ascii.fnt as the range 0xA0-0xFF,
   and the entire contents of dingbats.fnt starting at Unicode position
   0x1000.
<p><b>Return value:</b>
   Returns a pointer to the font or NULL on error. Remember that you are
   responsible for destroying the font when you are finished with it to
   avoid memory leaks.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#register_font_file_type" title="Register a new font loading function.">register_font_file_type</a>,
<a class="xref" href="#load_font" title="Loads a font from a file.">load_font</a>.</blockquote>
<h1><a name="Text output">Text output</a></h1>

<p>
Allegro provides text output routines that work with both monochrome and 
color fonts, which can contain any number of Unicode character ranges. The 
grabber program can create fonts from sets of characters drawn in a bitmap 
file (see <a href="grabber.html">grabber.txt</a> for more information), and can also import GRX or BIOS 
format font files. The font structure contains a number of hooks that can be 
used to extend it with your own custom drawing code: see the definition in 
allegro/text.h for details.

<p><br>
<div class="al-api"><b>extern <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *<a name="font">font</a>;</b></div><br>
   A simple 8x8 fixed size font (the mode 13h BIOS default). If you want to 
   alter the font used by the GUI routines, change this to point to one of 
   your own fonts. This font contains the standard ASCII (U+20 to U+7F), 
   Latin-1 (U+A1 to U+FF), and Latin Extended-A (U+0100 to U+017F) character 
   ranges.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>extern int <a name="allegro_404_char">allegro_404_char</a>;</b></div><br>
   When Allegro cannot find a glyph it needs in a font, it will instead
   output the character given in allegro_404_char. By default, this is set to
   the caret symbol, <tt>`^'</tt>, but you can change this global to use any other
   character instead. Example:
<blockquote class="code"><pre>
      /* Show unknown glyphs with an asterisk. */
      <a href="#allegro_404_char" class="autotype" title="Character used when Allegro cannot find a glyph.">allegro_404_char</a> = '*';</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>.</blockquote>
<div class="al-api"><b>int <a name="text_length">text_length</a>(const <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, const char *str);</b></div><br>
   Returns the length (in pixels) of a string in the specified font. Example:
<blockquote class="code"><pre>
      int width = <a href="#text_length" class="autotype" title="Returns the length of a string in pixels.">text_length</a>(<a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, "I love spam");
      ...
      bmp = <a href="#create_bitmap" class="autotype" title="Creates a memory bitmap.">create_bitmap</a>(width, height);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#text_height" title="Returns the height of a font in pixels.">text_height</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>,
<a class="eref" href="#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>,
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>int <a name="text_height">text_height</a>(const <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f)</b></div><br>
   Returns the height (in pixels) of the specified font. Example:
<blockquote class="code"><pre>
      int height = <a href="#text_height" class="autotype" title="Returns the height of a font in pixels.">text_height</a>(<a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>);
      ...
      bmp = <a href="#create_bitmap" class="autotype" title="Creates a memory bitmap.">create_bitmap</a>(width, height);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#text_length" title="Returns the length of a string in pixels.">text_length</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>,
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>,
<a class="eref" href="#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exsyscur" title="">exsyscur</a>,
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b>void <a name="textout_ex">textout_ex</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, const char *s,
                int x, int y, int color, int bg);</b></div><br>
   Writes the string <tt>`s'</tt> onto the bitmap at position x, y, using the
   specified font, foreground color and background color. If the background
   color is -1, then the text is written transparently. If the foreground
   color is -1 and a color font is in use, it will be drawn using the colors
   from the original font bitmap (the one you imported into the grabber
   program), which allows multicolored text output. For high and true color
   fonts, the foreground color is ignored and always treated as -1. Example:
<blockquote class="code"><pre>
      /* Show the program's version in blue letters. */
      <a href="#textout_ex" class="autotype" title="Writes a string on a bitmap.">textout_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, "v4.2.0-beta2", 10, 10,
                 <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 0, 255), -1);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>,
<a class="xref" href="#textout_right_ex" title="Writes a right aligned string on a bitmap.">textout_right_ex</a>,
<a class="xref" href="#textout_justify_ex" title="Draws justified text within a region.">textout_justify_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#text_height" title="Returns the height of a font in pixels.">text_height</a>,
<a class="xref" href="#text_length" title="Returns the length of a string in pixels.">text_length</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="textout_centre_ex">textout_centre_ex</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, const char *s,
                       int x, y, int color, int bg);</b></div><br>
   Like textout_ex(), but interprets the x coordinate as the centre rather
   than the left edge of the string. Example:
<blockquote class="code"><pre>
      /* Important texts go in the middle. */
      width = <a href="#text_length" class="autotype" title="Returns the length of a string in pixels.">text_length</a>("GAME OVER");
      <a href="#textout_centre_ex" class="autotype" title="Writes a centered string on a bitmap.">textout_centre_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, "GAME OVER",
                        <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a> / 2, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a> / 2,
                        <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(255, 0, 0), <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 0, 0));</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="textout_right_ex">textout_right_ex</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, const char *s,
                      int x, int y, int color, int bg);</b></div><br>
   Like textout_ex(), but interprets the x coordinate as the right rather
   than the left edge of the string. Example:
<blockquote class="code"><pre>
      <a href="#textout_right_ex" class="autotype" title="Writes a right aligned string on a bitmap.">textout_right_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, "Look at this color!",
                       <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a> - 10, 10, my_yellow, -1);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_right_ex" title="Formatted right aligned output of a string.">textprintf_right_ex</a>.</blockquote>
<div class="al-api"><b>void <a name="textout_justify_ex">textout_justify_ex</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, const char *s,
                        int x1, int x2, int y, int diff, int color,
                        int bg);</b></div><br>
   Draws justified text within the region x1-x2. If the amount of spare
   space is greater than the diff value, it will give up and draw regular
   left justified text instead. Example:
<blockquote class="code"><pre>
      char *lines[] = {"Draws justified text",
                       "within the specified",
                       "x2-x1 area. But not",
                       "T H I S !", NULL};
      /* Show the justification marker. */
      <a href="#vline" class="autotype" title="Draws a vertical line onto the bitmap.">vline</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 200, 0, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>-1, <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 0, 0));
      /* Draw all the lines until we reach a NULL entry. */
      for (num = 0, y = 0; lines[num]; num++, y += <a href="#text_height" class="autotype" title="Returns the height of a font in pixels.">text_height</a>(<a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>))
         <a href="#textout_justify_ex" class="autotype" title="Draws justified text within a region.">textout_justify_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, lines[num], 0, 200,
                            y, 80, <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 0, 0),
                            <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(255, 255, 255));</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_justify_ex" title="Formatted justified output of a string.">textprintf_justify_ex</a>.</blockquote>
<div class="al-api"><b>void <a name="textprintf_ex">textprintf_ex</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, int x, int y,
                   int color, int bg, const char *fmt, ...);</b></div><br>
   Formatted text output, using a printf() style format string. Due to an
   internal limitation, this function can't be used for extremely long texts.
   If you happen to reach this limit, you can work around it by using
   uszprintf() and textout_ex(), which don't have any. Example:
<blockquote class="code"><pre>
      int player_score;
      ...
      <a href="#textprintf_ex" class="autotype" title="Formatted output of a string.">textprintf_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, 10, 10, <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(255, 100, 200),
                    -1, "Score: %d", player_score);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>,
<a class="xref" href="#textprintf_right_ex" title="Formatted right aligned output of a string.">textprintf_right_ex</a>,
<a class="xref" href="#textprintf_justify_ex" title="Formatted justified output of a string.">textprintf_justify_ex</a>,
<a class="xref" href="#text_height" title="Returns the height of a font in pixels.">text_height</a>,
<a class="xref" href="#text_length" title="Returns the length of a string in pixels.">text_length</a>,
<a class="xref" href="#uszprintf" title="Writes formatted data into a buffer, specifying size.">uszprintf</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="textprintf_centre_ex">textprintf_centre_ex</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, int x, int y,
                          int color, int bg, const char *fmt, ...);</b></div><br>
   Like textprintf_ex(), but interprets the x coordinate as the centre rather
   than the left edge of the string. This function shares the text length
   limitation of textprintf_ex(). Example:
<blockquote class="code"><pre>
      <a href="#textprintf_centre_ex" class="autotype" title="Formatted centered output of a string.">textprintf_centre_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a> / 2, 120,
                           <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 100, 243), -1,
                           "Your best score so far was %d!",
                           total_max_points);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="textprintf_right_ex">textprintf_right_ex</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, int x, y, color, bg,
                         const char *fmt, ...);</b></div><br>
   Like textprintf_ex(), but interprets the x coordinate as the right rather
   than the left edge of the string. This function shares the text length
   limitation of textprintf_ex(). Example:
<blockquote class="code"><pre>
      <a href="#textprintf_right_ex" class="autotype" title="Formatted right aligned output of a string.">textprintf_right_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a> - 10, 10,
                          <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(200, 200, 20), -1,
                          "%d bullets left", player_ammo);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#textout_right_ex" title="Writes a right aligned string on a bitmap.">textout_right_ex</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmouse" title="Getting input from the mouse.">exmouse</a>.</blockquote>
<div class="al-api"><b>void <a name="textprintf_justify_ex">textprintf_justify_ex</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const <a class="autotype" href="#FONT" title="Stores an Allegro font.">FONT</a> *f, int x1, x2, y,
                           diff, color, bg, const char *fmt, ...);</b></div><br>
   Like textout_justify_ex(), but using a printf() style format string. This
   function shares the text length limitation of textprintf_ex(). Example:
<blockquote class="code"><pre>
      char *lines[] = {"Line %02d: Draws justified text",
                       "Line %02d: within the specified",
                       "Line %02d: x2-x1 area. But not",
                       "Line %02d: T H I S !", NULL};
      /* Show the justification marker. */
      <a href="#vline" class="autotype" title="Draws a vertical line onto the bitmap.">vline</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 300, 0, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>-1, <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 0, 0));
      /* Draw all the lines until we reach a NULL entry. */
      for (num = 0, y = 0; lines[num]; num++, y += <a href="#text_height" class="autotype" title="Returns the height of a font in pixels.">text_height</a>(<a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>))
         <a href="#textprintf_justify_ex" class="autotype" title="Formatted justified output of a string.">textprintf_justify_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, 0, 300, y, 180,
                               <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 0, 0), <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(255, 255, 255),
                               lines[num], num);</pre></blockquote>




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#textout_justify_ex" title="Draws justified text within a region.">textout_justify_ex</a>.</blockquote>
<h1><a name="Polygon rendering">Polygon rendering</a></h1>

<p>
All the 3d functions that accept a <tt>`type'</tt> parameter are asking for a polygon
rendering mode, which can be any of the following POLYTYPE_* values. If the
CPU_MMX flag of the cpu_capabilities global variable is set, the GRGB and
truecolor *LIT routines will be optimised using MMX instructions. If the
CPU_3DNOW flag is set, the truecolor PTEX*LIT routines will take advantage of
the 3DNow! CPU extensions.

<p>
Using MMX for *LIT routines has a side effect: normally (without MMX), these
routines use the blender functions used also for other lighting functions,
set with set_trans_blender() or set_blender_mode(). The MMX versions only use
the RGB value passed to set_trans_blender() and do the linear interpolation
themselves. Therefore a new set of blender functions passed to
set_blender_mode() is ignored.

<p><br>
<div class="al-api"><b>#define <a name="POLYTYPE_FLAT">POLYTYPE_FLAT</a></b></div><br>
   A simple flat shaded polygon, taking the color from the <tt>`c'</tt> value of the
   first vertex. This polygon type is affected by the drawing_mode() function,
   so it can be used to render XOR or translucent polygons.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>.</blockquote>
<div class="al-api"><b>#define <a name="POLYTYPE_GCOL">POLYTYPE_GCOL</a></b></div><br>
   A single-color gouraud shaded polygon. The colors for each vertex are taken
   from the <tt>`c'</tt> value, and interpolated across the polygon. This is very fast,
   but will only work in 256-color modes if your palette contains a smooth
   gradient between the colors. In truecolor modes it interprets the color as
   a packed, display-format value as produced by the makecol() function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>#define <a name="POLYTYPE_GRGB">POLYTYPE_GRGB</a></b></div><br>
   A gouraud shaded polygon which interpolates RGB triplets rather than a
   single color. In 256-color modes this uses the global rgb_map table to
   convert the result to an 8-bit paletted color, so it must only be used
   after you have set up the RGB mapping table! The colors for each vertex are
   taken from the <tt>`c'</tt> value, which is interpreted as a 24-bit RGB triplet
   (0xFF0000 is red, 0x00FF00 is green, and 0x0000FF is blue).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>#define <a name="POLYTYPE_ATEX">POLYTYPE_ATEX</a></b></div><br>
   An affine texture mapped polygon. This stretches the texture across the
   polygon with a simple 2d linear interpolation, which is fast but not
   mathematically correct. It can look OK if the polygon is fairly small or
   flat-on to the camera, but because it doesn't deal with perspective
   foreshortening, it can produce strange warping artifacts. To see what this
   means, run Allegro's test program and see what happens to the polygon3d()
   test when you zoom in very close to the cube.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>#define <a name="POLYTYPE_PTEX">POLYTYPE_PTEX</a></b></div><br>
   A perspective-correct texture mapped polygon. This uses the <tt>`z'</tt> value from
   the vertex structure as well as the u/v coordinates, so textures are
   displayed correctly regardless of the angle they are viewed from. Because
   it involves division calculations in the inner texture mapping loop, this
   mode is a lot slower than POLYTYPE_ATEX, and it uses floating point so it
   will be very slow on anything less than a Pentium (even with an FPU, a 486
   can't overlap floating point division with other integer operations like
   the Pentium can).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#POLYTYPE_ATEX" title="Polygon rendering mode type">POLYTYPE_ATEX</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>#define <a name="POLYTYPE_ATEX_MASK">POLYTYPE_ATEX_MASK</a></b></div><br>
<div class="al-api-cont"><b>#define <a name="POLYTYPE_PTEX_MASK">POLYTYPE_PTEX_MASK</a></b></div><br>
   Like POLYTYPE_ATEX and POLYTYPE_PTEX, but zero texture map pixels are
   skipped, allowing parts of the texture map to be transparent.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#POLYTYPE_ATEX" title="Polygon rendering mode type">POLYTYPE_ATEX</a>,
<a class="xref" href="#POLYTYPE_PTEX" title="Polygon rendering mode type">POLYTYPE_PTEX</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>#define <a name="POLYTYPE_ATEX_LIT">POLYTYPE_ATEX_LIT</a></b></div><br>
<div class="al-api-cont"><b>#define <a name="POLYTYPE_PTEX_LIT">POLYTYPE_PTEX_LIT</a></b></div><br>
   Like POLYTYPE_ATEX and POLYTYPE_PTEX, but the global color_map table (for
   256-color modes) or blender function (for non-MMX truecolor modes) is used
   to blend the texture with a light level taken from the <tt>`c'</tt> value in the
   vertex structure. This must only be used after you have set up the color
   mapping table or blender functions!


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#POLYTYPE_ATEX" title="Polygon rendering mode type">POLYTYPE_ATEX</a>,
<a class="xref" href="#POLYTYPE_PTEX" title="Polygon rendering mode type">POLYTYPE_PTEX</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#Truecolor transparency" title="">Truecolor transparency</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>#define <a name="POLYTYPE_ATEX_MASK_LIT">POLYTYPE_ATEX_MASK_LIT</a></b></div><br>
<div class="al-api-cont"><b>#define <a name="POLYTYPE_PTEX_MASK_LIT">POLYTYPE_PTEX_MASK_LIT</a></b></div><br>
   Like POLYTYPE_ATEX_LIT and POLYTYPE_PTEX_LIT, but zero texture map pixels
   are skipped, allowing parts of the texture map to be transparent.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#POLYTYPE_ATEX_LIT" title="Polygon rendering mode type">POLYTYPE_ATEX_LIT</a>,
<a class="xref" href="#POLYTYPE_PTEX_LIT" title="Polygon rendering mode type">POLYTYPE_PTEX_LIT</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>#define <a name="POLYTYPE_ATEX_TRANS">POLYTYPE_ATEX_TRANS</a></b></div><br>
<div class="al-api-cont"><b>#define <a name="POLYTYPE_PTEX_TRANS">POLYTYPE_PTEX_TRANS</a></b></div><br>
   Render translucent textures. All the general rules for drawing
   translucent things apply. However, these modes have a major
   limitation: they only work with memory bitmaps or linear frame
   buffers (not with banked frame buffers). Don't even try, they do not
   check and your program will die horribly (or at least draw wrong
   things).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>#define <a name="POLYTYPE_ATEX_MASK_TRANS">POLYTYPE_ATEX_MASK_TRANS</a></b></div><br>
<div class="al-api-cont"><b>#define <a name="POLYTYPE_PTEX_MASK_TRANS">POLYTYPE_PTEX_MASK_TRANS</a></b></div><br>
   Like POLYTYPE_ATEX_TRANS and POLYTYPE_PTEX_TRANS, but zero texture map 
   pixels are skipped.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>void <a name="polygon3d">polygon3d</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int type, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *texture, int vc, <a class="autotype" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a> *vtx[]);</b></div><br>
<div class="al-api-cont"><b>void <a name="polygon3d_f">polygon3d_f</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int type, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *texture, int vc, <a class="autotype" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a> *vtx[]);</b></div><br>
   Draw 3d polygons onto the specified bitmap, using the specified rendering 
   mode. Unlike the regular polygon() function, these routines don't support 
   concave or self-intersecting shapes, and they can't draw onto mode-X 
   screen bitmaps (if you want to write 3d code in mode-X, draw onto a 
   memory bitmap and then blit to the screen). The width and height of the 
   texture bitmap must be powers of two, but can be different, eg. a 64x16 
   texture is fine, but a 17x3 one is not. The vertex count parameter (vc) 
   should be followed by an array containing the appropriate number of 
   pointers to vertex structures: polygon3d() uses the fixed point V3D 
   structure, while polygon3d_f() uses the floating point V3D_f structure. 
   These are defined as:
<blockquote class="code"><pre>
      typedef struct <a href="#V3D" class="autotype" title="Fixed point vertex structure used by 3d functions.">V3D</a>
      {
         <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> x, y, z;       - position
         <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> u, v;          - texture map coordinates
         int c;               - color
      } <a href="#V3D" class="autotype" title="Fixed point vertex structure used by 3d functions.">V3D</a>;
   
      typedef struct <a href="#V3D_f" class="autotype" title="Floating point vertex structure used by 3d functions.">V3D_f</a>
      {
         float x, y, z;       - position
         float u, v;          - texture map coordinates
         int c;               - color
      } <a href="#V3D_f" class="autotype" title="Floating point vertex structure used by 3d functions.">V3D_f</a>;
</pre></blockquote>
   How the vertex data is used depends on the rendering mode:

<p>
   The <tt>`x'</tt> and <tt>`y'</tt> values specify the position of the vertex in 2d screen
   coordinates.

<p>
   The <tt>`z'</tt> value is only required when doing perspective correct texture
   mapping, and specifies the depth of the point in 3d world coordinates.

<p>
   The <tt>`u'</tt> and <tt>`v'</tt> coordinates are only required when doing texture mapping,
   and specify a point on the texture plane to be mapped on to this vertex.
   The texture plane is an infinite plane with the texture bitmap tiled
   across it. Each vertex in the polygon has a corresponding vertex on the
   texture plane, and the image of the resulting polygon in the texture plane
   will be mapped on to the polygon on the screen.

<p>
   We refer to pixels in the texture plane as texels. Each texel is a block, 
   not just a point, and whole numbers for u and v refer to the top-left 
   corner of a texel. This has a few implications. If you want to draw a 
   rectangular polygon and map a texture sized 32x32 on to it, you would use 
   the texture coordinates (0,0), (0,32), (32,32) and (32,0), assuming the 
   vertices are specified in anticlockwise order. The texture will then be 
   mapped perfectly on to the polygon. However, note that when we set u=32, 
   the last column of texels seen on the screen is the one at u=31, and the 
   same goes for v. This is because the coordinates refer to the top-left 
   corner of the texels. In effect, texture coordinates at the right and 
   bottom on the texture plane are exclusive.

<p>
   There is another interesting point here. If you have two polygons side 
   by side sharing two vertices (like the two parts of folded piece of 
   cardboard), and you want to map a texture across them seamlessly, the 
   values of u and v on the vertices at the join will be the same for both 
   polygons. For example, if they are both rectangular, one polygon may use 
   (0,0), (0,32), (32,32) and (32,0), and the other may use (32,0), (32,32), 
   (64,32), (64,0). This would create a seamless join.

<p>
   Of course you can specify fractional numbers for u and v to indicate a 
   point part-way across a texel. In addition, since the texture plane is 
   infinite, you can specify larger values than the size of the texture. 
   This can be used to tile the texture several times across the polygon.

<p>
   The <tt>`c'</tt> value specifies the vertex color, and is interpreted differently
   by various rendering modes. Read the beginning of chapter "Polygon
   rendering" for a list of rendering types you can use with this function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#triangle3d" title="Draws a 3d triangle onto the specified bitmap.">triangle3d</a>,
<a class="xref" href="#quad3d" title="Draws a 3d quad onto the specified bitmap.">quad3d</a>,
<a class="xref" href="#polygon" title="Draws a filled polygon.">polygon</a>,
<a class="xref" href="#clip3d" title="Clips the polygon given in vtx using fixed point math.">clip3d</a>,
<a class="xref" href="#cpu_capabilities" title="Contains the capability flags of the CPU.">cpu_capabilities</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>.</blockquote>
<div class="al-api"><b>void <a name="triangle3d">triangle3d</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int type, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *tex, <a class="autotype" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a> *v1, *v2, *v3);</b></div><br>
<div class="al-api-cont"><b>void <a name="triangle3d_f">triangle3d_f</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int type, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *tex, <a class="autotype" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a> *v1, *v2, *v3);</b></div><br>
   Draw 3d triangles, using either fixed or floating point vertex structures.
   Unlike quad3d[_f](), triangle3d[_f]() functions are not wrappers of
   polygon3d[_f](). The triangle3d[_f]() functions use their own routines
   taking into account the constantness of the gradients. Therefore
   triangle3d[_f](bmp, type, tex, v1, v2, v3) is faster than
   polygon3d[_f](bmp, type, tex, 3, v[]).

<p>
   Read the beginning of chapter "Polygon rendering" for a list of rendering
   types you can use with this function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#quad3d" title="Draws a 3d quad onto the specified bitmap.">quad3d</a>,
<a class="xref" href="#triangle" title="Draws a filled triangle.">triangle</a>,
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>.</blockquote>
<div class="al-api"><b>void <a name="quad3d">quad3d</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int type, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *tex, <a class="autotype" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a> *v1, *v2, *v3, *v4);</b></div><br>
<div class="al-api-cont"><b>void <a name="quad3d_f">quad3d_f</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int type, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *tex, <a class="autotype" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a> *v1, *v2, *v3, *v4);</b></div><br>
   Draw 3d quads, using either fixed or floating point vertex structures. 
   These are equivalent to calling polygon3d(bmp, type, tex, 4, v[]) or
   polygon3d_f(bmp, type, tex, 4, v[]).

<p>
   Read the beginning of chapter "Polygon rendering" for a list of rendering
   types you can use with this function.
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#triangle3d" title="Draws a 3d triangle onto the specified bitmap.">triangle3d</a>,
<a class="xref" href="#Polygon rendering" title="">Polygon rendering</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>int <a name="clip3d_f">clip3d_f</a>(int type, float min_z, float max_z, int vc,
             const <a class="autotype" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a> *vtx[], <a class="autotype" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a> *vout[], <a class="autotype" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a> *vtmp[], int out[]);</b></div><br>
   Clips the polygon given in <tt>`vtx'</tt>. The number of vertices is <tt>`vc'</tt>, the
   result goes in <tt>`vout'</tt>, and <tt>`vtmp'</tt> and <tt>`out'</tt> are needed for internal
   purposes. The pointers in <tt>`vtx'</tt>, <tt>`vout'</tt> and <tt>`vtmp'</tt> must point to valid
   V3D_f structures.
   
<p>
   As additional vertices may appear in the process of clipping, so the 
   size of <tt>`vout'</tt>, <tt>`vtmp'</tt> and <tt>`out'</tt> should be at least vc * (1.5 ^ n), where
   <tt>`n'</tt> is the number of clipping planes (5 or 6), and <tt>`^'</tt> denotes "to the
   power of".
   
<p>
   The frustum (viewing volume) is defined by -z&lt;x&lt;z, -z&lt;y&lt;z,
   0&lt;min_z&lt;z&lt;max_z. If  max_z&lt;=min_z, the z&lt;max_z clipping is
   not done. As you can see, clipping is done in the camera space, with
   perspective in mind, so this routine should be called after you apply
   the camera matrix, but before the perspective projection. The routine
   will correctly interpolate u, v, and c in the vertex structure. However,
   no provision is made for high/truecolor GCOL.
<p><b>Return value:</b>
   Returns the number of vertices after clipping is done.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#clip3d" title="Clips the polygon given in vtx using fixed point math.">clip3d</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>.</blockquote>
<div class="al-api"><b>int <a name="clip3d">clip3d</a>(int type, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> min_z, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> max_z, int vc,
           const <a class="autotype" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a> *vtx[], <a class="autotype" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a> *vout[], <a class="autotype" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a> *vtmp[], int out[]);</b></div><br>
   Fixed point version of clip3d_f(). This function should be used with 
   caution, due to the limited precision of fixed point arithmetic and high 
   chance of rounding errors: the floating point code is better for most 
   situations.
<p><b>Return value:</b>
   Returns the number of vertices after clipping is done.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#clip3d_f" title="Clips the polygon given in vtx using floating point math,">clip3d_f</a>.</blockquote>
<br><center><h2><a name="Zbuffered rendering">Zbuffered rendering</a></h2></center><p>
A Z-buffer stores the depth of each pixel that is drawn on a viewport.
When a 3D object is rendered, the depth of each of its pixels is compared
against the value stored into the Z-buffer: if the pixel is closer it is
drawn, otherwise it is skipped.

<p>
No polygon sorting is needed. However, backface culling should be done
because it prevents many invisible polygons being compared against the
Z-buffer. Z-buffered rendering is the only algorithm supported by Allegro
that directly solves penetrating shapes (see example exzbuf.c, for instance).
The price to pay is more complex (and slower) routines.

<p>
Z-buffered polygons are designed as an extension of the normal POLYTYPE_*
rendering styles. Just OR the POLYTYPE with the value POLYTYPE_ZBUF, and
the normal polygon3d(), polygon3d_f(), quad3d(), etc. functions will
render z-buffered polygons.

<p>
Example:
<blockquote class="code"><pre>
   <a href="#polygon3d" class="autotype" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>(bmp, <a href="#POLYTYPE_ATEX" class="autotype" title="Polygon rendering mode type">POLYTYPE_ATEX</a> | POLYTYPE_ZBUF, tex, vc, vtx);</pre></blockquote>

<p>
Of course, the z coordinates have to be valid regardless of rendering style.

<p>
A Z-buffered rendering procedure looks like a double-buffered rendering
procedure. You should follow four steps: create a Z-buffer at the beginning
of the program and make the library use it by calling set_zbuffer(). Then,
for each frame, clear the Z-buffer and draw polygons with
POLYTYPE_* | POLYTYPE_ZBUF and finally destroy the Z-buffer when leaving the
program.

<p>
Notes on Z-buffered renderers:
<ul><li>
Unlike the normal POLYTYPE_FLAT renderers, the Z-buffered ones don't use
the hline() routine. Therefore DRAW_MODE has no effect.
<li>
The *LIT* routines work the traditional way - through the set of
blender routines.
<li>
All the Z-buffered routines are much slower than their normal counterparts
(they all use the FPU to interpolate and test 1/z values).
</ul>
<div class="al-api"><b><a class="autotype" href="#ZBUFFER" title="Stores 3d zbuffer information.">ZBUFFER</a> *<a name="create_zbuffer">create_zbuffer</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Creates a Z-buffer using the size of the BITMAP you are planning to draw
   on. Several Z-buffers can be defined but only one can be used at the same
   time, so you must call set_zbuffer() to make this Z-buffer active.
<p><b>Return value:</b>
   Returns the pointer to the ZBUFFER or NULL if there was an error. Remember
   to destroy the ZBUFFER once you are done with it, to avoid having memory
   leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_sub_zbuffer" title="Creates a sub-z-buffer.">create_sub_zbuffer</a>,
<a class="xref" href="#set_zbuffer" title="Makes the given Z-buffer the active one.">set_zbuffer</a>,
<a class="xref" href="#clear_zbuffer" title="Writes a depth value into the given Z-buffer.">clear_zbuffer</a>,
<a class="xref" href="#destroy_zbuffer" title="Destroys a Z-buffer.">destroy_zbuffer</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#ZBUFFER" title="Stores 3d zbuffer information.">ZBUFFER</a> *<a name="create_sub_zbuffer">create_sub_zbuffer</a>(<a class="autotype" href="#ZBUFFER" title="Stores 3d zbuffer information.">ZBUFFER</a> *parent, int x, int y, int width, int height);</b></div><br>
   Creates a sub-z-buffer, ie. a z-buffer sharing drawing memory with a
   pre-existing z-buffer, but possibly with a different size. The same rules
   as for sub-bitmaps apply: the sub-z-buffer width and height can extend
   beyond the right and bottom edges of the parent (they will be clipped), 
   but the origin point must lie within the parent region.

<p>
   When drawing z-buffered to a bitmap, the top left corner of the bitmap is
   always mapped to the top left corner of the current z-buffer. So this
   function is primarily useful if you want to draw to a sub-bitmap and use
   the corresponding sub-area of the z-buffer. In other cases, eg. if you
   just want to draw to a sub-bitmap of screen (and not to other parts of
   screen), then you would usually want to create a normal z-buffer (not
   sub-z-buffer) the size of the visible screen. You don't need to first
   create a z-buffer the size of the virtual screen and then a sub-z-buffer
   of that.
<p><b>Return value:</b>
   Returns the pointer to the sub ZBUFFER or NULL if there was an error.
   Remember to destroy the ZBUFFER once you are done with it, to avoid having
   memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_zbuffer" title="Creates a Z-buffer for a bitmap.">create_zbuffer</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#destroy_zbuffer" title="Destroys a Z-buffer.">destroy_zbuffer</a>.</blockquote>
<div class="al-api"><b>void <a name="set_zbuffer">set_zbuffer</a>(<a class="autotype" href="#ZBUFFER" title="Stores 3d zbuffer information.">ZBUFFER</a> *zbuf);</b></div><br>
   Makes the given Z-buffer be the active one. This should have been
   previously created with create_zbuffer().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_zbuffer" title="Creates a Z-buffer for a bitmap.">create_zbuffer</a>,
<a class="xref" href="#clear_zbuffer" title="Writes a depth value into the given Z-buffer.">clear_zbuffer</a>,
<a class="xref" href="#destroy_zbuffer" title="Destroys a Z-buffer.">destroy_zbuffer</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>void <a name="clear_zbuffer">clear_zbuffer</a>(<a class="autotype" href="#ZBUFFER" title="Stores 3d zbuffer information.">ZBUFFER</a> *zbuf, float z);</b></div><br>
   Writes z into the given Z-buffer (0 means far away). This function should
   be used to initialize the Z-buffer before each frame. Actually, low-level
   routines compare depth of the current pixel with 1/z: for example, if you
   want to clip polygons farther than 10, you must call
   clear_zbuffer(zbuf, 0.1).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_zbuffer" title="Creates a Z-buffer for a bitmap.">create_zbuffer</a>,
<a class="xref" href="#set_zbuffer" title="Makes the given Z-buffer the active one.">set_zbuffer</a>,
<a class="xref" href="#destroy_zbuffer" title="Destroys a Z-buffer.">destroy_zbuffer</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_zbuffer">destroy_zbuffer</a>(<a class="autotype" href="#ZBUFFER" title="Stores 3d zbuffer information.">ZBUFFER</a> *zbuf);</b></div><br>
   Destroys the Z-buffer when you are finished with it. Use this to avoid
   memory leaks in your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_zbuffer" title="Creates a Z-buffer for a bitmap.">create_zbuffer</a>,
<a class="xref" href="#set_zbuffer" title="Makes the given Z-buffer the active one.">set_zbuffer</a>,
<a class="xref" href="#clear_zbuffer" title="Writes a depth value into the given Z-buffer.">clear_zbuffer</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<br><center><h2><a name="Scene rendering">Scene rendering</a></h2></center><p>
Allegro provides two simple approaches to remove hidden surfaces:
<ul><li>
   Z-buffering - (see above)
<li>
   Scan-line algorithms - along each scanline on your screen, you keep
   track of what polygons you are "in" and which is the nearest. This
   status changes only where the scanline crosses some polygon edge. So you
   have to juggle an edge list and a polygon list. And you have to sort the
   edges for each scanline (this can be countered by keeping the order of
   the previous scanline - it won't change much). The BIG advantage is that
   you write each pixel only once. If you have a lot of overlapping
   polygons you can get incredible speeds compared to any of the previous
   algorithms. This algorithm is covered by the *_scene routines.
</ul>

<p>
The scene rendering has approximately the following steps:
<ul><li>
   Initialize the scene (set the clip area, clear the bitmap, blit a
   background, etc.)
<li>
   Call clear_scene().
<li>
   Transform all your points to camera space.
<li>
   Clip polygons.
<li>
   Project with persp_project() or persp_project_f().
<li>
   "Draw" polygons with scene_polygon3d() and/or scene_polygon3d_f().
   This doesn't do any actual drawing, only initializes tables.
<li>
   Render all the polygons defined previously to the bitmap with
   render_scene().
<li>
   Overlay some non-3D graphics.
<li>
   Show the bitmap (blit it to screen, flip the page, etc).
</ul>

<p>
For each horizontal line in the viewport an x-sorted edge list is used to
keep track of what polygons are "in" and which is the nearest. Vertical
coherency is used - the edge list for a scanline is sorted starting from
the previous one - it won't change much. The scene rendering routines use
the same low-level asm routines as normal polygon3d().

<p>
Notes on scene rendering:
<ul><li>
   Unlike polygon3d(), scene_polygon3d() requires valid z coordinates
   for all vertices, regardless of rendering style (unlike
   polygon3d(), which only uses z coordinate for *PTEX*).
<li>
   All polygons passed to scene_polygon3d() have to be
   persp_project()'ed.
<li>
   After render_scene() the mode is reset to SOLID.
</ul>
Using a lot of *MASK* polygons drastically reduces performance, because
when a MASKed polygon is the first in line of sight, the polygons
underneath have to be drawn too. The same applies to FLAT polygons drawn
with DRAW_MODE_TRANS.

<p>
Z-buffered rendering works also within the scene renderer. It may be
helpful when you have a few intersecting polygons, but most of the
polygons may be safely rendered by the normal scanline sorting algorithm.
Same as before: just OR the POLYTYPE with POLYTYPE_ZBUF. Also, you
have to clear the z-buffer at the start of the frame. Example:
<blockquote class="code"><pre>
   <a href="#clear_scene" class="autotype" title="Initializes a scene.">clear_scene</a>(buffer);
   if (some_polys_are_zbuf) <a href="#clear_zbuffer" class="autotype" title="Writes a depth value into the given Z-buffer.">clear_zbuffer</a>(0.);
   while (polygons) {
      ...
      if (this_poly_is_zbuf) type |= POLYTYPE_ZBUF;
      <a href="#scene_polygon3d" class="autotype" title="Puts a polygon in the scene rendering list.">scene_polygon3d</a>(type, tex, vc, vtx);
   }
   <a href="#render_scene" class="autotype" title="Renders all the queued scene polygons.">render_scene</a>();</pre></blockquote>

<p><br>
<div class="al-api"><b>int <a name="create_scene">create_scene</a>(int nedge, int npoly);</b></div><br>
   Allocates memory for a scene, <tt>`nedge'</tt> and <tt>`npoly'</tt> are your estimates of how
   many edges and how many polygons you will render (you cannot get over the
   limit specified here). If you use same values in successive calls, the
   space will be reused (no new malloc()).

<p>
   The memory allocated is a little less than 150 * (nedge + npoly) bytes.
<p><b>Return value:</b>
   Returns zero on success, or a negative number if allocations fail.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#scene_polygon3d" title="Puts a polygon in the scene rendering list.">scene_polygon3d</a>,
<a class="xref" href="#render_scene" title="Renders all the queued scene polygons.">render_scene</a>,
<a class="xref" href="#clear_scene" title="Initializes a scene.">clear_scene</a>,
<a class="xref" href="#destroy_scene" title="Deallocates the memory used by a scene.">destroy_scene</a>,
<a class="xref" href="#scene_gap" title="Number controlling the scene z-sorting algorithm behaviour.">scene_gap</a>,
<a class="xref" href="#create_zbuffer" title="Creates a Z-buffer for a bitmap.">create_zbuffer</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>.</blockquote>
<div class="al-api"><b>void <a name="clear_scene">clear_scene</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Initializes a scene. The bitmap is the bitmap you will eventually render
   on.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_scene" title="Allocates memory for a 3d scene.">create_scene</a>,
<a class="xref" href="#scene_polygon3d" title="Puts a polygon in the scene rendering list.">scene_polygon3d</a>,
<a class="xref" href="#render_scene" title="Renders all the queued scene polygons.">render_scene</a>,
<a class="xref" href="#destroy_scene" title="Deallocates the memory used by a scene.">destroy_scene</a>,
<a class="xref" href="#scene_gap" title="Number controlling the scene z-sorting algorithm behaviour.">scene_gap</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_scene">destroy_scene</a>();</b></div><br>
   Deallocate memory previously allocated by create_scene. Use this to avoid
   memory leaks in your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_scene" title="Allocates memory for a 3d scene.">create_scene</a>,
<a class="xref" href="#scene_polygon3d" title="Puts a polygon in the scene rendering list.">scene_polygon3d</a>,
<a class="xref" href="#clear_scene" title="Initializes a scene.">clear_scene</a>,
<a class="xref" href="#render_scene" title="Renders all the queued scene polygons.">render_scene</a>,
<a class="xref" href="#scene_gap" title="Number controlling the scene z-sorting algorithm behaviour.">scene_gap</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>.</blockquote>
<div class="al-api"><b>int <a name="scene_polygon3d">scene_polygon3d</a>(int type, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *texture, int vc, <a class="autotype" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a> *vtx[]);</b></div><br>
<div class="al-api-cont"><b>int <a name="scene_polygon3d_f">scene_polygon3d_f</a>(int type, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *texture, int vc, <a class="autotype" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a> *vtx[]);</b></div><br>
   Puts a polygon in the rendering list. Nothing is really rendered at this
   moment. Should be called between clear_scene() and render_scene().

<p>
   Arguments are the same as for polygon3d(), except the bitmap is missing.
   The one passed to clear_scene() will be used.

<p>
   Unlike polygon3d(), the polygon may be concave or self-intersecting.
   Shapes that penetrate one another may look OK, but they are not really
   handled by this code.

<p>
   Note that the texture is stored as a pointer only, and you should keep
   the actual bitmap around until render_scene(), where it is used.

<p>
   Since the FLAT style is implemented with the low-level hline() function,
   the FLAT style is subject to DRAW_MODEs. All these modes are valid. Along
   with the polygon, this mode will be stored for the rendering moment, and
   also all the other related variables (color_map pointer, pattern pointer,
   anchor, blender values).

<p>
   The settings of the CPU_MMX and CPU_3DNOW flags of the cpu_capabilities 
   global variable on entry in this routine affect the choice of low-level 
   asm routine that will be used by render_scene() for this polygon.
<p><b>Return value:</b>
   Returns zero on success, or a negative number if it won't be rendered for
   lack of a rendering routine.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_scene" title="Allocates memory for a 3d scene.">create_scene</a>,
<a class="xref" href="#clear_scene" title="Initializes a scene.">clear_scene</a>,
<a class="xref" href="#render_scene" title="Renders all the queued scene polygons.">render_scene</a>,
<a class="xref" href="#destroy_scene" title="Deallocates the memory used by a scene.">destroy_scene</a>,
<a class="xref" href="#polygon3d" title="Draws a 3d polygon onto the specified bitmap.">polygon3d</a>,
<a class="xref" href="#cpu_capabilities" title="Contains the capability flags of the CPU.">cpu_capabilities</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>.</blockquote>
<div class="al-api"><b>void <a name="render_scene">render_scene</a>();</b></div><br>
   Renders all the specified scene_polygon3d()'s on the bitmap passed to
   clear_scene(). Rendering is done one scanline at a time, with no pixel
   being processed more than once.

<p>
   Note that between clear_scene() and render_scene() you shouldn't change
   the clip rectangle of the destination bitmap. For speed reasons, you
   should set the clip rectangle to the minimum.

<p>
   Note also that all the textures passed to scene_polygon3d() are stored as
   pointers only and actually used in render_scene().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_scene" title="Allocates memory for a 3d scene.">create_scene</a>,
<a class="xref" href="#clear_scene" title="Initializes a scene.">clear_scene</a>,
<a class="xref" href="#destroy_scene" title="Deallocates the memory used by a scene.">destroy_scene</a>,
<a class="xref" href="#scene_gap" title="Number controlling the scene z-sorting algorithm behaviour.">scene_gap</a>,
<a class="xref" href="#scene_polygon3d" title="Puts a polygon in the scene rendering list.">scene_polygon3d</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>.</blockquote>
<div class="al-api"><b>extern float <a name="scene_gap">scene_gap</a>;</b></div><br>
   This number (default value = 100.0) controls the behaviour of the
   z-sorting algorithm. When an edge is very close to another's polygon
   plane, there is an interval of uncertainty in which you cannot tell which
   object is visible (which z is smaller). This is due to cumulative
   numerical errors for edges that have undergone a lot of transformations
   and interpolations.

<p>
   The default value means that if the 1/z values (in projected space)
   differ by only 1/100 (one percent), they are considered to be equal and
   the x-slopes of the planes are used to find out which plane is getting
   closer when we move to the right.

<p>
   Larger values means narrower margins, and increasing the chance of
   missing true adjacent edges/planes. Smaller values means larger margins,
   and increasing the chance of mistaking close polygons for adjacent ones.
   The value of 100 is close to the optimum. However, the optimum shifts
   slightly with resolution, and may be application-dependent. It is here 
   for you to fine-tune.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_scene" title="Allocates memory for a 3d scene.">create_scene</a>,
<a class="xref" href="#clear_scene" title="Initializes a scene.">clear_scene</a>,
<a class="xref" href="#destroy_scene" title="Deallocates the memory used by a scene.">destroy_scene</a>,
<a class="xref" href="#render_scene" title="Renders all the queued scene polygons.">render_scene</a>,
<a class="xref" href="#scene_polygon3d" title="Puts a polygon in the scene rendering list.">scene_polygon3d</a>.</blockquote>
<h1><a name="Transparency and patterned drawing">Transparency and patterned drawing</a></h1>

<p><br>
<div class="al-api"><b>void <a name="drawing_mode">drawing_mode</a>(int mode, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *pattern, int x_anchor, int y_anchor);</b></div><br>
   Sets the graphics drawing mode. This only affects the geometric routines 
   like putpixel, lines, rectangles, circles, polygons, floodfill, etc, not 
   the text output, blitting, or sprite drawing functions. The mode should 
   be one of the following constants:
<blockquote class="text"><pre>
      DRAW_MODE_SOLID               - the default, solid color
                                      drawing
      DRAW_MODE_XOR                 - exclusive-or drawing
      DRAW_MODE_COPY_PATTERN        - multicolored pattern fill
      DRAW_MODE_SOLID_PATTERN       - single color pattern fill
      DRAW_MODE_MASKED_PATTERN      - masked pattern fill
      DRAW_MODE_TRANS               - translucent color blending
</pre></blockquote>
   In DRAW_MODE_SOLID, pixels of the bitmap being drawn onto are simply 
   replaced by those produced by the drawing function.

<p>
   In DRAW_MODE_XOR, pixels are written to the bitmap with an exclusive-or 
   operation rather than a simple copy, so drawing the same shape twice will 
   erase it. Because it involves reading as well as writing the bitmap 
   memory, xor drawing is a lot slower than the normal replace mode.

<p>
   With the patterned modes, you provide a pattern bitmap which is tiled 
   across the surface of the shape. Allegro stores a pointer to this bitmap 
   rather than copying it, so you must not destroy the bitmap while it is 
   still selected as the pattern. The width and height of the pattern must 
   be powers of two, but they can be different, eg. a 64x16 pattern is fine, 
   but a 17x3 one is not. The pattern is tiled in a grid starting at point 
   (x_anchor, y_anchor). Normally you should just pass zero for these 
   values, which lets you draw several adjacent shapes and have the patterns 
   meet up exactly along the shared edges. Zero alignment may look peculiar 
   if you are moving a patterned shape around the screen, however, because 
   the shape will move but the pattern alignment will not, so in some 
   situations you may wish to alter the anchor position.

<p>
   When you select DRAW_MODE_COPY_PATTERN, pixels are simply copied from the 
   pattern bitmap onto the destination bitmap. This allows the use of 
   multicolored patterns, and means that the color you pass to the drawing 
   routine is ignored. This is the fastest of the patterned modes.

<p>
   In DRAW_MODE_SOLID_PATTERN, each pixel in the pattern bitmap is compared 
   with the mask color, which is zero in 256-color modes or bright pink for 
   truecolor data (maximum red and blue, zero green). If the pattern pixel 
   is solid, a pixel of the color you passed to the drawing routine is 
   written to the destination bitmap, otherwise a zero is written. The 
   pattern is thus treated as a monochrome bitmask, which lets you use the 
   same pattern to draw different shapes in different colors, but prevents 
   the use of multicolored patterns.

<p>
   DRAW_MODE_MASKED_PATTERN is almost the same as DRAW_MODE_SOLID_PATTERN, 
   but the masked pixels are skipped rather than being written as zeros, so 
   the background shows through the gaps.

<p>
   In DRAW_MODE_TRANS, the global color_map table or truecolor blender 
   functions are used to overlay pixels on top of the existing image. This 
   must only be used after you have set up the color mapping table (for 256 
   color modes) or blender functions (for truecolor modes). Because it 
   involves reading as well as writing the bitmap memory, translucent 
   drawing is very slow if you draw directly to video RAM, so wherever 
   possible you should use a memory bitmap instead.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#xor_mode" title="Shortcut for toggling xor drawing mode on and off.">xor_mode</a>,
<a class="xref" href="#solid_mode" title="Shortcut for selecting solid drawing mode.">solid_mode</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>,
<a class="eref" href="#exjoy" title="Detecting, calibrating and using joystick input.">exjoy</a>,
<a class="eref" href="#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="xor_mode">xor_mode</a>(int on);</b></div><br>
   This is a shortcut for toggling xor drawing mode on and off. Calling 
   xor_mode(TRUE) is equivalent to drawing_mode(DRAW_MODE_XOR, NULL, 0, 0).
   Calling xor_mode(FALSE) is equivalent to
   drawing_mode(DRAW_MODE_SOLID, NULL, 0, 0).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>void <a name="solid_mode">solid_mode</a>();</b></div><br>
   This is a shortcut for selecting solid drawing mode. It is equivalent to 
   calling drawing_mode(DRAW_MODE_SOLID, NULL, 0, 0).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>.</blockquote>
<br><center><h2><a name="256-color transparency">256-color transparency</a></h2></center><p>
In paletted video modes, translucency and lighting are implemented with a 
64k lookup table, which contains the result of combining any two colors c1 
and c2. You must set up this table before you use any of the translucency 
or lighting routines. Depending on how you construct the table, a range of 
different effects are possible. For example, translucency can be implemented 
by using a color halfway between c1 and c2 as the result of the combination. 
Lighting is achieved by treating one of the colors as a light level (0-255) 
rather than a color, and setting up the table appropriately. A range of 
specialised effects are possible, for instance replacing any color with any 
other color and making individual source or destination colors completely 
solid or invisible. Color mapping tables can be precalculated with the
colormap utility, or generated at runtime. Read chapter "Structures and types
defined by Allegro" for an internal description of the COLOR_MAP structure.

<p><br>
<div class="al-api"><b>extern <a class="autotype" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> *<a name="color_map">color_map</a>;</b></div><br>
   Global pointer to the color mapping table. You must allocate your own
   COLOR_MAP either statically or dynamically and set color_map to it 
   before using any translucent or lit drawing functions in a 256-color 
   video mode! Example:
<blockquote class="code"><pre>
      <a href="#color_map" class="autotype" title="Global pointer to the color mapping table.">color_map</a> = malloc(sizeof(<a href="#COLOR_MAP" class="autotype" title="Stores a color map to accelerate drawing.">COLOR_MAP</a>));
      if (!<a href="#color_map" class="autotype" title="Global pointer to the color mapping table.">color_map</a>)
         abort_on_error("Not enough memory for color map!");</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_color_table" title="Fills a color mapping table for customised effects.">create_color_table</a>,
<a class="xref" href="#create_light_table" title="Fills a color mapping table for lighting effects.">create_light_table</a>,
<a class="xref" href="#create_trans_table" title="Fills a color mapping table for translucency effects.">create_trans_table</a>,
<a class="xref" href="#create_blender_table" title="Emulates truecolor blender effects in paletted modes.">create_blender_table</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#draw_gouraud_sprite" title="Draws a sprite with gouraud shading.">draw_gouraud_sprite</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="create_trans_table">create_trans_table</a>(<a class="autotype" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> *table, const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal,
                        int r, g, b, void (*callback)(int pos));</b></div><br>
   Fills the specified color mapping table with lookup data for doing 
   translucency effects with the specified palette. When combining the 
   colors c1 and c2 with this table, the result will be a color somewhere 
   between the two. The r, g, and b parameters specify the solidity of each 
   color component, ranging from 0 (totally transparent) to 255 (totally 
   solid). For 50% solidity, pass 128.

<p>
   This function treats source color #0 as a special case, leaving the
   destination unchanged whenever a zero source pixel is encountered, so that
   masked sprites will draw correctly. This function will take advantage of
   the global rgb_map variable to speed up color conversions. If the callback
   function is not NULL, it will be called 256 times during the calculation,
   allowing you to display a progress indicator. Example:
<blockquote class="code"><pre>
      <a href="#COLOR_MAP" class="autotype" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> trans_table;
      ...
      /* Build a color lookup table for translucent drawing. */
      <a href="#create_trans_table" class="autotype" title="Fills a color mapping table for translucency effects.">create_trans_table</a>(&amp;trans_table, pal, 128, 128, 128, NULL);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#create_light_table" title="Fills a color mapping table for lighting effects.">create_light_table</a>,
<a class="xref" href="#create_color_table" title="Fills a color mapping table for customised effects.">create_color_table</a>,
<a class="xref" href="#create_blender_table" title="Emulates truecolor blender effects in paletted modes.">create_blender_table</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#draw_gouraud_sprite" title="Draws a sprite with gouraud shading.">draw_gouraud_sprite</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="create_light_table">create_light_table</a>(<a class="autotype" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> *table, const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal,
                        int r, g, b, void (*callback)(int pos));</b></div><br>
   Fills the specified color mapping table with lookup data for doing 
   lighting effects with the specified palette. When combining the colors c1 
   and c2 with this table, c1 is treated as a light level from 0-255. At 
   light level 255 the table will output color c2 unchanged, at light level 
   0 it will output the r, g, b value you specify to this function, and at 
   intermediate light levels it will output a color somewhere between the 
   two extremes. The r, g, and b values are in the range 0-63.

<p>
   This function will take advantage of the global rgb_ap variable to speed
   up color conversions. If the callback function is not NULL, it will be
   called 256 times during the calculation, allowing you to display a
   progress indicator. Example:
<blockquote class="code"><pre>
      <a href="#COLOR_MAP" class="autotype" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> light_table;
      ...
      /* Build a color lookup table for lighting effects. */
      <a href="#create_light_table" class="autotype" title="Fills a color mapping table for lighting effects.">create_light_table</a>(&light_table, pal, 0, 0, 0, NULL);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#create_trans_table" title="Fills a color mapping table for translucency effects.">create_trans_table</a>,
<a class="xref" href="#create_color_table" title="Fills a color mapping table for customised effects.">create_color_table</a>,
<a class="xref" href="#create_blender_table" title="Emulates truecolor blender effects in paletted modes.">create_blender_table</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#draw_gouraud_sprite" title="Draws a sprite with gouraud shading.">draw_gouraud_sprite</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="create_color_table">create_color_table</a>(<a class="autotype" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> *table, const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal,
                        void (*blend)(<a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal, int x, int y, <a class="autotype" href="#RGB" title="Single palette entry.">RGB</a> *rgb),
                        void (*callback)(int pos));</b></div><br>
   Fills the specified color mapping table with lookup data for doing 
   customised effects with the specified palette, calling the blend function 
   to determine the results of each color combination.

<p>
   Your blend routine will be passed a pointer to the palette and the two
   indices of the colors which are to be combined, and should fill in the RGB
   structure with the desired result in 0-63 format. Allegro will then search
   the palette for the closest match to the RGB color that you requested, so
   it doesn't matter if the palette has no exact match for this color.

<p>
   If the callback function is not NULL, it will be called 256 times during
   the calculation, allowing you to display a progress indicator. Example:
<blockquote class="code"><pre>
      <a href="#COLOR_MAP" class="autotype" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> greyscale_table;
      ...
      void return_grey_color(const <a href="#PALETTE" class="autotype" title="Stores palette information.">PALETTE</a> pal,
                             int x, int y, <a href="#RGB" class="autotype" title="Single palette entry.">RGB</a> *rgb)
      {
         ...
      }
      ...
         /* Build a color lookup table for greyscale effect. */
         <a href="#create_color_table" class="autotype" title="Fills a color mapping table for customised effects.">create_color_table</a>(&greyscale_table, pal,
                            return_grey_color, NULL);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#create_light_table" title="Fills a color mapping table for lighting effects.">create_light_table</a>,
<a class="xref" href="#create_trans_table" title="Fills a color mapping table for translucency effects.">create_trans_table</a>,
<a class="xref" href="#create_blender_table" title="Emulates truecolor blender effects in paletted modes.">create_blender_table</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#draw_gouraud_sprite" title="Draws a sprite with gouraud shading.">draw_gouraud_sprite</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>.</blockquote>
<div class="al-api"><b>void <a name="create_blender_table">create_blender_table</a>(<a class="autotype" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a> *table, const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal,
                          void (*callback)(int pos));</b></div><br>
   Fills the specified color mapping table with lookup data for doing a 
   paletted equivalent of whatever truecolor blender mode is currently 
   selected. After calling set_trans_blender(), set_blender_mode(), or any 
   of the other truecolor blender mode routines, you can use this function 
   to create an 8-bit mapping table that will have the same results as 
   whatever 24-bit blending mode you have enabled.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#create_light_table" title="Fills a color mapping table for lighting effects.">create_light_table</a>,
<a class="xref" href="#create_trans_table" title="Fills a color mapping table for translucency effects.">create_trans_table</a>,
<a class="xref" href="#create_color_table" title="Fills a color mapping table for customised effects.">create_color_table</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#draw_gouraud_sprite" title="Draws a sprite with gouraud shading.">draw_gouraud_sprite</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#set_blender_mode" title="Specifies a custom set of truecolor blender routines.">set_blender_mode</a>.</blockquote>
<br><center><h2><a name="Truecolor transparency">Truecolor transparency</a></h2></center><p>
In truecolor video modes, translucency and lighting are implemented by a 
blender function of the form:
<blockquote class="code"><pre>
   unsigned long (*BLENDER_FUNC)(unsigned long x, y, n);</pre></blockquote>

<p>
For each pixel to be drawn, this routine is passed two color parameters x 
and y, decomposes them into their red, green and blue components, combines 
them according to some mathematical transformation involving the 
interpolation factor n, and then merges the result back into a single 
return color value, which will be used to draw the pixel onto 
the destination bitmap.

<p>
The parameter x represents the blending modifier color and the parameter y 
represents the base color to be modified. The interpolation factor n is in 
the range [0-255] and controls the solidity of the blending.

<p>
When a translucent drawing function is used, x is the color of the source, 
y is the color of the bitmap being drawn onto and n is the alpha level   
that was passed to the function that sets the blending mode (the RGB triplet 
that was passed to this function is not taken into account).

<p>
When a lit sprite drawing function is used, x is the color represented by 
the RGB triplet that was passed to the function that sets the blending mode 
(the alpha level that was passed to this function is not taken into 
account), y is the color of the sprite and n is the alpha level that was 
passed to the drawing function itself.

<p>
Since these routines may be used from various different color depths, there 
are three such callbacks, one for use with 15-bit 5.5.5 pixels, one for 16 
bit 5.6.5 pixels, and one for 24-bit 8.8.8 pixels (this can be shared 
between the 24 and 32-bit code since the bit packing is the same).

<p><br>
<div class="al-api"><b>void <a name="set_trans_blender">set_trans_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a linear interpolator blender mode for combining translucent 
   or lit truecolor pixels.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_blender_mode" title="Specifies a custom set of truecolor blender routines.">set_blender_mode</a>,
<a class="xref" href="#set_alpha_blender" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>,
<a class="xref" href="#set_write_alpha_blender" title="Enables the special alpha-channel editing mode.">set_write_alpha_blender</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#set_add_blender" title="Enables an additive blender mode.">set_add_blender</a>,
<a class="xref" href="#set_burn_blender" title="Enables a burn blender mode.">set_burn_blender</a>,
<a class="xref" href="#set_color_blender" title="Enables a color blender mode.">set_color_blender</a>,
<a class="xref" href="#set_difference_blender" title="Enables a difference blender mode.">set_difference_blender</a>,
<a class="xref" href="#set_dissolve_blender" title="Enables a dissolve blender mode.">set_dissolve_blender</a>,
<a class="xref" href="#set_dodge_blender" title="Enables a dodge blender mode.">set_dodge_blender</a>,
<a class="xref" href="#set_hue_blender" title="Enables a hue blender mode.">set_hue_blender</a>,
<a class="xref" href="#set_invert_blender" title="Enables an invert blender mode.">set_invert_blender</a>,
<a class="xref" href="#set_luminance_blender" title="Enables a luminance blender mode.">set_luminance_blender</a>,
<a class="xref" href="#set_multiply_blender" title="Enables a multiply blender mode.">set_multiply_blender</a>,
<a class="xref" href="#set_saturation_blender" title="Enables a saturation blender mode.">set_saturation_blender</a>,
<a class="xref" href="#set_screen_blender" title="Enables a screen blender mode.">set_screen_blender</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>,
<a class="eref" href="#exxfade" title="Truecolor image loading and fades.">exxfade</a>.</blockquote>
<div class="al-api"><b>void <a name="set_alpha_blender">set_alpha_blender</a>();</b></div><br>
   Enables the special alpha-channel blending mode, which is used for 
   drawing 32-bit RGBA sprites. After calling this function, you can use 
   draw_trans_sprite() or draw_trans_rle_sprite() to draw a 32-bit source 
   image onto any hicolor or truecolor destination. The alpha values will be 
   taken directly from the source graphic, so you can vary the solidity of 
   each part of the image. You can't use any of the normal translucency 
   functions while this mode is active, though, so you should reset to one 
   of the normal blender modes (eg. set_trans_blender()) before drawing 
   anything other than 32-bit RGBA sprites.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#draw_trans_rle_sprite" title="Draws a translucent RLE sprite.">draw_trans_rle_sprite</a>,
<a class="xref" href="#set_write_alpha_blender" title="Enables the special alpha-channel editing mode.">set_write_alpha_blender</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="set_write_alpha_blender">set_write_alpha_blender</a>();</b></div><br>
   Enables the special alpha-channel editing mode, which is used for drawing 
   alpha channels over the top of an existing 32-bit RGB sprite, to turn it 
   into an RGBA format image. After calling this function, you can set the 
   drawing mode to DRAW_MODE_TRANS and then write draw color values (0-255) 
   onto a 32-bit image. This will leave the color values unchanged, but 
   alter the alpha to whatever values you are writing. After enabling this 
   mode you can also use draw_trans_sprite() to superimpose an 8-bit alpha 
   mask over the top of an existing 32-bit sprite.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_alpha_blender" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="set_add_blender">set_add_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables an additive blender mode for combining translucent or lit 
   truecolor pixels.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_burn_blender">set_burn_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a burn blender mode for combining translucent or lit truecolor 
   pixels. Here the lightness values of the colours of the source image 
   reduce the lightness of the destination image, darkening the image.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_color_blender">set_color_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a color blender mode for combining translucent or lit truecolor 
   pixels. Applies only the hue and saturation of the source image to the 
   destination image. The luminance of the destination image is not affected.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_difference_blender">set_difference_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a difference blender mode for combining translucent or lit 
   truecolor pixels. This makes an image which has colours calculated by the 
   difference between the source and destination colours.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_dissolve_blender">set_dissolve_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a dissolve blender mode for combining translucent or lit 
   truecolor pixels. Randomly replaces the colours of some pixels in the 
   destination image with those of the source image. The number of pixels 
   replaced depends on the alpha value (higher value, more pixels replaced; 
   you get the idea :).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_dodge_blender">set_dodge_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a dodge blender mode for combining translucent or lit truecolor 
   pixels. The lightness of colours in the source lighten the colours of the 
   destination. White has the most effect; black has none.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_hue_blender">set_hue_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a hue blender mode for combining translucent or lit truecolor 
   pixels. This applies the hue of the source to the destination.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_invert_blender">set_invert_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables an invert blender mode for combining translucent or lit truecolor 
   pixels. Blends the inverse (or negative) colour of the source with the 
   destination.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_luminance_blender">set_luminance_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a luminance blender mode for combining translucent or lit 
   truecolor pixels. Applies the luminance of the source to the destination.
   The colour of the destination is not affected.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_multiply_blender">set_multiply_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a multiply blender mode for combining translucent or lit 
   truecolor pixels. Combines the source and destination images, multiplying 
   the colours to produce a darker colour. If a colour is multiplied by 
   white it remains unchanged; when multiplied by black it also becomes 
   black.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exalpha" title="Creating and using 32 bit RGBA sprites.">exalpha</a>.</blockquote>
<div class="al-api"><b>void <a name="set_saturation_blender">set_saturation_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a saturation blender mode for combining translucent or lit 
   truecolor pixels. Applies the saturation of the source to the destination 
   image.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_screen_blender">set_screen_blender</a>(int r, int g, int b, int a);</b></div><br>
   Enables a screen blender mode for combining translucent or lit truecolor 
   pixels. This blender mode lightens the colour of the destination image by 
   multiplying the inverse of the source and destination colours. Sort of 
   like the opposite of the multiply blender mode.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_blender_mode">set_blender_mode</a>(BLENDER_FUNC b15, b16, b24, int r, g, b, a);</b></div><br>
   Specifies a custom set of truecolor blender routines, which can be used 
   to implement whatever special interpolation modes you need. This function 
   shares a single blender between the 24 and 32-bit modes.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_blender_mode_ex" title="An even more complex version of set_blender_mode().">set_blender_mode_ex</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>.</blockquote>
<div class="al-api"><b>void <a name="set_blender_mode_ex">set_blender_mode_ex</a>(BLENDER_FUNC b15, b16, b24, b32, b15x, b16x, b24x,
                         int r, g, b, a);</b></div><br>
   Like set_blender_mode(), but allows you to specify a more complete set of 
   blender routines. The b15, b16, b24, and b32 routines are used when 
   drawing pixels onto destinations of the same format, while b15x, b16x, 
   and b24x are used by draw_trans_sprite() and draw_trans_rle_sprite() when 
   drawing RGBA images onto destination bitmaps of another format. These 
   blenders will be passed a 32-bit x parameter, along with a y value of a 
   different color depth, and must try to do something sensible in response.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_blender_mode" title="Specifies a custom set of truecolor blender routines.">set_blender_mode</a>,
<a class="xref" href="#set_alpha_blender" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>.</blockquote>
<h1><a name="Converting between color formats">Converting between color formats</a></h1>

<p>
In general, Allegro is designed to be used in only one color depth at a 
time, so you will call set_color_depth() once and then store all your 
bitmaps in the same format. If you want to mix several different pixel 
formats, you can use create_bitmap_ex() in place of create_bitmap(), and 
call bitmap_color_depth() to query the format of a specific image. Most of 
the graphics routines require all their input parameters to be in the same 
format (eg. you cannot stretch a 15-bit source bitmap onto a 24-bit 
destination), but there are some exceptions:
<ul><li>
   blit() and the rotation routines can copy between bitmaps of any format,
   converting the data as required.
<li>
   draw_sprite() can draw 256-color source images onto destinations of any
   format.
<li>
   draw_character_ex() _always_ uses a 256-color source bitmap, whatever the
   format of the destination.
<li>
   The draw_trans_sprite() and draw_trans_rle_sprite() functions are able to
   draw 32-bit RGBA images onto any hicolor or truecolor destination, as long
   as you call set_alpha_blender() first.
<li>
   The draw_trans_sprite() function is able to draw an 8-bit alpha channel
   image over the top of an existing 32-bit image, as long as you call
   set_write_alpha_blender() first.
</ul>
Expanding a 256-color source onto a truecolor destination is fairly fast 
(obviously you must set the correct palette before doing this conversion!). 
Converting between different truecolor formats is slightly slower, and 
reducing truecolor images to a 256-color destination is very slow (it can be 
sped up significantly if you set up the global rgb_map table before doing 
the conversion).

<p><br>
<div class="al-api"><b>int <a name="bestfit_color">bestfit_color</a>(const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal, int r, int g, int b);</b></div><br>
   Searches the specified palette for the closest match to the requested 
   color, which are specified in the VGA hardware 0-63 format. Normally you 
   should call makecol8() instead, but this lower level function may be 
   useful if you need to use a palette other than the currently selected 
   one, or specifically don't want to use the rgb_map lookup table.
<p><b>Return value:</b>
   Returns the index of the palette for the closest match to the requested
   color.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#makecol8" title="Converts an RGB value into a display dependent pixel format.">makecol8</a>.</blockquote>
<div class="al-api"><b>extern <a class="autotype" href="#RGB_MAP" title="Stores an rgb map to accelerate conversions.">RGB_MAP</a> *<a name="rgb_map">rgb_map</a>;</b></div><br>
   To speed up reducing RGB values to 8-bit paletted colors, Allegro uses a 
   32k lookup table (5 bits for each color component). You must set up this 
   table before using the gouraud shading routines, and if present the table 
   will also vastly accelerate the makecol8() and some create_*_table()
   functions. RGB tables can be precalculated with the rgbmap utility, or
   generated at runtime with create_rgb_table().
      

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_rgb_table" title="Generates an RGB mapping table with lookup data for a palette.">create_rgb_table</a>,
<a class="xref" href="#makecol8" title="Converts an RGB value into a display dependent pixel format.">makecol8</a>,
<a class="xref" href="#create_trans_table" title="Fills a color mapping table for translucency effects.">create_trans_table</a>,
<a class="xref" href="#create_light_table" title="Fills a color mapping table for lighting effects.">create_light_table</a>,
<a class="xref" href="#create_color_table" title="Fills a color mapping table for customised effects.">create_color_table</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="create_rgb_table">create_rgb_table</a>(<a class="autotype" href="#RGB_MAP" title="Stores an rgb map to accelerate conversions.">RGB_MAP</a> *table, const <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal,
                      void (*callback)(int pos));</b></div><br>
   Fills the specified RGB mapping table with lookup data for the specified 
   palette. If the callback function is not NULL, it will be called 256 
   times during the calculation, allowing you to display a progress 
   indicator. Example:
<blockquote class="code"><pre>
      <a href="#RGB_MAP" class="autotype" title="Stores an rgb map to accelerate conversions.">RGB_MAP</a> rgb_table;
      
      <a href="#create_rgb_table" class="autotype" title="Generates an RGB mapping table with lookup data for a palette.">create_rgb_table</a>(&amp;rgb_table, palette, NULL);
      <a href="#rgb_map" class="autotype" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a> = &amp;rgb_table;</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#excolmap" title="Creating graphical effects with color mapping tables.">excolmap</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>,
<a class="eref" href="#exshade" title="Gouraud shaded sprites.">exshade</a>,
<a class="eref" href="#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b>void <a name="hsv_to_rgb">hsv_to_rgb</a>(float h, float s, float v, int *r, int *g, int *b);</b></div><br>
<div class="al-api-cont"><b>void <a name="rgb_to_hsv">rgb_to_hsv</a>(int r, int g, int b, float *h, float *s, float *v);</b></div><br>
   Convert color values between the HSV and RGB color spaces. The RGB values 
   range from 0 to 255, hue is from 0 to 360, and saturation and value are 
   from 0 to 1. Example:
<blockquote class="code"><pre>
      int r, g, b;
      float hue, saturation, value;
      ...
      /* Convert a reddish color to HSV format. */
      <a href="#rgb_to_hsv" class="autotype" title="Converts color values between the HSV and RGB color spaces.">rgb_to_hsv</a>(255, 0, 128, &amp;hue, &amp;saturation, &amp;value);
      
      /* Now put our tin foil hat, and verify that. */
      <a href="#hsv_to_rgb" class="autotype" title="Converts color values between the HSV and RGB color spaces.">hsv_to_rgb</a>(hue, saturation, value, &amp;r, &g, &amp;b);
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(r == 255);
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(g == 0);
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(b == 128);</pre></blockquote>




<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>.</blockquote>
<h1><a name="Direct access to video memory">Direct access to video memory</a></h1>

<p>
Read chapter "Structures and types defined by Allegro" for an internal
description of the BITMAP structure. There are several ways to get direct
access to the image memory of a bitmap, varying in complexity depending on
what sort of bitmap you are using.

<p>
The simplest approach will only work with memory bitmaps (obtained from 
create_bitmap(), grabber datafiles, and image files) and sub-bitmaps of 
memory bitmaps. This uses a table of char pointers, called <tt>`line'</tt>, which is
a part of the bitmap structure and contains pointers to the start of each 
line of the image. For example, a simple memory bitmap putpixel function is:
<blockquote class="code"><pre>
   void memory_putpixel(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color)
   {
      bmp-&gt;<a href="#line" class="autotype" title="Draws a line onto the bitmap.">line</a>[y][x] = color;
   }
</pre></blockquote>
For truecolor modes you need to cast the line pointer to the appropriate
type, for example:
<blockquote class="code"><pre>
   void memory_putpixel_15_or_16_bpp(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color)
   {
      ((short *)bmp-&gt;<a href="#line" class="autotype" title="Draws a line onto the bitmap.">line</a>[y])[x] = color;
   }

   void memory_putpixel_32(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color)
   {
      ((long *)bmp-&gt;<a href="#line" class="autotype" title="Draws a line onto the bitmap.">line</a>[y])[x] = color;
   }
</pre></blockquote>
If you want to write to the screen as well as to memory bitmaps, you need to
use some helper macros, because the video memory may not be part of your 
normal address space. This simple routine will work for any linear screen, 
eg. a VESA linear framebuffers:
<blockquote class="code"><pre>
   void linear_screen_putpixel(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color)
   {
      bmp_select(bmp);
      bmp_write8((unsigned long)bmp-&gt;<a href="#line" class="autotype" title="Draws a line onto the bitmap.">line</a>[y]+x, color);
   }
</pre></blockquote>
For truecolor modes you should replace the bmp_write8() with bmp_write16(), 
bmp_write24(), or bmp_write32(), and multiply the x offset by the number of 
bytes per pixel. There are of course similar functions to read a pixel value
from a bitmap, namely bmp_read8(), bmp_read16(), bmp_read24() and
bmp_read32().

<p>
This still won't work in banked SVGA modes, however, or on platforms like 
Windows that do special processing inside the bank switching functions. For 
more flexible access to bitmap memory, you need to call the following
routines. They are implemented as inline assembler routines, so they are not
as inefficient as they might seem. If the bitmap doesn't require bank
switching (ie. it is a memory bitmap, mode 13h screen, etc), these functions
just return bmp-&gt;line[line].

<p><br>
<div class="al-api"><b>unsigned long <a name="bmp_write_line">bmp_write_line</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int line);</b></div><br>
   Selects the line of a bitmap that you are going to draw onto.
<p><b>Return value:</b>
   Returns the address of the selected line for writing.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exflame" title="How to write directly to video memory improving performance.">exflame</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>.</blockquote>
<div class="al-api"><b>unsigned long <a name="bmp_read_line">bmp_read_line</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int line);</b></div><br>
   Selects the line of a bitmap that you are going to read from.
<p><b>Return value:</b>
   Returns the address of the selected line for reading.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exflame" title="How to write directly to video memory improving performance.">exflame</a>.</blockquote>
<div class="al-api"><b>void <a name="bmp_unwrite_line">bmp_unwrite_line</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Releases the bitmap memory after you are finished with it. You only need 
   to call this once at the end of a drawing operation, even if you have 
   called bmp_write_line() or bmp_read_line() several times before it.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exflame" title="How to write directly to video memory improving performance.">exflame</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>.</blockquote>
<br><center><h2><a name="More on banked direct memory access">More on banked direct memory access</a></h2></center><p>

<p>
Although SVGA bitmaps are banked, Allegro provides linear access to the 
memory within each scanline, so you only need to pass a y coordinate to 
these functions. Various x positions can be obtained by simply adding the x 
coordinate to the returned address. The return value is an unsigned long 
rather than a char pointer because the bitmap memory may not be in your data 
segment, and you need to access it with far pointers. For example, a 
putpixel using the bank switching functions is:
<blockquote class="code"><pre>
   void banked_putpixel(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int color)
   {
      unsigned long address = <a href="#bmp_write_line" class="autotype" title="Direct access bank switching line selection for writing.">bmp_write_line</a>(bmp, y);
      bmp_select(bmp);
      bmp_write8(address+x, color);
      <a href="#bmp_unwrite_line" class="autotype" title="Direct access bank switching line release.">bmp_unwrite_line</a>(bmp);
   }
</pre></blockquote>
You will notice that Allegro provides separate functions for setting the 
read and write banks. It is important that you distinguish between these, 
because on some graphics cards the banks can be set individually, and on 
others the video memory is read and written at different addresses. Life is 
never quite as simple as we might wish it to be, though (this is true even 
when we _aren't_ talking about graphics coding :-) and so of course some 
cards only provide a single bank. On these the read and write bank functions 
will behave identically, so you shouldn't assume that you can read from one 
part of video memory and write to another at the same time. You can call 
bmp_read_line(), and read whatever you like from that line, and then call 
bmp_write_line() with the same or a different line number, and write 
whatever you like to this second line, but you mustn't call bmp_read_line() 
and bmp_write_line() together and expect to be able to read one line and 
write the other simultaneously. It would be nice if this was possible, but 
if you do it, your code won't work on single banked SVGA cards.

<p>
And then there's mode-X. If you've never done any mode-X graphics coding, 
you probably won't understand this, but for those of you who want to know 
how Allegro sets up the mode-X screen bitmaps, here goes...

<p>
The line pointers are still present, and they contain planar addresses, ie. 
the actual location at which you access the first pixel in the line. These 
addresses are guaranteed to be quad aligned, so you can just set the write 
plane, divide your x coordinate by four, and add it to the line pointer. For 
example, a mode-X putpixel is:
<blockquote class="code"><pre>
   void modex_putpixel(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *b, int x, int y, int color)
   {
      outportw(0x3C4, (0x100&lt;&lt;(x&amp;3))|2);
      bmp_select(bmp);
      bmp_write8((unsigned long)bmp-&gt;<a href="#line" class="autotype" title="Draws a line onto the bitmap.">line</a>[y]+(x&gt;&gt;2), color);
   }</pre></blockquote>

<p>
Oh yeah: the DJGPP nearptr hack. Personally I don't like this very much 
because it disables memory protection and isn't portable to other platforms, 
but a lot of people swear by it because it can give you direct access to the 
screen memory via a normal C pointer. Warning: this method will only work 
with the DJGPP library, when using VGA 13h or a linear framebuffer modes!

<p>
In your setup code:
<blockquote class="code"><pre>
   #include &lt;sys/nearptr.h&gt;

   unsigned char *screenmemory;
   unsigned long screen_base_addr;

   __djgpp_nearptr_enable();

   __dpmi_get_segment_base_address(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>-&gt;seg, &amp;screen_base_addr);

   screenmemory = (unsigned char *)(screen_base_addr + 
                                    <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>-&gt;<a href="#line" class="autotype" title="Draws a line onto the bitmap.">line</a>[0] -
                                    __djgpp_base_address);
</pre></blockquote>
Then:
<blockquote class="code"><pre>
   void nearptr_putpixel(int x, int y, int color)
   {
      screenmemory[x + y*<a href="#VIRTUAL_W" class="autotype" title="Global define to obtain the virtual size of the screen.">VIRTUAL_W</a>] = color;
   }
</pre></blockquote>


<p><br>
<h1><a name="FLIC routines">FLIC routines</a></h1>

<p>
There are two high level functions for playing FLI/FLC animations: 
play_fli(), which reads the data directly from disk, and play_memory_fli(), 
which uses data that has already been loaded into RAM. Apart from the 
different sources of the data, these two functions behave identically. They 
draw the animation onto the specified bitmap, which should normally be the 
screen. Frames will be aligned with the top left corner of the bitmap: if 
you want to position them somewhere else you will need to create a 
sub-bitmap for the FLI player to draw onto.

<p>
If the callback function is not NULL it will be called once for each frame,
allowing you to perform background tasks of your own. This callback should
normally return zero: if it returns non-zero the player will terminate (this
is the only way to stop an animation that is playing in looped mode).

<p>
The FLI player returns FLI_OK if it reached the end of the file, FLI_ERROR
if something went wrong, and the value returned by the callback function if
that was what stopped it. If you need to distinguish between different return
values, your callback should return positive integers, since FLI_OK is zero
and FLI_ERROR is negative.

<p>
Note that the FLI player will only work when the timer module is installed, 
and that it will alter the palette according to whatever palette data is 
present in the animation file.

<p>
Occasionally you may need more detailed control over how an FLI is played, 
for example if you want to superimpose a text scroller on top of the 
animation, or to play it back at a different speed. You could do both of 
these with the lower level functions described below.

<p><br>
<div class="al-api"><b>int <a name="play_fli">play_fli</a>(const char *filename, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int loop, int (*callback)());</b></div><br>
   Plays an Autodesk Animator FLI or FLC animation file on the specified
   BITMAP, reading the data from disk as it is required. If <tt>`loop'</tt> is not
   zero, the player will cycle when it reaches the end of the file, otherwise
   it will play through the animation once and then return. Read the beginning
   of chapter "FLIC routines" for a description of the callback parameter.
   Example:
<blockquote class="code"><pre>
      /* Let users skip looped animations. */
      int check_escape_key(void)
      {
         if (<a href="#key" class="autotype" title="Array of flags indicating key state.">key</a>[KEY_ESC])
            return 1;
         else
            return 0;
      }
      ...
         int ret = <a href="#play_fli" class="autotype" title="Plays a FLI or FLC animation from disk.">play_fli</a>("animlogo.fli", <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 1,
                             check_escape_key);
         if (ret == FLI_ERROR)
            abort_on_error("Error playing intro!");</pre></blockquote>
<p><b>Return value:</b>
   The FLI player returns FLI_OK if it reached the end of the file, FLI_ERROR
   if something went wrong, and the value returned by the callback function if
   that was what stopped it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_memory_fli" title="Plays a FLI or FLC animation from memory.">play_memory_fli</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#fli_frame" title="Stores the current frame number of the animation.">fli_frame</a>.</blockquote>
<div class="al-api"><b>int <a name="play_memory_fli">play_memory_fli</a>(const void *fli_data, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int loop,
                    int (*callback)());</b></div><br>
   Plays an Autodesk Animator FLI or FLC animation on the specified BITMAP,
   reading the data from a copy of the file which is held in memory. You can
   obtain the <tt>`fli_data'</tt> pointer by allocating a block of memory and reading
   an FLI file into it, or by importing an FLI into a grabber datafile. If
   <tt>`loop'</tt> is not zero, the player will cycle when it reaches the end of the
   file, otherwise it will play through the animation once and then return.
   Read the beginning of chapter "FLIC routines" for a description of the
   callback parameter.

<p>
   Playing animations from memory is obviously faster than cuing them
   directly from disk, and is particularly useful with short, looped FLI's.
   Animations can easily get very large, though, so in most cases you will
   probably be better just using play_fli(). You can think of this function
   as a wrapper on top of open_memory_fli(), next_fli_frame() and close_fli().
   Example:
<blockquote class="code"><pre>
      int ret = <a href="#play_memory_fli" class="autotype" title="Plays a FLI or FLC animation from memory.">play_memory_fli</a>(anim_data, <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, NULL);
      if (ret == FLI_ERROR)
         abort_on_error("Corrupted animation data?");</pre></blockquote>
<p><b>Return value:</b>
   The FLI player returns FLI_OK if it reached the end of the file, FLI_ERROR
   if something went wrong, and the value returned by the callback function if
   that was what stopped it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_fli" title="Plays a FLI or FLC animation from disk.">play_fli</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#fli_frame" title="Stores the current frame number of the animation.">fli_frame</a>.</blockquote>
<div class="al-api"><b>int <a name="open_fli">open_fli</a>(const char *filename);</b></div><br>
<div class="al-api-cont"><b>int <a name="open_memory_fli">open_memory_fli</a>(const void *fli_data);</b></div><br>
   Open FLI files ready for playing, reading the data from disk or memory
   respectively. Information about the current FLI is held in the global
   variables fli_bitmap and fli_palette, which you can use if this function
   succeeds. However, you can only have one animation open at a time.
   Example:
<blockquote class="code"><pre>
      if (<a href="#open_fli" class="autotype" title="Makes a FLI file open and ready for playing.">open_fli</a>("intro.fli") == FLI_ERROR)
         abort_on_error("Error playing intro");</pre></blockquote>
<p><b>Return value:</b>
   Returns FLI_OK on success, FLI_ERROR if something went wrong, like trying
   to open another FLI file without closing the previous one.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#close_fli" title="Closes a FLI file previously opened.">close_fli</a>,
<a class="xref" href="#next_fli_frame" title="Reads the next frame of the current animation file.">next_fli_frame</a>,
<a class="xref" href="#fli_bitmap" title="Contains the current frame of the animation.">fli_bitmap</a>,
<a class="xref" href="#fli_palette" title="Contains the current palette of the animation.">fli_palette</a>.</blockquote>
<div class="al-api"><b>void <a name="close_fli">close_fli</a>();</b></div><br>
   Closes an FLI file when you have finished reading from it. Remember to do
   this to avoid having memory leaks in your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#open_fli" title="Makes a FLI file open and ready for playing.">open_fli</a>.</blockquote>
<div class="al-api"><b>int <a name="next_fli_frame">next_fli_frame</a>(int loop);</b></div><br>
   Reads the next frame of the current animation file. If <tt>`loop'</tt> is not zero,
   the player will cycle when it reaches the end of the file, otherwise it
   will return FLI_EOF. The frame is read into the global variables
   fli_bitmap and fli_palette. Example:
<blockquote class="code"><pre>
      while (<a href="#next_fli_frame" class="autotype" title="Reads the next frame of the current animation file.">next_fli_frame</a>(0) == FLI_OK) {
         /* Do stuff, like play audio stream
            or check keys to skip animation. */
         /* Rest some time until next frame... */
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns FLI_OK on success, FLI_ERROR or FLI_NOT_OPEN on error, and FLI_EOF
   on reaching the end of the file.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#open_fli" title="Makes a FLI file open and ready for playing.">open_fli</a>,
<a class="xref" href="#fli_bitmap" title="Contains the current frame of the animation.">fli_bitmap</a>,
<a class="xref" href="#fli_palette" title="Contains the current palette of the animation.">fli_palette</a>,
<a class="xref" href="#fli_timer" title="Global variable for timing FLI playback.">fli_timer</a>,
<a class="xref" href="#fli_frame" title="Stores the current frame number of the animation.">fli_frame</a>.</blockquote>
<div class="al-api"><b>extern <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="fli_bitmap">fli_bitmap</a>;</b></div><br>
   Contains the current frame of the FLI/FLC animation. If there is no open
   animation, its value will be NULL.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#next_fli_frame" title="Reads the next frame of the current animation file.">next_fli_frame</a>,
<a class="xref" href="#fli_bmp_dirty_from" title="Indicate which parts of the image have changed.">fli_bmp_dirty_from</a>,
<a class="xref" href="#fli_palette" title="Contains the current palette of the animation.">fli_palette</a>.</blockquote>
<div class="al-api"><b>extern <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> <a name="fli_palette">fli_palette</a>;</b></div><br>
   Contains the current FLI palette.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#next_fli_frame" title="Reads the next frame of the current animation file.">next_fli_frame</a>,
<a class="xref" href="#fli_pal_dirty_from" title="Indicate which parts of the palette have changed.">fli_pal_dirty_from</a>,
<a class="xref" href="#fli_bitmap" title="Contains the current frame of the animation.">fli_bitmap</a>.</blockquote>
<div class="al-api"><b>extern int <a name="fli_bmp_dirty_from">fli_bmp_dirty_from</a>;</b></div><br>
<div class="al-api-cont"><b>extern int <a name="fli_bmp_dirty_to">fli_bmp_dirty_to</a>;</b></div><br>
   These variables are set by next_fli_frame() to indicate which part of the 
   fli_bitmap has changed since the last call to reset_fli_variables(). If 
   fli_bmp_dirty_from is greater than fli_bmp_dirty_to, the bitmap has not 
   changed, otherwise lines fli_bmp_dirty_from to fli_bmp_dirty_to 
   (inclusive) have altered. You can use these when copying the fli_bitmap 
   onto the screen, to avoid moving data unnecessarily. Example:
<blockquote class="code"><pre>
      if (<a href="#fli_bmp_dirty_from" class="autotype" title="Indicate which parts of the image have changed.">fli_bmp_dirty_from</a> &lt;= <a href="#fli_bmp_dirty_to" class="autotype" title="Indicate which parts of the image have changed.">fli_bmp_dirty_to</a>)
         <a href="#blit" class="autotype" title="Copies a rectangular area from one bitmap to another.">blit</a>(<a href="#fli_bitmap" class="autotype" title="Contains the current frame of the animation.">fli_bitmap</a>, <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, <a href="#fli_bmp_dirty_from" class="autotype" title="Indicate which parts of the image have changed.">fli_bmp_dirty_from</a>,
              0, <a href="#fli_bmp_dirty_from" class="autotype" title="Indicate which parts of the image have changed.">fli_bmp_dirty_from</a>, <a href="#fli_bitmap" class="autotype" title="Contains the current frame of the animation.">fli_bitmap</a>->w,
              <a href="#fli_bmp_dirty_to" class="autotype" title="Indicate which parts of the image have changed.">fli_bmp_dirty_to</a> - <a href="#fli_bmp_dirty_from" class="autotype" title="Indicate which parts of the image have changed.">fli_bmp_dirty_from</a> + 1);</pre></blockquote>
              

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fli_bitmap" title="Contains the current frame of the animation.">fli_bitmap</a>,
<a class="xref" href="#reset_fli_variables" title="Resets the bitmap and palette dirty global variables.">reset_fli_variables</a>.</blockquote>
<div class="al-api"><b>extern int <a name="fli_pal_dirty_from">fli_pal_dirty_from</a>;</b></div><br>
<div class="al-api-cont"><b>extern int <a name="fli_pal_dirty_to">fli_pal_dirty_to</a>;</b></div><br>
   These variables are set by next_fli_frame() to indicate which part of the 
   fli_palette has changed since the last call to reset_fli_variables(). If 
   fli_pal_dirty_from is greater than fli_pal_dirty_to, the palette has not 
   changed, otherwise colors fli_pal_dirty_from to fli_pal_dirty_to 
   (inclusive) have altered. You can use these when updating the hardware 
   palette, to avoid unnecessary calls to set_palette(). Example:
<blockquote class="code"><pre>
      if (<a href="#fli_pal_dirty_from" class="autotype" title="Indicate which parts of the palette have changed.">fli_pal_dirty_from</a> &lt;= <a href="#fli_pal_dirty_to" class="autotype" title="Indicate which parts of the palette have changed.">fli_pal_dirty_to</a>)
         <a href="#set_palette_range" class="autotype" title="Sets a specific range of the palette.">set_palette_range</a>(<a href="#fli_palette" class="autotype" title="Contains the current palette of the animation.">fli_palette</a>, <a href="#fli_pal_dirty_from" class="autotype" title="Indicate which parts of the palette have changed.">fli_pal_dirty_from</a>,
                           <a href="#fli_pal_dirty_to" class="autotype" title="Indicate which parts of the palette have changed.">fli_pal_dirty_to</a>, 1);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fli_palette" title="Contains the current palette of the animation.">fli_palette</a>,
<a class="xref" href="#reset_fli_variables" title="Resets the bitmap and palette dirty global variables.">reset_fli_variables</a>.</blockquote>
<div class="al-api"><b>void <a name="reset_fli_variables">reset_fli_variables</a>();</b></div><br>
   Once you have done whatever you are going to do with the fli_bitmap and 
   fli_palette, call this function to reset the fli_bmp_dirty_* and 
   fli_pal_dirty_* variables.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fli_bmp_dirty_from" title="Indicate which parts of the image have changed.">fli_bmp_dirty_from</a>,
<a class="xref" href="#fli_pal_dirty_from" title="Indicate which parts of the palette have changed.">fli_pal_dirty_from</a>.</blockquote>
<div class="al-api"><b>extern int <a name="fli_frame">fli_frame</a>;</b></div><br>
   Global variable containing the current frame number in the FLI file. This 
   is useful for synchronising other events with the animation, for instance 
   you could check it in a play_fli() callback function and use it to 
   trigger a sample at a particular point. Example:
<blockquote class="code"><pre>
      while (<a href="#next_fli_frame" class="autotype" title="Reads the next frame of the current animation file.">next_fli_frame</a>(0) == FLI_OK) {
         if (<a href="#fli_frame" class="autotype" title="Stores the current frame number of the animation.">fli_frame</a> == 345)
            <a href="#play_sample" class="autotype" title="Plays a sample.">play_sample</a>(trumpet_sound, 255, 128, 1000, 0);
         /* Rest some time until next frame... */
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_fli" title="Plays a FLI or FLC animation from disk.">play_fli</a>,
<a class="xref" href="#play_memory_fli" title="Plays a FLI or FLC animation from memory.">play_memory_fli</a>,
<a class="xref" href="#next_fli_frame" title="Reads the next frame of the current animation file.">next_fli_frame</a>.</blockquote>
<div class="al-api"><b>extern volatile int <a name="fli_timer">fli_timer</a>;</b></div><br>
   Global variable for timing FLI playback. When you open an FLI file, a 
   timer interrupt is installed which increments this variable every time a 
   new frame should be displayed. Calling next_fli_frame() decrements it, so 
   you can test it and know that it is time to display a new frame if it is 
   greater than zero. Example:
<blockquote class="code"><pre>
      while (<a href="#next_fli_frame" class="autotype" title="Reads the next frame of the current animation file.">next_fli_frame</a>(0) == FLI_OK) {
         /* Do stuff, like play audio stream
            or check keys to skip animation. */
         /* Rest some time until next frame... */
         while (<a href="#fli_timer" class="autotype" title="Global variable for timing FLI playback.">fli_timer</a> &lt;= 0)
            <a href="#rest" class="autotype" title="Waits a specified number of milliseconds or yields CPU.">rest</a>(0);
      }</pre></blockquote>




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#next_fli_frame" title="Reads the next frame of the current animation file.">next_fli_frame</a>.</blockquote>
<h1><a name="Sound init routines">Sound init routines</a></h1>

<p>
Allegro allows you to use the sound hardware in two ways: automatic, or
manual. Usually you should try the automatic version first. This means
calling install_sound() with the autodetection parameters and using the rest
of the sound functions to play samples or music. In this situation, Allegro
will handle the sound devices and mix the samples and/or music the best way
it can.

<p>
However, sound hardware has a limitation on the number of samples it may
play all at the same time (from now on, called hardware voices). When you
exceed this limit, Allegro will cut off one of the samples being played and
reproduce the new one. Depending on the type of sounds you are playing, how
many of them you need at the same time and their nature (e.g: vital audio
feedback to the user or useless "ping" when some shrapnel hits a rock in the
scenery) you will want to specify more carefully how hardware voices are
reserved and which samples have priority over others.

<p>
The hardware voice reservation phase has to be done before the call to
install_sound(), since it directly affects how Allegro talks to the sound
drivers.

<p><br>
<div class="al-api"><b>int <a name="detect_digi_driver">detect_digi_driver</a>(int driver_id);</b></div><br>
   Detects whether the specified digital sound device is available. This
   function must be called _before_ install_sound().
<p><b>Return value:</b>
   Returns the maximum number of voices that the driver can provide, or zero
   if the hardware is not present.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#reserve_voices" title="Reserve a number of voices for the digital and MIDI drivers.">reserve_voices</a>,
<a class="xref" href="#DIGI_*/DOS" title="Supported DOS digital sound drivers.">DIGI_*/DOS</a>,
<a class="xref" href="#DIGI_*/Windows" title="Supported Windows digital sound drivers.">DIGI_*/Windows</a>,
<a class="xref" href="#DIGI_*/Unix" title="Supported Unix digital sound drivers.">DIGI_*/Unix</a>,
<a class="xref" href="#DIGI_*/BeOS" title="Supported BeOS digital sound drivers.">DIGI_*/BeOS</a>,
<a class="xref" href="#DIGI_*/QNX" title="Supported QNX digital sound drivers.">DIGI_*/QNX</a>,
<a class="xref" href="#DIGI_*/MacOSX" title="Supported MacOSX digital sound drivers.">DIGI_*/MacOSX</a>.</blockquote>
<div class="al-api"><b>int <a name="detect_midi_driver">detect_midi_driver</a>(int driver_id);</b></div><br>
   Detects whether the specified MIDI sound device is available. This function
   must be called _before_ install_sound().
<p><b>Return value:</b>
   Returns the maximum number of voices that the driver can provide, or zero
   if the hardware is not present.

<p>
   There are two special-case return values that you should watch out for:
   if this function returns -1 it is a note-stealing driver (eg. DIGMID) that
   shares voices with the current digital sound driver, and if it returns
   0xFFFF it is an external device like an MPU-401 where there is no way to
   determine how many voices are available.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#reserve_voices" title="Reserve a number of voices for the digital and MIDI drivers.">reserve_voices</a>,
<a class="xref" href="#MIDI_*/DOS" title="Supported DOS MIDI sound drivers.">MIDI_*/DOS</a>,
<a class="xref" href="#MIDI_*/Windows" title="Supported Windows MIDI sound drivers.">MIDI_*/Windows</a>,
<a class="xref" href="#MIDI_*/Unix" title="Supported Unix MIDI sound drivers.">MIDI_*/Unix</a>,
<a class="xref" href="#MIDI_*/BeOS" title="Supported BeOS MIDI sound drivers.">MIDI_*/BeOS</a>,
<a class="xref" href="#MIDI_*/QNX" title="Supported QNX MIDI sound drivers.">MIDI_*/QNX</a>,
<a class="xref" href="#MIDI_*/MacOSX" title="Supported MacOSX MIDI sound drivers.">MIDI_*/MacOSX</a>.</blockquote>
<div class="al-api"><b>void <a name="reserve_voices">reserve_voices</a>(int digi_voices, int midi_voices);</b></div><br>
   Call this function to specify the number of voices that are to be used by
   the digital and MIDI sound drivers respectively. This must be done
   _before_ calling install_sound(). If you reserve too many voices,
   subsequent calls to install_sound() will fail. How many voices are
   available depends on the driver, and in some cases you will actually get
   more than you reserve (eg. the FM synth drivers will always provide 9
   voices on an OPL2 and 18 on an OPL3, and the SB digital driver will round
   the number of voices up to the nearest power of two). Pass negative
   values to restore the default settings. You should be aware that the
   sound quality is usually inversely related to how many voices you use, so
   don't reserve any more than you really need.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_volume_per_voice" title="Sets the volume of a voice.">set_volume_per_voice</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#detect_digi_driver" title="Detects whether the specified digital sound device is available.">detect_digi_driver</a>,
<a class="xref" href="#detect_midi_driver" title="Detects whether the specified MIDI sound device is available.">detect_midi_driver</a>,
<a class="xref" href="#get_mixer_voices" title="Returns the number of voices allocated to the mixer.">get_mixer_voices</a>.</blockquote>
<div class="al-api"><b>void <a name="set_volume_per_voice">set_volume_per_voice</a>(int scale);</b></div><br>
   By default, Allegro will play a centered sample at half volume on both
   the left and right channel. A sample panned to the far right or left
   will be played at maximum volume on that channel only. This is done so
   you can play a single panned sample without distortion. If you play
   multiple samples at full volume, the mixing process can result in
   clipping, a noticeable form of distortion. The more samples, the more
   likely clipping is to occur, and the more clipping, the worse the output
   will sound.

<p>
   If clipping is a problem - or if the output is too quiet - this function
   can be used to adjust the volume of each voice. You should first check
   that your speakers are at a reasonable volume, Allegro's global volume
   is at maximum (see set_volume() below), and any other mixers such as the
   Windows Volume Control are set reasonably. Once you are sure that
   Allegro's output level is unsuitable for your application, use this
   function to adjust it.

<p>
   Each time you increase the parameter by one, the volume of each voice
   will halve. For example, if you pass 4, you can play up to 16 centred
   samples at maximum volume without distortion.

<p>
   If you pass 0 to this function, each centred sample will play at the
   maximum volume possible without distortion, as will all samples played
   through a mono driver. Samples at the extreme left and right will distort
   if played at full volume. If you wish to play panned samples at full
   volume without distortion, you should pass 1 to this function.
   Note: this is different from the function's behaviour in WIPs 3.9.34,
   3.9.35 and 3.9.36. If you used this function under one of these WIPs,
   you will have to increase your parameter by one to get the same volume.

<p>
   Note: The default behaviour has changed as of Allegro 4.1.15. If you
   would like the behaviour of earlier versions of Allegro, pass -1 to this
   function. Allegro will choose a value dependent on the number of voices,
   so that if you reserve n voices, you can play up to n/2 normalised
   samples with centre panning without risking distortion. The exception is
   when you have fewer than 8 voices, where the volume remains the same as
   for 8 voices. Here are the values, dependent on the number of voices:
<blockquote class="text"><pre>
     1-8 voices - set_volume_per_voice(2)
      16 voices - set_volume_per_voice(3)
      32 voices - set_volume_per_voice(4)
      64 voices - set_volume_per_voice(5)
</pre></blockquote>
   Of course this function does not override the volume you specify with
   play_sample() or voice_set_volume(). It simply alters the overall output
   of the program. If you play samples at lower volumes, or if they are not
   normalised, then you can play more of them without distortion.

<p>
   It is recommended that you hard-code the parameter into your program,
   rather than offering it to the user. The user can alter the volume with
   the configuration file instead, or you can provide for this with
   set_volume().

<p>
   To restore volume per voice to its default behaviour, pass 1.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#reserve_voices" title="Reserve a number of voices for the digital and MIDI drivers.">reserve_voices</a>,
<a class="xref" href="#set_volume" title="Alters the global sound output volume.">set_volume</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#detect_digi_driver" title="Detects whether the specified digital sound device is available.">detect_digi_driver</a>,
<a class="xref" href="#detect_midi_driver" title="Detects whether the specified MIDI sound device is available.">detect_midi_driver</a>.</blockquote>
<div class="al-api"><b>int <a name="install_sound">install_sound</a>(int digi, int midi, const char *cfg_path);</b></div><br>
   Initialises the sound module. You should normally pass DIGI_AUTODETECT 
   and MIDI_AUTODETECT as the driver parameters to this function, in which 
   case Allegro will read hardware settings from the current configuration 
   file. This allows the user to select different values with the setup 
   utility: see the config section for details. Alternatively, see the 
   platform specific documentation for a list of the available drivers. The 
   cfg_path parameter is only present for compatibility with previous 
   versions of Allegro, and has no effect on anything.
<p><b>Return value:</b>
   Returns zero if the sound is successfully installed, and -1 on failure.
   If it fails it will store a description of the problem in allegro_error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#remove_sound" title="Cleans up after you are finished with the sound routines.">remove_sound</a>,
<a class="xref" href="#reserve_voices" title="Reserve a number of voices for the digital and MIDI drivers.">reserve_voices</a>,
<a class="xref" href="#detect_digi_driver" title="Detects whether the specified digital sound device is available.">detect_digi_driver</a>,
<a class="xref" href="#detect_midi_driver" title="Detects whether the specified MIDI sound device is available.">detect_midi_driver</a>,
<a class="xref" href="#set_volume" title="Alters the global sound output volume.">set_volume</a>,
<a class="xref" href="#play_sample" title="Plays a sample.">play_sample</a>,
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#play_midi" title="Starts playing the specified MIDI file.">play_midi</a>,
<a class="xref" href="#play_audio_stream" title="Creates a new audio stream and starts playing it.">play_audio_stream</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>,
<a class="xref" href="#set_mixer_quality" title="Sets the resampling quality of the mixer.">set_mixer_quality</a>,
<a class="xref" href="#DIGI_*/DOS" title="Supported DOS digital sound drivers.">DIGI_*/DOS</a>,
<a class="xref" href="#DIGI_*/Windows" title="Supported Windows digital sound drivers.">DIGI_*/Windows</a>,
<a class="xref" href="#DIGI_*/Unix" title="Supported Unix digital sound drivers.">DIGI_*/Unix</a>,
<a class="xref" href="#DIGI_*/BeOS" title="Supported BeOS digital sound drivers.">DIGI_*/BeOS</a>,
<a class="xref" href="#DIGI_*/QNX" title="Supported QNX digital sound drivers.">DIGI_*/QNX</a>,
<a class="xref" href="#DIGI_*/MacOSX" title="Supported MacOSX digital sound drivers.">DIGI_*/MacOSX</a>,
<a class="xref" href="#MIDI_*/DOS" title="Supported DOS MIDI sound drivers.">MIDI_*/DOS</a>,
<a class="xref" href="#MIDI_*/Windows" title="Supported Windows MIDI sound drivers.">MIDI_*/Windows</a>,
<a class="xref" href="#MIDI_*/Unix" title="Supported Unix MIDI sound drivers.">MIDI_*/Unix</a>,
<a class="xref" href="#MIDI_*/BeOS" title="Supported BeOS MIDI sound drivers.">MIDI_*/BeOS</a>,
<a class="xref" href="#MIDI_*/QNX" title="Supported QNX MIDI sound drivers.">MIDI_*/QNX</a>,
<a class="xref" href="#MIDI_*/MacOSX" title="Supported MacOSX MIDI sound drivers.">MIDI_*/MacOSX</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>,
<a class="eref" href="#exsample" title="Playing digital samples.">exsample</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exstream" title="Playing audio streams.">exstream</a>.</blockquote>
<div class="al-api"><b>void <a name="remove_sound">remove_sound</a>();</b></div><br>
   Cleans up after you are finished with the sound routines. You don't 
   normally need to call this, because allegro_exit() will do it for you.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>.</blockquote>
<div class="al-api"><b>void <a name="set_volume">set_volume</a>(int digi_volume, int midi_volume);</b></div><br>
   Alters the global sound output volume. Specify volumes for both digital 
   samples and MIDI playback, as integers from 0 to 255, or pass a negative 
   value to leave one of the settings unchanged. Values bigger than 255 will
   be reduced to 255. This routine will not alter the volume of the hardware
   mixer if it exists (i.e. only your application will be affected).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#set_hardware_volume" title="Alters the hardware sound output volume.">set_hardware_volume</a>.</blockquote>
<div class="al-api"><b>void <a name="set_hardware_volume">set_hardware_volume</a>(int digi_volume, int midi_volume);</b></div><br>
   Alters the hardware sound output volume. Specify volumes for both digital 
   samples and MIDI playback, as integers from 0 to 255, or pass a negative 
   value to leave one of the settings unchanged. Values bigger than 255 will
   be reduced to 255. This routine will use the hardware mixer to control the
   volume if it exists (i.e. the volume of all the applications on your
   machine will be affected), otherwise do nothing.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#set_volume" title="Alters the global sound output volume.">set_volume</a>.</blockquote>
<div class="al-api"><b>void <a name="get_volume">get_volume</a>(int *digi_volume, int *midi_volume);</b></div><br>
   Retrieves the global sound output volume, both for digital samples and MIDI
   playback, as integers from 0 to 255. Parameters digi_volume and midi_volume
   must be valid pointers to int, or NULL if not interested in specific value.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_volume" title="Alters the global sound output volume.">set_volume</a>,
<a class="xref" href="#get_hardware_volume" title="Retrieves the hardware sound output volume.">get_hardware_volume</a>.</blockquote>
<div class="al-api"><b>void <a name="get_hardware_volume">get_hardware_volume</a>(int *digi_volume, int *midi_volume);</b></div><br>
   Retrieves the hardware sound output volume, both for digital samples and MIDI
   playback, as integers from 0 to 255, or -1 if the information is not
   available. Parameters digi_volume and midi_volume must be valid pointers to
   int, or NULL if not interested in specific value.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_hardware_volume" title="Alters the hardware sound output volume.">set_hardware_volume</a>,
<a class="xref" href="#get_volume" title="Retrieves the global sound output volume.">get_volume</a>.</blockquote>
<h1><a name="Mixer routines">Mixer routines</a></h1>



<p><br>
<div class="al-api"><b>void <a name="set_mixer_quality">set_mixer_quality</a>(int quality);</b></div><br>
   Sets the resampling quality of the mixer. Valid values are the same as
   the <tt>`quality'</tt> config variable. Please read chapter "Standard config
   variables" for details. You can call this function at any point in your
   program, even before allegro_init().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_mixer_quality" title="Returns the current mixing quality.">get_mixer_quality</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>
<div class="al-api"><b>int <a name="get_mixer_quality">get_mixer_quality</a>(void);</b></div><br>
   Returns the current mixing quality, as specified by the <tt>`quality'</tt> config
   variable, or a previous call to set_mixer_quality().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_mixer_quality" title="Sets the resampling quality of the mixer.">set_mixer_quality</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>
<div class="al-api"><b>int <a name="get_mixer_frequency">get_mixer_frequency</a>(void);</b></div><br>
   Returns the mixer frequency, in Hz.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>
<div class="al-api"><b>int <a name="get_mixer_bits">get_mixer_bits</a>(void);</b></div><br>
   Returns the mixer bit depth (8 or 16).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>
<div class="al-api"><b>int <a name="get_mixer_channels">get_mixer_channels</a>(void);</b></div><br>
   Returns the number of output channels. 2 for stereo, 1 for mono, 0 if
   the mixer isn't active.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>
<div class="al-api"><b>int <a name="get_mixer_voices">get_mixer_voices</a>(void);</b></div><br>
   Returns the number of voices allocated to the mixer.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#reserve_voices" title="Reserve a number of voices for the digital and MIDI drivers.">reserve_voices</a>.</blockquote>
<div class="al-api"><b>int <a name="get_mixer_buffer_length">get_mixer_buffer_length</a>(void);</b></div><br>
   Returns the number of samples per channel in the mixer buffer.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>.</blockquote>
<h1><a name="Digital sample routines">Digital sample routines</a></h1>

<p><br>
<div class="al-api"><b><a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *<a name="load_sample">load_sample</a>(const char *filename);</b></div><br>
   Loads a sample from a file, supporting both mono and stereo WAV and mono
   VOC files, in 8 or 16-bit formats, as well as formats handled by functions
   registered using register_sample_file_type(). Example:
<blockquote class="code"><pre>
      <a href="#SAMPLE" class="autotype" title="Stores sound data.">SAMPLE</a> *sample = <a href="#load_sample" class="autotype" title="Loads a sample from a file.">load_sample</a>(user_input);
      if (!sample)
         abort_on_error("Couldn't load sample!");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the SAMPLE or NULL on error. Remember to free this
   sample later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#destroy_sample" title="Destroys a sample structure when you are done with it.">destroy_sample</a>,
<a class="xref" href="#load_voc" title="Loads a sample from a Creative Labs VOC file.">load_voc</a>,
<a class="xref" href="#load_wav" title="Loads a sample from a RIFF WAV file.">load_wav</a>,
<a class="xref" href="#play_sample" title="Plays a sample.">play_sample</a>,
<a class="xref" href="#save_sample" title="Writes a sample into a file.">save_sample</a>,
<a class="xref" href="#register_sample_file_type" title="Registers custom loading/saving sample routines.">register_sample_file_type</a>,
<a class="xref" href="#Voice control" title="">Voice control</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsample" title="Playing digital samples.">exsample</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *<a name="load_wav">load_wav</a>(const char *filename);</b></div><br>
   Loads a sample from a RIFF WAV file. Example:
<blockquote class="code"><pre>
      <a href="#SAMPLE" class="autotype" title="Stores sound data.">SAMPLE</a> *sample = <a href="#load_wav" class="autotype" title="Loads a sample from a RIFF WAV file.">load_wav</a>("scream.wav");
      if (!sample)
         abort_on_error("Couldn't scare user!");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the SAMPLE or NULL on error. Remember to free this
   sample later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>,
<a class="xref" href="#register_sample_file_type" title="Registers custom loading/saving sample routines.">register_sample_file_type</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *<a name="load_wav_pf">load_wav_pf</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   A version of load_wav() which reads from a packfile. Example:
<blockquote class="code"><pre>
      <a href="#PACKFILE" class="autotype" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *packfile;
      <a href="#SAMPLE" class="autotype" title="Stores sound data.">SAMPLE</a> *sample;
   
      packfile = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>("sound.wav", F_READ);
      if (!packfile)
         abort_on_error("Couldn't open sound.wav");
   
      sample = <a href="#load_wav_pf" class="autotype" title="Packfile version of load_wav.">load_wav_pf</a>(packfile);
      if (!sample)
         abort_on_error("Error loading sound.wav");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the SAMPLE or NULL on error. Remember to free this
   sample later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_wav" title="Loads a sample from a RIFF WAV file.">load_wav</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *<a name="load_voc">load_voc</a>(const char *filename);</b></div><br>
   Loads a sample from a Creative Labs VOC file. Example:
<blockquote class="code"><pre>
      <a href="#SAMPLE" class="autotype" title="Stores sound data.">SAMPLE</a> *sample = <a href="#load_voc" class="autotype" title="Loads a sample from a Creative Labs VOC file.">load_voc</a>("alarm.voc");
      if (!sample)
         abort_on_error("Couldn't <a href="#alert" class="autotype" title="Displays a popup alert box.">alert</a> user!");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the SAMPLE or NULL on error. Remember to free this
   sample later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>,
<a class="xref" href="#register_sample_file_type" title="Registers custom loading/saving sample routines.">register_sample_file_type</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *<a name="load_voc_pf">load_voc_pf</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   A version of load_voc() which reads from a packfile. Example:
<blockquote class="code"><pre>
      <a href="#PACKFILE" class="autotype" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *packfile;
      <a href="#SAMPLE" class="autotype" title="Stores sound data.">SAMPLE</a> *sample;
   
      packfile = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>("sound.wav", F_READ);
      if (!packfile)
         abort_on_error("Couldn't open sound.wav");
   
      sample = <a href="#load_wav_pf" class="autotype" title="Packfile version of load_wav.">load_wav_pf</a>(packfile);
      if (!sample)
         abort_on_error("Error loading sound.wav");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the SAMPLE or NULL on error. Remember to free this
   sample later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_voc" title="Loads a sample from a Creative Labs VOC file.">load_voc</a>.</blockquote>
<div class="al-api"><b>int <a name="save_sample">save_sample</a>(const char *filename, <a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *spl);</b></div><br>
   Writes a sample into a file. The output format is determined from the
   filename extension. At present Allegro does not natively support the
   writing of any sample formats, so you must register a custom saver routine
   with register_sample_file_type(). Example:
<blockquote class="code"><pre>
      if (<a href="#save_sample" class="autotype" title="Writes a sample into a file.">save_sample</a>("sound.wav", sample) != 0)
         abort_on_error("Couldn't save sample!");</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success, non-zero otherwise.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>,
<a class="xref" href="#register_sample_file_type" title="Registers custom loading/saving sample routines.">register_sample_file_type</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *<a name="create_sample">create_sample</a>(int bits, int stereo, int freq, int len);</b></div><br>
   Constructs a new sample structure of the specified type. Read chapter
   "Structures and types defined by Allegro" for an internal description of
   the SAMPLE structure. The <tt>`bits'</tt> parameter can be 8 or 16, <tt>`stereo'</tt> can be
   zero for mono samples and non-zero for stereo samples, <tt>`freq'</tt> is the
   frequency in hertz, and <tt>`len'</tt> is the number of samples you want to allocate
   for the full sound buffer.
<p><b>Return value:</b>
   Returns a pointer to the created sample, or NULL if the sample could not
   be created. Remember to free this sample later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>,
<a class="xref" href="#destroy_sample" title="Destroys a sample structure when you are done with it.">destroy_sample</a>,
<a class="xref" href="#Structures and types defined by Allegro" title="">Structures and types defined by Allegro</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_sample">destroy_sample</a>(<a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *spl);</b></div><br>
   Destroys a sample structure when you are done with it. It is safe to call 
   this even when the sample might be playing, because it checks and will 
   kill it off if it is active. Use this to avoid memory leaks in your
   program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsample" title="Playing digital samples.">exsample</a>.</blockquote>
<div class="al-api"><b>void <a name="lock_sample">lock_sample</a>(<a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *spl);</b></div><br>
   Under DOS, locks all the memory used by a sample. You don't normally need 
   to call this function because load_sample() and create_sample() do it for
   you.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>,
<a class="xref" href="#create_sample" title="Constructs a new sample structure of the specified type.">create_sample</a>.</blockquote>
<div class="al-api"><b>void <a name="register_sample_file_type">register_sample_file_type</a>(const char *ext,
                          <a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *(*load)(const char *filename),
                          int (*save)(const char *filename, <a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *spl));</b></div><br>
   Informs the load_sample() function of a new sample file type,
   providing routines to read and write samples in this format (either
   function may be NULL). Example:
<blockquote class="code"><pre>
      <a href="#SAMPLE" class="autotype" title="Stores sound data.">SAMPLE</a> *load_mp3(const char *filename)
      {
         ...
      }
      
         <a href="#register_sample_file_type" class="autotype" title="Registers custom loading/saving sample routines.">register_sample_file_type</a>("mp3", load_mp3, NULL);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>,
<a class="xref" href="#save_sample" title="Writes a sample into a file.">save_sample</a>.</blockquote>
<div class="al-api"><b>int <a name="play_sample">play_sample</a>(const <a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *spl, int vol, int pan, int freq, int loop);</b></div><br>
   Triggers a sample at the specified volume, pan position, and frequency. 
   The parameters <tt>`vol'</tt> and <tt>`pan'</tt> range from 0 (min/left) to 255 (max/right).
   Frequency is relative rather than absolute: 1000 represents the frequency
   that the sample was recorded at, 2000 is twice this, etc. If <tt>`loop'</tt> is not
   zero, the sample will repeat until you call stop_sample(), and can be
   manipulated while it is playing by calling adjust_sample(). Example:
<blockquote class="code"><pre>
      /* Scream from the left speaker, twice the freq. */
      int sound = <a href="#play_sample" class="autotype" title="Plays a sample.">play_sample</a>(scream, 255, 0, 2000, 0);</pre></blockquote>
<p><b>Return value:</b>
   Returns the voice number that was allocated for the sample or negative if
   no voices were available.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>,
<a class="xref" href="#adjust_sample" title="Alters the parameters of a sample while it is playing.">adjust_sample</a>,
<a class="xref" href="#stop_sample" title="Stops a sample from playing.">stop_sample</a>,
<a class="xref" href="#Voice control" title="">Voice control</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsample" title="Playing digital samples.">exsample</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>.</blockquote>
<div class="al-api"><b>void <a name="adjust_sample">adjust_sample</a>(const <a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *spl, int vol, int pan, int freq, int loop);</b></div><br>
   Alters the parameters of a sample while it is playing (useful for
   manipulating looped sounds). You can alter the volume, pan, and frequency,
   and can also clear the loop flag, which will stop the sample when it next
   reaches the end of its loop. The values of the parameters are just like
   those of play_sample(). If there are several copies of the same sample
   playing, this will adjust the first one it comes across. If the sample is
   not playing it has no effect.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_sample" title="Plays a sample.">play_sample</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exsample" title="Playing digital samples.">exsample</a>.</blockquote>
<div class="al-api"><b>void <a name="stop_sample">stop_sample</a>(const <a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *spl);</b></div><br>
   Stop a sample from playing, which is required if you have set a sample
   going in looped mode. If there are several copies of the sample playing,
   it will stop them all. You must still destroy the sample using
   destroy_sample().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_sample" title="Plays a sample.">play_sample</a>,
<a class="xref" href="#destroy_sample" title="Destroys a sample structure when you are done with it.">destroy_sample</a>.</blockquote>
<br><center><h2><a name="Voice control">Voice control</a></h2></center><p>
If you need more detailed control over how samples are played, you can use 
the lower level voice functions rather than just calling play_sample(). This 
is rather more work, because you have to explicitly allocate and free the 
voices rather than them being automatically released when they finish 
playing, but allows far more precise specification of exactly how you want 
everything to sound. You may also want to modify a couple of fields from the 
SAMPLE structure. Read chapter "Structures and types defined by Allegro" for
its definition.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#allocate_voice" title="Allocates a sound card voice for a sample.">allocate_voice</a>,
<a class="xref" href="#deallocate_voice" title="Frees a sound card voice.">deallocate_voice</a>,
<a class="xref" href="#reallocate_voice" title="Switches the sample of an already-allocated voice.">reallocate_voice</a>,
<a class="xref" href="#release_voice" title="Releases a sound card voice.">release_voice</a>,
<a class="xref" href="#voice_start" title="Activates a voice.">voice_start</a>,
<a class="xref" href="#voice_set_priority" title="Sets the priority of a voice.">voice_set_priority</a>,
<a class="xref" href="#voice_check" title="Checks whether a voice is currently allocated.">voice_check</a>,
<a class="xref" href="#voice_set_position" title="Sets the position of a voice.">voice_set_position</a>,
<a class="xref" href="#voice_set_playmode" title="Adjusts the loop status of the specified voice.">voice_set_playmode</a>,
<a class="xref" href="#voice_set_volume" title="Sets the volume of the voice.">voice_set_volume</a>,
<a class="xref" href="#voice_set_frequency" title="Sets the pitch of the voice.">voice_set_frequency</a>,
<a class="xref" href="#voice_set_pan" title="Sets the pan position.">voice_set_pan</a>,
<a class="xref" href="#SAMPLE" title="Stores sound data.">SAMPLE</a>.</blockquote>
<div class="al-api"><b>int <a name="allocate_voice">allocate_voice</a>(const <a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *spl);</b></div><br>
   Allocates a sound card voice and prepares it for playing the specified 
   sample, setting up sensible default parameters (maximum volume, centre 
   pan, no change of pitch, no looping). When you are finished with the 
   voice you must free it by calling deallocate_voice() or release_voice().
   Allegro can manage up to 256 simultaneous voices, but that limit may be
   lower due to hardware reasons.
<p><b>Return value:</b>
   Returns the voice number, or -1 if no voices are available.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#deallocate_voice" title="Frees a sound card voice.">deallocate_voice</a>,
<a class="xref" href="#reallocate_voice" title="Switches the sample of an already-allocated voice.">reallocate_voice</a>,
<a class="xref" href="#release_voice" title="Releases a sound card voice.">release_voice</a>,
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>.</blockquote>
<div class="al-api"><b>void <a name="deallocate_voice">deallocate_voice</a>(int voice);</b></div><br>
   Frees a sound card voice, stopping it from playing and releasing whatever 
   resources it is using.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#allocate_voice" title="Allocates a sound card voice for a sample.">allocate_voice</a>,
<a class="xref" href="#voice_stop" title="Stops a voice.">voice_stop</a>.</blockquote>
<div class="al-api"><b>void <a name="reallocate_voice">reallocate_voice</a>(int voice, const <a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *spl);</b></div><br>
   Switches an already-allocated voice to use a different sample. Calling 
   reallocate_voice(voice, sample) is equivalent to:
<blockquote class="code"><pre>
      <a href="#deallocate_voice" class="autotype" title="Frees a sound card voice.">deallocate_voice</a>(voice);
      voice = <a href="#allocate_voice" class="autotype" title="Allocates a sound card voice for a sample.">allocate_voice</a>(sample);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#allocate_voice" title="Allocates a sound card voice for a sample.">allocate_voice</a>,
<a class="xref" href="#deallocate_voice" title="Frees a sound card voice.">deallocate_voice</a>,
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>.</blockquote>
<div class="al-api"><b>void <a name="release_voice">release_voice</a>(int voice);</b></div><br>
   Releases a sound card voice, indicating that you are no longer interested 
   in manipulating it. The sound will continue to play, and any resources 
   that it is using will automatically be freed when it finishes. This is 
   essentially the same as deallocate_voice(), but it waits for the sound to 
   stop playing before taking effect.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#allocate_voice" title="Allocates a sound card voice for a sample.">allocate_voice</a>,
<a class="xref" href="#deallocate_voice" title="Frees a sound card voice.">deallocate_voice</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_start">voice_start</a>(int voice);</b></div><br>
   Activates a voice, using whatever parameters have been set for it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#allocate_voice" title="Allocates a sound card voice for a sample.">allocate_voice</a>,
<a class="xref" href="#voice_stop" title="Stops a voice.">voice_stop</a>,
<a class="xref" href="#release_voice" title="Releases a sound card voice.">release_voice</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstream" title="Playing audio streams.">exstream</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_stop">voice_stop</a>(int voice);</b></div><br>
   Stops a voice, storing the current position and state so that it may 
   later be resumed by calling voice_start().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#voice_start" title="Activates a voice.">voice_start</a>,
<a class="xref" href="#deallocate_voice" title="Frees a sound card voice.">deallocate_voice</a>,
<a class="xref" href="#release_voice" title="Releases a sound card voice.">release_voice</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstream" title="Playing audio streams.">exstream</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_set_priority">voice_set_priority</a>(int voice, int priority);</b></div><br>
   Sets the priority of a voice (range 0-255). This is used to decide which 
   voices should be chopped off, if you attempt to play more than the 
   sound card driver can handle.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#SAMPLE" title="Stores sound data.">SAMPLE</a> *<a name="voice_check">voice_check</a>(int voice);</b></div><br>
   Checks whether a voice is currently allocated.
<p><b>Return value:</b>
   Returns a pointer to the sample that the voice is using, or NULL if the
   voice is inactive (ie. it has been deallocated, or the release_voice()
   function has been called and the sample has then finished playing).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#allocate_voice" title="Allocates a sound card voice for a sample.">allocate_voice</a>,
<a class="xref" href="#voice_start" title="Activates a voice.">voice_start</a>,
<a class="xref" href="#voice_get_position" title="Returns the current position of a voice.">voice_get_position</a>.</blockquote>
<div class="al-api"><b>int <a name="voice_get_position">voice_get_position</a>(int voice);</b></div><br>
   Returns the current position of a voice, in sample units, or -1 if it has 
   finished playing.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_set_position" title="Sets the position of a voice.">voice_set_position</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_set_position">voice_set_position</a>(int voice, int position);</b></div><br>
   Sets the position of a voice, in sample units.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_get_position" title="Returns the current position of a voice.">voice_get_position</a>,
<a class="xref" href="#voice_set_playmode" title="Adjusts the loop status of the specified voice.">voice_set_playmode</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_set_playmode">voice_set_playmode</a>(int voice, int playmode);</b></div><br>
   Adjusts the loop status of the specified voice. This can be done while 
   the voice is playing, so you can start a sample in looped mode (having 
   set the loop start and end positions to the appropriate values), and then 
   clear the loop flag when you want to end the sound, which will cause it 
   to continue past the loop end, play the subsequent part of the sample, 
   and finish in the normal way. The mode parameter is a bitfield containing 
   the following values:
   <ul><li>
   PLAYMODE_PLAY<br>
      Plays the sample a single time. This is the default if you don't set 
      the loop flag.
   <li>
   PLAYMODE_LOOP<br>
      Loops repeatedly through the sample, jumping back to the loop start 
      position upon reaching the loop end.
   <li>
   PLAYMODE_FORWARD<br>
      Plays the sample from beginning to end. This is the default if you 
      don't set the backward flag.
   <li>
   PLAYMODE_BACKWARD<br>
      Reverses the direction of the sample. If you combine this with the 
      loop flag, the sample jumps to the loop end position upon reaching the 
      loop start (ie. you do not need to reverse the loop start and end 
      values when you play the sample in reverse).
   <li>
   PLAYMODE_BIDIR<br>
      When used in combination with the loop flag, causes the sample to 
      change direction each time it reaches one of the loop points, so it 
      alternates between playing forwards and in reverse.
   </ul>

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>.</blockquote>
<div class="al-api"><b>int <a name="voice_get_volume">voice_get_volume</a>(int voice);</b></div><br>
   Returns the current volume of the voice, range 0-255.  Otherwise it
   returns -1 if that cannot be determined (because it has finished or
   been preempted by a different sound).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_set_volume" title="Sets the volume of the voice.">voice_set_volume</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_set_volume">voice_set_volume</a>(int voice, int volume);</b></div><br>
   Sets the volume of the voice, range 0-255.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_get_volume" title="Returns the current volume of the voice.">voice_get_volume</a>,
<a class="xref" href="#voice_ramp_volume" title="Starts a volume ramp for a voice.">voice_ramp_volume</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_ramp_volume">voice_ramp_volume</a>(int voice, int time, int endvol);</b></div><br>
   Starts a volume ramp (crescendo or diminuendo) from the current volume to 
   the specified ending volume, lasting for time milliseconds. The volume is
   a value in the range 0-255.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_set_volume" title="Sets the volume of the voice.">voice_set_volume</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_stop_volumeramp">voice_stop_volumeramp</a>(int voice);</b></div><br>
   Interrupts a volume ramp operation.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#voice_ramp_volume" title="Starts a volume ramp for a voice.">voice_ramp_volume</a>.</blockquote>
<div class="al-api"><b>int <a name="voice_get_frequency">voice_get_frequency</a>(int voice);</b></div><br>
   Returns the current pitch of the voice, in Hz.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_set_frequency" title="Sets the pitch of the voice.">voice_set_frequency</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_set_frequency">voice_set_frequency</a>(int voice, int frequency);</b></div><br>
   Sets the pitch of the voice, in Hz.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_get_frequency" title="Returns the current pitch of the voice.">voice_get_frequency</a>,
<a class="xref" href="#voice_sweep_frequency" title="Starts a frequency sweep for a voice.">voice_sweep_frequency</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_sweep_frequency">voice_sweep_frequency</a>(int voice, int time, int endfreq);</b></div><br>
   Starts a frequency sweep (glissando) from the current pitch to the 
   specified ending pitch, lasting for time milliseconds.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_set_frequency" title="Sets the pitch of the voice.">voice_set_frequency</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_stop_frequency_sweep">voice_stop_frequency_sweep</a>(int voice);</b></div><br>
   Interrupts a frequency sweep operation.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#voice_sweep_frequency" title="Starts a frequency sweep for a voice.">voice_sweep_frequency</a>.</blockquote>
<div class="al-api"><b>int <a name="voice_get_pan">voice_get_pan</a>(int voice);</b></div><br>
   Returns the current pan position, from 0 (left) to 255 (right).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_set_pan" title="Sets the pan position.">voice_set_pan</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_set_pan">voice_set_pan</a>(int voice, int pan);</b></div><br>
   Sets the pan position, ranging from 0 (left) to 255 (right).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_get_pan" title="Returns the current pan position.">voice_get_pan</a>,
<a class="xref" href="#voice_sweep_pan" title="Starts a pan sweep for a voice.">voice_sweep_pan</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_sweep_pan">voice_sweep_pan</a>(int voice, int time, int endpan);</b></div><br>
   Starts a pan sweep (left &lt;-&gt; right movement) from the current position to
   the specified ending position, lasting for time milliseconds.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>,
<a class="xref" href="#voice_set_pan" title="Sets the pan position.">voice_set_pan</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_stop_pan_sweep">voice_stop_pan_sweep</a>(int voice);</b></div><br>
   Interrupts a pan sweep operation.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#voice_sweep_pan" title="Starts a pan sweep for a voice.">voice_sweep_pan</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_set_echo">voice_set_echo</a>(int voice, int strength, int delay);</b></div><br>
   Sets the echo parameters for a voice (not currently implemented).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_set_tremolo">voice_set_tremolo</a>(int voice, int rate, int depth);</b></div><br>
   Sets the tremolo parameters for a voice (not currently implemented).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>.</blockquote>
<div class="al-api"><b>void <a name="voice_set_vibrato">voice_set_vibrato</a>(int voice, int rate, int depth);</b></div><br>
   Sets the vibrato parameters for a voice (not currently implemented).




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Voice control" title="">Voice control</a>.</blockquote>
<h1><a name="Music routines (MIDI)">Music routines (MIDI)</a></h1>

<p>
Allegro allows you to play MIDI files. MIDI files basically contain notes and
the type of instrument that is meant to play them, so they are usually very
small in size. However, it's up to the sound card of the end user to play the
notes, and sound cards have been historically known to have poor MIDI
performance (at least those oriented to the consumer market). Few consumer
cards feature decent MIDI playback. Still, as a game creator you can never be
sure if the music of your game will be played as you meant it, because it
totally depends on the hardware of the user.

<p>
For this reason Allegro also provides a DIGMID driver. This is a software
implementation of the so called Wavetable synthesis. Sound cards featuring this
store digital samples of real instruments at different pitches, interpolating
those that are not recorded, thus achieving a high sound quality. Implementing
this in software makes you sure that the quality you hear on your computer is
that which will be heard by end users using the same driver.

<p>
The disadvantage of the DIGMID driver is that it uses more CPU than simple
MIDI playback, and it steals some hardware voices from the sound card, which
might be more critical for the end user experience than the background music.
At the Allegro homepage (<a href="http://alleg.sourceforge.net/">http://alleg.sourceforge.net/</a>) you can find more
information about DIGMID and where to download digital samples for your MIDI
files.

<p><br>
<div class="al-api"><b><a class="autotype" href="#MIDI" title="Stores MIDI data.">MIDI</a> *<a name="load_midi">load_midi</a>(const char *filename);</b></div><br>
   Loads a MIDI file (handles both format 0 and format 1). Example:
<blockquote class="code"><pre>
      <a href="#MIDI" class="autotype" title="Stores MIDI data.">MIDI</a> *music;
      music = <a href="#load_midi" class="autotype" title="Loads a MIDI file.">load_midi</a>("backmus.mid");
      if (!music)
         abort_on_error("Couldn't load background music!");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to a MIDI structure, or NULL on error. Remember to free
   this MIDI file later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#destroy_midi" title="Destroys a MIDI structure when you are done with it.">destroy_midi</a>,
<a class="xref" href="#play_midi" title="Starts playing the specified MIDI file.">play_midi</a>,
<a class="xref" href="#get_midi_length" title="Determines the total playing time of a midi, in seconds.">get_midi_length</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_midi">destroy_midi</a>(<a class="autotype" href="#MIDI" title="Stores MIDI data.">MIDI</a> *midi);</b></div><br>
   Destroys a MIDI structure when you are done with it. It is safe to call 
   this even when the MIDI file might be playing, because it checks and will 
   kill it off if it is active. Use this to avoid memory leaks in your
   program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_midi" title="Loads a MIDI file.">load_midi</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>.</blockquote>
<div class="al-api"><b>void <a name="lock_midi">lock_midi</a>(<a class="autotype" href="#MIDI" title="Stores MIDI data.">MIDI</a> *midi);</b></div><br>
   Under DOS, locks all the memory used by a MIDI file. You don't normally 
   need to call this function because load_midi() does it for you.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_midi" title="Loads a MIDI file.">load_midi</a>.</blockquote>
<div class="al-api"><b>int <a name="play_midi">play_midi</a>(<a class="autotype" href="#MIDI" title="Stores MIDI data.">MIDI</a> *midi, int loop);</b></div><br>
   Starts playing the specified MIDI file, first stopping whatever music was 
   previously playing. If the loop flag is set to non-zero, the data will be
   repeated until replaced with something else, otherwise it will stop at the
   end of the file. Passing a NULL pointer will stop whatever music is
   currently playing.
<p><b>Return value:</b>
   Returns non-zero if an error occurs (this may happen if a patch-caching
   wavetable driver is unable to load the required samples, or at least it
   might in the future when somebody writes some patch-caching wavetable
   drivers :-)


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#load_midi" title="Loads a MIDI file.">load_midi</a>,
<a class="xref" href="#play_looped_midi" title="Starts playing a MIDI file with a user-defined loop position.">play_looped_midi</a>,
<a class="xref" href="#stop_midi" title="Stops whatever music is currently playing.">stop_midi</a>,
<a class="xref" href="#midi_pause" title="Pauses the MIDI player.">midi_pause</a>,
<a class="xref" href="#midi_seek" title="Seeks to the given midi_pos in the current MIDI file.">midi_seek</a>,
<a class="xref" href="#midi_pos" title="Stores the current position in the MIDI file.">midi_pos</a>,
<a class="xref" href="#midi_time" title="The current position in the MIDI file, in seconds.">midi_time</a>,
<a class="xref" href="#midi_msg_callback" title="Hook functions allowing you to intercept MIDI player events.">midi_msg_callback</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>.</blockquote>
<div class="al-api"><b>int <a name="play_looped_midi">play_looped_midi</a>(<a class="autotype" href="#MIDI" title="Stores MIDI data.">MIDI</a> *midi, int loop_start, int loop_end);</b></div><br>
   Starts playing a MIDI file with a user-defined loop position. When the 
   player reaches the loop end position or the end of the file (loop_end may 
   be -1 to only loop at EOF), it will wind back to the loop start point. 
   Both positions are specified in the same beat number format as the 
   midi_pos variable.
<p><b>Return value:</b>
   The return value has the same meaning as that of play_midi(): non-zero if
   an error occurs, zero otherwise.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_midi" title="Starts playing the specified MIDI file.">play_midi</a>,
<a class="xref" href="#midi_pos" title="Stores the current position in the MIDI file.">midi_pos</a>,
<a class="xref" href="#midi_loop_start" title="Loop start and end points, set by play_looped_midi().">midi_loop_start</a>.</blockquote>
<div class="al-api"><b>void <a name="stop_midi">stop_midi</a>();</b></div><br>
   Stops whatever music is currently playing. This is the same thing as 
   calling play_midi(NULL, FALSE).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_midi" title="Starts playing the specified MIDI file.">play_midi</a>,
<a class="xref" href="#midi_pause" title="Pauses the MIDI player.">midi_pause</a>.</blockquote>
<div class="al-api"><b>void <a name="midi_pause">midi_pause</a>();</b></div><br>
   Pauses the MIDI player.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_midi" title="Starts playing the specified MIDI file.">play_midi</a>,
<a class="xref" href="#stop_midi" title="Stops whatever music is currently playing.">stop_midi</a>,
<a class="xref" href="#midi_resume" title="Resumes playback of a paused MIDI file.">midi_resume</a>,
<a class="xref" href="#midi_seek" title="Seeks to the given midi_pos in the current MIDI file.">midi_seek</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>.</blockquote>
<div class="al-api"><b>void <a name="midi_resume">midi_resume</a>();</b></div><br>
   Resumes playback of a paused MIDI file.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#midi_pause" title="Pauses the MIDI player.">midi_pause</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>.</blockquote>
<div class="al-api"><b>int <a name="midi_seek">midi_seek</a>(int target);</b></div><br>
   Seeks to the given midi_pos in the current MIDI file. If the target is 
   earlier in the file than the current midi_pos it seeks from the 
   beginning; otherwise it seeks from the current position.
<p><b>Return value:</b>
   Returns zero if it could successfully seek to the requested position.
   Otherwise, a return value of 1 means it stopped playing, and midi_pos is
   set to the negative length of the MIDI file (so you can use this function
   to determine the length of a MIDI file). A return value of 2 means the
   MIDI file looped back to the start.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_midi" title="Starts playing the specified MIDI file.">play_midi</a>,
<a class="xref" href="#midi_pos" title="Stores the current position in the MIDI file.">midi_pos</a>.</blockquote>
<div class="al-api"><b>int <a name="get_midi_length">get_midi_length</a>(<a class="autotype" href="#MIDI" title="Stores MIDI data.">MIDI</a> *midi);</b></div><br>
   This function will simulate playing the given MIDI, from start to end, to
   determine how long it takes to play. After calling this function, midi_pos
   will contain the negative number of beats, and midi_time the length of the
   midi, in seconds.

<p>
   Note that any currently playing midi is stopped when you call this function.
   Usually you would call it before play_midi, to get the length of the midi to
   be played, like in this example:
<blockquote class="code"><pre>
      length = <a href="#get_midi_length" class="autotype" title="Determines the total playing time of a midi, in seconds.">get_midi_length</a>(my_midi);
      <a href="#play_midi" class="autotype" title="Starts playing the specified MIDI file.">play_midi</a>(my_midi);
      do {
         pos = <a href="#midi_time" class="autotype" title="The current position in the MIDI file, in seconds.">midi_time</a>;
         <a href="#textprintf_ex" class="autotype" title="Formatted output of a string.">textprintf_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, 0, 0, c, -1, "%d:%02d / %d:%02d\n",
            pos / 60, pos % 60, length / 60, length % 60);
         <a href="#rest" class="autotype" title="Waits a specified number of milliseconds or yields CPU.">rest</a>(100);
      } while(pos &lt;= length);</pre></blockquote>
<p><b>Return value:</b>
   Returns the value of midi_time, the length of the midi.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_midi" title="Loads a MIDI file.">load_midi</a>,
<a class="xref" href="#midi_time" title="The current position in the MIDI file, in seconds.">midi_time</a>,
<a class="xref" href="#midi_pos" title="Stores the current position in the MIDI file.">midi_pos</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>.</blockquote>
<div class="al-api"><b>void <a name="midi_out">midi_out</a>(unsigned char *data, int length);</b></div><br>
   Streams a block of MIDI commands into the player in real-time, allowing 
   you to trigger notes, jingles, etc, over the top of whatever MIDI file is 
   currently playing.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#load_midi_patches" title="Forces the MIDI driver to load a set of patches.">load_midi_patches</a>,
<a class="xref" href="#midi_recorder" title="Hook notifying you when new MIDI data becomes available.">midi_recorder</a>.</blockquote>
<div class="al-api"><b>int <a name="load_midi_patches">load_midi_patches</a>();</b></div><br>
   Forces the MIDI driver to load the entire set of patches ready for use. 
   You will not normally need to call this, because Allegro automatically 
   loads whatever data is required for the current MIDI file, but you must 
   call it before sending any program change messages via the midi_out() 
   command.
<p><b>Return value:</b>
   Returns non-zero if an error occurred.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#midi_out" title="Streams a block of MIDI commands into the player.">midi_out</a>.</blockquote>
<div class="al-api"><b>extern volatile long <a name="midi_pos">midi_pos</a>;</b></div><br>
   Stores the current position (beat number) in the MIDI file, or contains 
   a negative number if no music is currently playing. Useful for 
   synchronising animations with the music, and for checking whether a MIDI 
   file has finished playing.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_midi" title="Starts playing the specified MIDI file.">play_midi</a>,
<a class="xref" href="#midi_msg_callback" title="Hook functions allowing you to intercept MIDI player events.">midi_msg_callback</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>.</blockquote>
<div class="al-api"><b>extern volatile long <a name="midi_time">midi_time</a>;</b></div><br>
   Contains the position in seconds in the currently playing midi. This is
   useful if you want to display the current song position in seconds, not as
   beat number.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_midi" title="Starts playing the specified MIDI file.">play_midi</a>,
<a class="xref" href="#midi_pos" title="Stores the current position in the MIDI file.">midi_pos</a>,
<a class="xref" href="#get_midi_length" title="Determines the total playing time of a midi, in seconds.">get_midi_length</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>.</blockquote>
<div class="al-api"><b>extern long <a name="midi_loop_start">midi_loop_start</a>;</b></div><br>
<div class="al-api-cont"><b>extern long <a name="midi_loop_end">midi_loop_end</a>;</b></div><br>
   The loop start and end points, set by the play_looped_midi() function. 
   These may safely be altered while the music is playing, but you should be 
   sure they are always set to sensible values (start &lt; end). If you are 
   changing them both at the same time, make sure to alter them in the right 
   order in case a MIDI interrupt happens to occur in between your two 
   writes! Setting these values to -1 represents the start and end of the 
   file respectively.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_looped_midi" title="Starts playing a MIDI file with a user-defined loop position.">play_looped_midi</a>.</blockquote>
<div class="al-api"><b>extern void (*<a name="midi_msg_callback">midi_msg_callback</a>)(int msg, int byte1, int byte2);</b></div><br>
<div class="al-api-cont"><b>extern void (*<a name="midi_meta_callback">midi_meta_callback</a>)(int type, const unsigned char *data, int length);</b></div><br>
<div class="al-api-cont"><b>extern void (*<a name="midi_sysex_callback">midi_sysex_callback</a>)(const unsigned char *data, int length);</b></div><br>
   Hook functions allowing you to intercept MIDI player events. If set to 
   anything other than NULL, these routines will be called for each MIDI 
   message, meta-event, and system exclusive data block respectively. They 
   will execute in an interrupt handler context, so all the code and data 
   they use should be locked, and they must not call any operating system 
   functions. In general you just use these routines to set some flags and 
   respond to them later in your mainline code.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_midi" title="Starts playing the specified MIDI file.">play_midi</a>.</blockquote>
<div class="al-api"><b>int <a name="load_ibk">load_ibk</a>(char *filename, int drums);</b></div><br>
   Reads in a .IBK patch definition file for use by the Adlib driver. If 
   drums is set, it will load it as a percussion patch set, otherwise it 
   will use it as a replacement set of General MIDI instruments. You may 
   call this before or after initialising the sound code, or can simply set 
   the ibk_file and ibk_drum_file variables in the configuration file to 
   have the data loaded automatically. Note that this function has no effect 
   on any drivers other than the Adlib one!
<p><b>Return value:</b>
   Returns non-zero on error.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>.</blockquote>
<h1><a name="Audio stream routines">Audio stream routines</a></h1>

<p>
The audio stream functions are for playing digital sounds that are too big 
to fit in a regular SAMPLE structure, either because they are huge files 
that you want to load in pieces as the data is required, or because you are 
doing something clever like generating the waveform on the fly.

<p>
You can think of an AUDIOSTREAM structure as a wrapper around two audio
buffers. The first thing you do is fill both buffers with sound data and let
Allegro play them. Once the first buffer has been played, the second starts,
and Allegro lets you know you have to fill the other one (i.e. graphics
double buffering applied to sounds too big to fit into memory).

<p>
The implementation of the sound buffers uses normal SAMPLE structures, so you
can use all the voice_*() functions to modify the audio streams. Read chapter
"Digital sample routines", section "Voice control" for a list of additional
functions you can use. Read chapter "Structures and types defined by Allegro"
for the internals of the AUDIOSTREAM structure.

<p><br>
<div class="al-api"><b><a class="autotype" href="#AUDIOSTREAM" title="Stores an audiostream.">AUDIOSTREAM</a> *<a name="play_audio_stream">play_audio_stream</a>(int len, int bits, int stereo,
                               int freq, int vol, int pan);</b></div><br>
   This function creates a new audio stream and starts playing it. The 
   length is the size of each transfer buffer in sample frames (not bytes), 
   where a sample frame is a single sample value for mono data or a pair of 
   interleaved sample values (left first) for stereo data. The length should 
   normally be (but doesn't have to be) a power of 2 somewhere around 1k in 
   size. Larger buffers are more efficient and require fewer updates, but 
   result in more latency between you providing the data and it actually 
   being played.

<p>
   The <tt>`bits'</tt> parameter must be 8 or 16. <tt>`freq'</tt> is the sample rate of the
   data in Hertz. The <tt>`vol'</tt> and <tt>`pan'</tt> values use the same 0-255 ranges as the
   regular sample playing functions. The <tt>`stereo'</tt> parameter should be set to
   1 for stereo streams, or 0 otherwise.

<p>
   If you want to adjust the pitch, volume, or panning of a stream once it is
   playing, you can use the regular voice_*() functions with stream-&gt;voice
   as a parameter. The format of the sample data is described in the SAMPLE
   entry of the "Structures and types defined by Allegro" chapter. The formula
   to get the size of the buffers in bytes could be:
<blockquote class="code"><pre>
      bytes = length * (bits / 8) * (stereo ? 2 : 1)</pre></blockquote>
   Example:
<blockquote class="code"><pre>
      /* Create a 22KHz 8bit mono audio stream. */
      stream = <a href="#play_audio_stream" class="autotype" title="Creates a new audio stream and starts playing it.">play_audio_stream</a>(1024, 8, FALSE, 22050, 255, 128);
      if (!stream)
         abort_on_error("Error creating audio stream!\n");</pre></blockquote>
<p><b>Return value:</b>
   This function returns a pointer to the audio stream or NULL if it could
   not be created.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#get_audio_stream_buffer" title="Tells you if you need to fill the audiostream or not.">get_audio_stream_buffer</a>,
<a class="xref" href="#stop_audio_stream" title="Destroys an audio stream when it is no longer required.">stop_audio_stream</a>,
<a class="xref" href="#AUDIOSTREAM" title="Stores an audiostream.">AUDIOSTREAM</a>,
<a class="xref" href="#Voice control" title="">Voice control</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstream" title="Playing audio streams.">exstream</a>.</blockquote>
<div class="al-api"><b>void <a name="stop_audio_stream">stop_audio_stream</a>(<a class="autotype" href="#AUDIOSTREAM" title="Stores an audiostream.">AUDIOSTREAM</a> *stream);</b></div><br>
   Destroys an audio stream when it is no longer required.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_audio_stream" title="Creates a new audio stream and starts playing it.">play_audio_stream</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstream" title="Playing audio streams.">exstream</a>.</blockquote>
<div class="al-api"><b>void *<a name="get_audio_stream_buffer">get_audio_stream_buffer</a>(<a class="autotype" href="#AUDIOSTREAM" title="Stores an audiostream.">AUDIOSTREAM</a> *stream);</b></div><br>
   You must call this function at regular intervals while an audio stream is 
   playing, to provide the next buffer of sample data (the smaller the 
   stream buffer size, the more often it must be called). This function should
   not be called from a timer handler. Example:
<blockquote class="code"><pre>
      void *mem_chunk;
      ...
      while (TRUE) {
         ...
         mem_chunk = <a href="#get_audio_stream_buffer" class="autotype" title="Tells you if you need to fill the audiostream or not.">get_audio_stream_buffer</a>(buffer);
         if (mem_chunk != NULL) {
            /* Refill the stream buffer. */
         }
      }</pre></blockquote>
<p><b>Return value:</b>
   If it returns NULL, the stream is still playing the previous lot of data,
   so you don't need to do anything. If it returns a value, that is the
   location of the next buffer to be played, and you should load the
   appropriate number of samples (however many you specified when creating the
   stream) to that address, for example using an fread() from a disk file.
   After filling the buffer with data, call free_audio_stream_buffer() to
   indicate that the new data is now valid.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#play_audio_stream" title="Creates a new audio stream and starts playing it.">play_audio_stream</a>,
<a class="xref" href="#free_audio_stream_buffer" title="Tells the audio stream player new data can be played.">free_audio_stream_buffer</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstream" title="Playing audio streams.">exstream</a>.</blockquote>
<div class="al-api"><b>void <a name="free_audio_stream_buffer">free_audio_stream_buffer</a>(<a class="autotype" href="#AUDIOSTREAM" title="Stores an audiostream.">AUDIOSTREAM</a> *stream);</b></div><br>
   Call this function after get_audio_stream_buffer() returns a non-NULL 
   address, to indicate that you have loaded a new block of samples to that 
   location and the data is now ready to be played. Example:
<blockquote class="code"><pre>
      mem_chunk = <a href="#get_audio_stream_buffer" class="autotype" title="Tells you if you need to fill the audiostream or not.">get_audio_stream_buffer</a>(buffer);
      if (mem_chunk != NULL) {
         /* Refill the stream buffer. */
         ...
         <a href="#free_audio_stream_buffer" class="autotype" title="Tells the audio stream player new data can be played.">free_audio_stream_buffer</a>(buffer);
      }</pre></blockquote>




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_audio_stream_buffer" title="Tells you if you need to fill the audiostream or not.">get_audio_stream_buffer</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstream" title="Playing audio streams.">exstream</a>.</blockquote>
<h1><a name="Recording routines">Recording routines</a></h1>

<p>
Allegro provides routines to capture sound from the sound card, be it digital
samples or MIDI notes. Ideally this would allow you to create games where
basic speech recognition could be implemented, or voice messages in
multiplayer games over a network. However, many old sound cards are not full
duplex. This means, that the sound device can only be playing or recording,
but not both at the same time.

<p>
Any Windows 2000 or better machine comes with a full duplex sound card and
updated drivers. All MacOS X machines allow full duplex recording. Under Unix
your mileage may vary: you can have the right hardware for the task, but the
drivers might not support this feature. Under DOS you should forget about full
duplex altogether.

<p>
To find out if your system allows this feature, use the akaitest program,
distributed along with Allegro, in the <tt>`tests'</tt> directory.

<p><br>
<div class="al-api"><b>int <a name="install_sound_input">install_sound_input</a>(int digi, int midi);</b></div><br>
   Initialises the sound recorder module. You must install the normal sound
   playback system before calling this routine. The two card parameters should
   use the same constants as install_sound(), including DIGI_NONE and
   MIDI_NONE to disable parts of the module, or DIGI_AUTODETECT and
   MIDI_AUTODETECT to guess the hardware.
<p><b>Return value:</b>
   This function returns zero on success, and any other value if the machine
   or driver doesn't support sound recording.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#start_sound_input" title="Starts recording in the specified format.">start_sound_input</a>,
<a class="xref" href="#midi_recorder" title="Hook notifying you when new MIDI data becomes available.">midi_recorder</a>,
<a class="xref" href="#Standard config variables" title="">Standard config variables</a>,
<a class="xref" href="#DIGI_*/DOS" title="Supported DOS digital sound drivers.">DIGI_*/DOS</a>,
<a class="xref" href="#DIGI_*/Windows" title="Supported Windows digital sound drivers.">DIGI_*/Windows</a>,
<a class="xref" href="#DIGI_*/Unix" title="Supported Unix digital sound drivers.">DIGI_*/Unix</a>,
<a class="xref" href="#DIGI_*/BeOS" title="Supported BeOS digital sound drivers.">DIGI_*/BeOS</a>,
<a class="xref" href="#DIGI_*/QNX" title="Supported QNX digital sound drivers.">DIGI_*/QNX</a>,
<a class="xref" href="#DIGI_*/MacOSX" title="Supported MacOSX digital sound drivers.">DIGI_*/MacOSX</a>,
<a class="xref" href="#MIDI_*/DOS" title="Supported DOS MIDI sound drivers.">MIDI_*/DOS</a>,
<a class="xref" href="#MIDI_*/Windows" title="Supported Windows MIDI sound drivers.">MIDI_*/Windows</a>,
<a class="xref" href="#MIDI_*/Unix" title="Supported Unix MIDI sound drivers.">MIDI_*/Unix</a>,
<a class="xref" href="#MIDI_*/BeOS" title="Supported BeOS MIDI sound drivers.">MIDI_*/BeOS</a>,
<a class="xref" href="#MIDI_*/QNX" title="Supported QNX MIDI sound drivers.">MIDI_*/QNX</a>,
<a class="xref" href="#MIDI_*/MacOSX" title="Supported MacOSX MIDI sound drivers.">MIDI_*/MacOSX</a>.</blockquote>
<div class="al-api"><b>void <a name="remove_sound_input">remove_sound_input</a>();</b></div><br>
   Cleans up after you are finished with the sound input routines. You don't 
   normally need to call this, because remove_sound() and/or allegro_exit() 
   will do it for you.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>,
<a class="xref" href="#remove_sound" title="Cleans up after you are finished with the sound routines.">remove_sound</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>.</blockquote>
<div class="al-api"><b>int <a name="get_sound_input_cap_bits">get_sound_input_cap_bits</a>();</b></div><br>
   Checks which sample formats are supported by the current audio input 
   driver, returning one of the bitfield values:
<blockquote class="text"><pre>
      0 = audio input not supported
      8 = eight bit audio input is supported
      16 = sixteen bit audio input is supported
      24 = both eight and sixteen bit audio input are supported</pre></blockquote>
   Example:
<blockquote class="code"><pre>
      cap = <a href="#get_sound_input_cap_bits" class="autotype" title="Checks which audio input sample formats are supported.">get_sound_input_cap_bits</a>();
      if (cap == 0) {
         /* Ugh, no audio input supported? */
      } else {
         if (cap &amp; 8) {
            /* We have eight bit audio input. */
         }
         if (cap &amp; 16) {
            /* We have sixteen bit audio input. */
         }
      }</pre></blockquote>
      

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#start_sound_input" title="Starts recording in the specified format.">start_sound_input</a>,
<a class="xref" href="#get_sound_input_cap_parm" title="Detects if the specified recording parameters are supported.">get_sound_input_cap_parm</a>,
<a class="xref" href="#get_sound_input_cap_rate" title="Returns the maximum sample frequency for recording.">get_sound_input_cap_rate</a>,
<a class="xref" href="#get_sound_input_cap_stereo" title="Tells if the input driver is capable of stereo recording.">get_sound_input_cap_stereo</a>.</blockquote>
<div class="al-api"><b>int <a name="get_sound_input_cap_stereo">get_sound_input_cap_stereo</a>();</b></div><br>
   Checks whether the current audio input driver is capable of stereo 
   recording.
<p><b>Return value:</b>
   Returns non-zero if the driver is capable of stereo recording.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#start_sound_input" title="Starts recording in the specified format.">start_sound_input</a>,
<a class="xref" href="#get_sound_input_cap_parm" title="Detects if the specified recording parameters are supported.">get_sound_input_cap_parm</a>,
<a class="xref" href="#get_sound_input_cap_bits" title="Checks which audio input sample formats are supported.">get_sound_input_cap_bits</a>,
<a class="xref" href="#get_sound_input_cap_rate" title="Returns the maximum sample frequency for recording.">get_sound_input_cap_rate</a>.</blockquote>
<div class="al-api"><b>int <a name="get_sound_input_cap_rate">get_sound_input_cap_rate</a>(int bits, int stereo);</b></div><br>
   Returns the maximum possible sample frequency for recording in the 
   specified format, or zero if these settings are not supported. The bits
   parameter is the number of bits of the audio, and stereo is a boolean
   parameter. Pass zero for mono, non-zero for stereo input. Example:
<blockquote class="code"><pre>
      int max_freq;
      ...
      /* What frequency can we record 8 bits mono at? */
      max_freq = <a href="#get_sound_input_cap_rate" class="autotype" title="Returns the maximum sample frequency for recording.">get_sound_input_cap_rate</a>(8, 0);
      if (max_freq > 22000) {
         /* Ok, 22KHz and above is good enough. */
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#start_sound_input" title="Starts recording in the specified format.">start_sound_input</a>,
<a class="xref" href="#get_sound_input_cap_parm" title="Detects if the specified recording parameters are supported.">get_sound_input_cap_parm</a>,
<a class="xref" href="#get_sound_input_cap_bits" title="Checks which audio input sample formats are supported.">get_sound_input_cap_bits</a>,
<a class="xref" href="#get_sound_input_cap_stereo" title="Tells if the input driver is capable of stereo recording.">get_sound_input_cap_stereo</a>.</blockquote>
<div class="al-api"><b>int <a name="get_sound_input_cap_parm">get_sound_input_cap_parm</a>(int rate, int bits, int stereo);</b></div><br>
   Checks whether the specified recording frequency, number of bits, and 
   mono/stereo mode are supported (and how) by the current audio driver.
<p><b>Return value:</b>
   The function returns one of the following possible values:
<blockquote class="text"><pre>
      0  = It is impossible to record in this format.
      1  = Recording is possible, but audio output
           will be suspended.
      2  = Recording is possible at the same time as
           playing other sounds (full duplex sound card).
      -n = Sampling rate not supported, but rate 'n'
           would work instead.</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#start_sound_input" title="Starts recording in the specified format.">start_sound_input</a>,
<a class="xref" href="#get_sound_input_cap_bits" title="Checks which audio input sample formats are supported.">get_sound_input_cap_bits</a>,
<a class="xref" href="#get_sound_input_cap_rate" title="Returns the maximum sample frequency for recording.">get_sound_input_cap_rate</a>,
<a class="xref" href="#get_sound_input_cap_stereo" title="Tells if the input driver is capable of stereo recording.">get_sound_input_cap_stereo</a>.</blockquote>
<div class="al-api"><b>int <a name="set_sound_input_source">set_sound_input_source</a>(int source);</b></div><br>
   Selects the audio input source. The parameter should be one of the values:
<blockquote class="text"><pre>
      SOUND_INPUT_MIC
      SOUND_INPUT_LINE
      SOUND_INPUT_CD</pre></blockquote>
<p><b>Return value:</b>
   The function returns zero on success, or -1 if the hardware does not
   provide an input select register (ie. you have no control over the input
   source).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#start_sound_input" title="Starts recording in the specified format.">start_sound_input</a>.</blockquote>
<div class="al-api"><b>int <a name="start_sound_input">start_sound_input</a>(int rate, int bits, int stereo);</b></div><br>
   Starts recording in the specified format, suspending audio playback as 
   necessary if the card is not full duplex.
<p><b>Return value:</b>
   Returns the buffer size in bytes if successful, or zero on error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>,
<a class="xref" href="#read_sound_input" title="Retrieves the last recorded audio buffer.">read_sound_input</a>,
<a class="xref" href="#stop_sound_input" title="Stops audio recording.">stop_sound_input</a>,
<a class="xref" href="#digi_recorder" title="Hook notifying you when a new sample buffer becomes available.">digi_recorder</a>,
<a class="xref" href="#set_sound_input_source" title="Selects the audio input source.">set_sound_input_source</a>,
<a class="xref" href="#get_sound_input_cap_parm" title="Detects if the specified recording parameters are supported.">get_sound_input_cap_parm</a>,
<a class="xref" href="#get_sound_input_cap_bits" title="Checks which audio input sample formats are supported.">get_sound_input_cap_bits</a>,
<a class="xref" href="#get_sound_input_cap_rate" title="Returns the maximum sample frequency for recording.">get_sound_input_cap_rate</a>,
<a class="xref" href="#get_sound_input_cap_stereo" title="Tells if the input driver is capable of stereo recording.">get_sound_input_cap_stereo</a>.</blockquote>
<div class="al-api"><b>void <a name="stop_sound_input">stop_sound_input</a>();</b></div><br>
   Stops audio recording, switching the card back into the normal playback 
   mode.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#start_sound_input" title="Starts recording in the specified format.">start_sound_input</a>.</blockquote>
<div class="al-api"><b>int <a name="read_sound_input">read_sound_input</a>(void *buffer);</b></div><br>
   Retrieves the most recently recorded audio buffer into the specified 
   location. The buffer size can be obtained by checking the return value
   from start_sound_input(). You must be sure to call this
   function at regular intervals during the recording (typically around 100 
   times a second), or some data will be lost. If you are unable to do this 
   often enough from the mainline code, use the digi_recorder() callback to 
   store the waveform into a larger buffer of your own.

<p>
   Note: many cards produce a click or popping sound when switching between
   record and playback modes, so it is often a good idea to discard the
   first buffer after you start a recording. The waveform is always stored
   in unsigned format, with stereo data consisting of alternate left/right
   samples.
<p><b>Return value:</b>
   The function will return non-zero if a buffer has been copied or zero if
   no new data is yet available (you were too fast checking the input).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#start_sound_input" title="Starts recording in the specified format.">start_sound_input</a>.</blockquote>
<div class="al-api"><b>extern void (*<a name="digi_recorder">digi_recorder</a>)();</b></div><br>
   If set, this function is called by the input driver whenever a new sample 
   buffer becomes available, at which point you can use read_sound_input() 
   to copy the data into a more permanent location. It runs in an interrupt
   context, so it must execute very quickly, the code and all memory that it
   touches must be locked, and you cannot call any operating system routines
   or access disk files. This currently works only under DOS.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>,
<a class="xref" href="#start_sound_input" title="Starts recording in the specified format.">start_sound_input</a>.</blockquote>
<div class="al-api"><b>extern void (*<a name="midi_recorder">midi_recorder</a>)(unsigned char data);</b></div><br>
   If set, this function is called by the MIDI input driver whenever a new 
   byte of MIDI data becomes available. It runs in an interrupt context, so 
   it must execute very quickly and all the code/data must be locked. This
   currently works only under DOS and Windows.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>,
<a class="xref" href="#midi_out" title="Streams a block of MIDI commands into the player.">midi_out</a>.</blockquote>
<h1><a name="File and compression routines">File and compression routines</a></h1>

<p>
The following routines implement a fast buffered file I/O system, which 
supports the reading and writing of compressed files using a ring buffer 
algorithm based on the LZSS compressor by Haruhiko Okumura. This does not 
achieve quite such good compression as programs like zip and lha, but 
unpacking is very fast and it does not require much memory. Packed files 
always begin with the 32-bit value F_PACK_MAGIC, and autodetect files with 
the value F_NOPACK_MAGIC.

<p>
The following FA_* flags are guaranteed to work:
<blockquote class="text"><pre>
      FA_NONE           - Exclude files that have any attribute set
      FA_RDONLY         - Directory entries that are unwritable for current user
      FA_HIDDEN         - Hidden flag
      FA_DIREC          - Directories
      FA_SYSTEM         - Files with system flag set (DOS/Windows only)
      FA_LABEL          - Files with volume label flag set (DOS/Windows only)
      FA_ARCH           - Files with archive flag set (DOS/Windows only)
      FA_ALL            - Match all attributes</pre></blockquote>
Do not use any other flags from DOS/Windows or your code will not compile on 
another platform.
FA_RDONLY is for directory entries with read-only flag on DOS-like systems or 
unwritable by current user on Unix-like systems. Hidden files are directory
entries that have the hidden flag set (DOS/Windows) or have names starting with
'.' (UNIX, excluding '.' and '..').
Flags can be combined using '|' (binary OR operator).

<p>
When passed to the functions as the 'attrib' parameter, these flags 
represent an upper set in which the actual flag set of a matching file must 
be included. That is, in order for a file to be matching, its attributes 
may contain any of the specified flags but must not contain any of the 
unspecified flags. In other words, you explicitly <i>exclude</i> the flags that you
do <i>not</i> specify. Thus if you pass 'FA_DIREC | FA_RDONLY', normal files 
and directories will be included as well as read-only files and 
directories, but not hidden files and directories. Similarly, if you pass 
'FA_ARCH' then both archived and non-archived files will be included. If
FA_NONE is passed all attributes are excluded and only files with no attributes
are returned. Conversely, if you pass FA_ALL, no attributes are excluded so all
files are returned (which is what you would usually want).

<p>
Functions which accept wildcards as file names support the meta characters
`*' (which means, zero or any quantity of characters) and <tt>`?'</tt> (which means
any character, but only one).

<p><br>
<div class="al-api"><b>void <a name="get_executable_name">get_executable_name</a>(char *buf, int size);</b></div><br>
   Fills <tt>`buf'</tt> with the full path to the current executable, writing at most
   <tt>`size'</tt> bytes.  This generally comes from <tt>`argv[0]'</tt> but on Unix systems it
   tries to get the information from the <tt>`/proc'</tt> filesystem first, searching
   the directories specified in `$PATH' if necessary. If this fails too, it
   tries to find the executable name from the output of the <tt>`ps'</tt> command,
   using <tt>`argv[0]'</tt> only as a last resort if all other options fail. Example:
<blockquote class="code"><pre>
      char name[200];
      ...
      <a href="#get_executable_name" class="autotype" title="Obtains the full path to the current executable.">get_executable_name</a>(name, sizeof(name));
      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("Running `%s'\n", name);</pre></blockquote>

<p><br>
<div class="al-api"><b>char *<a name="fix_filename_case">fix_filename_case</a>(char *path);</b></div><br>
   Converts the filename stored in <tt>`path'</tt> to a standardised case. On DOS
   platforms, they will be entirely uppercase. On other platforms this
   function doesn't do anything. Example:
<blockquote class="code"><pre>
      <a href="#get_executable_name" class="autotype" title="Obtains the full path to the current executable.">get_executable_name</a>(name, sizeof(name));
      <a href="#fix_filename_case" class="autotype" title="Converts a filename to a standardised case.">fix_filename_case</a>(name);
      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("Running `%s'\n", name);</pre></blockquote>
<p><b>Return value:</b>
   Returns a copy of the <tt>`path'</tt> parameter.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fix_filename_slashes" title="Converts all the directory separators to a standard character.">fix_filename_slashes</a>,
<a class="xref" href="#canonicalize_filename" title="Converts any filename into its canonical form.">canonicalize_filename</a>.</blockquote>
<div class="al-api"><b>char *<a name="fix_filename_slashes">fix_filename_slashes</a>(char *path);</b></div><br>
   Converts all the directory separators in the filename stored in <tt>`path'</tt> to
   a standard character. On DOS and Windows platforms, this is a backslash.
   On most other platforms this is a slash. Example:
<blockquote class="code"><pre>
      char buf[200] = "c:/dos\\backup/weirdo\\test";
      ...
      <a href="#fix_filename_slashes" class="autotype" title="Converts all the directory separators to a standard character.">fix_filename_slashes</a>(buf);
      /* Under DOS we would have c:\dos\backup\weirdo\test.
         Under Unix we would have c:/dos/backup/weirdo/test. */</pre></blockquote>
<p><b>Return value:</b>
   Returns a copy of the <tt>`path'</tt> parameter.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fix_filename_case" title="Converts a filename to a standardised case.">fix_filename_case</a>,
<a class="xref" href="#canonicalize_filename" title="Converts any filename into its canonical form.">canonicalize_filename</a>.</blockquote>
<div class="al-api"><b>char *<a name="canonicalize_filename">canonicalize_filename</a>(char *dest, const char *filename, int size);</b></div><br>
   Converts any filename into its canonical form, i.e. the minimal absolute
   filename describing the same file and fixing incorrect forward/backward
   slashes for the current platform, storing at most <tt>`size'</tt> bytes into the
   <tt>`dest'</tt> buffer. You can use the same buffer both as input and output
   because Allegro internally works on a copy of the input before touching
   <tt>`dest'</tt>. Example:
<blockquote class="code"><pre>
      char buf[256];
      ...
      <a href="#canonicalize_filename" class="autotype" title="Converts any filename into its canonical form.">canonicalize_filename</a>(buf, "~/../s22/..\\t3st///hi.c",
                            sizeof(buf));
      /* Running this under Unix would
         return: /home/t3st/hi.c */
</pre></blockquote>
   Note that this function won't work as expected if the path to canonicalize
   comes from another platform (eg. a "c:\something" path will canonicalize
   into something really wrong under Unix: "/current/path/c:/something").
<p><b>Return value:</b>
   Returns a copy of the <tt>`dest'</tt> parameter.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fix_filename_case" title="Converts a filename to a standardised case.">fix_filename_case</a>,
<a class="xref" href="#fix_filename_slashes" title="Converts all the directory separators to a standard character.">fix_filename_slashes</a>.</blockquote>
<div class="al-api"><b>char *<a name="make_absolute_filename">make_absolute_filename</a>(char *dest, const char *path, const char *filename, int size);</b></div><br>
   Makes an absolute filename from an absolute path and a relative filename,
   storing at most <tt>`size'</tt> bytes into the <tt>`dest'</tt> buffer. This is like calling
   replace_filename() and then canonicalize_filename(). Example:
<blockquote class="code"><pre>
      char buf[256];
      ...
      <a href="#make_absolute_filename" class="autotype" title="Makes an absolute filename from a path and relative filename.">make_absolute_filename</a>(buf, "/usr/games/",
                             "../temp.txt", sizeof(buf));
      /* This would create /usr/temp.txt */</pre></blockquote>
<p><b>Return value:</b>
   Returns a copy of the <tt>`dest'</tt> parameter.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#make_relative_filename" title="Tries to make a relative filename from absolute path and filename.">make_relative_filename</a>,
<a class="xref" href="#is_relative_filename" title="Returns TRUE if the filename is relative.">is_relative_filename</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#canonicalize_filename" title="Converts any filename into its canonical form.">canonicalize_filename</a>.</blockquote>
<div class="al-api"><b>char *<a name="make_relative_filename">make_relative_filename</a>(char *dest, const char *path, const char *filename, int size);</b></div><br>
   Attempts to make a relative filename from an absolute path and an absolute
   filename, storing at most <tt>`size'</tt> bytes into the <tt>`dest'</tt> buffer. This
   function won't work if the paths are not canonical under the current
   platform (see canonicalize_filename()). Also, <tt>`dest'</tt> cannot be used as
   input value for <tt>`path'</tt> or <tt>`filename'</tt>. Example:
<blockquote class="code"><pre>
      char base[] = "/long/absolute/path/program.exe";
      char user_input[] = "/nice/and/short.txt";
      ...
      <a href="#make_relative_filename" class="autotype" title="Tries to make a relative filename from absolute path and filename.">make_relative_filename</a>(buf, base, user_input, sizeof(buf));
      /* Under Unix buf would contain:
         ../../../nice/and/short.txt */</pre></blockquote>
<p><b>Return value:</b>
   Returns a copy of the <tt>`dest'</tt> parameter if it succeeds or NULL if it fails
   (eg. under DOS, one path starts with "C:\" and another with "A:\").


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#make_absolute_filename" title="Makes an absolute filename from a path and relative filename.">make_absolute_filename</a>,
<a class="xref" href="#is_relative_filename" title="Returns TRUE if the filename is relative.">is_relative_filename</a>,
<a class="xref" href="#canonicalize_filename" title="Converts any filename into its canonical form.">canonicalize_filename</a>.</blockquote>
<div class="al-api"><b>int <a name="is_relative_filename">is_relative_filename</a>(const char *filename);</b></div><br>
   Returns TRUE if the filename is relative or FALSE if it is absolute. Note
   that an absolute filename under DOS (with a device separator) will be
   considered as relative under Unix, because there absolute paths always
   start with a slash.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#make_absolute_filename" title="Makes an absolute filename from a path and relative filename.">make_absolute_filename</a>,
<a class="xref" href="#make_relative_filename" title="Tries to make a relative filename from absolute path and filename.">make_relative_filename</a>.</blockquote>
<div class="al-api"><b>char *<a name="replace_filename">replace_filename</a>(char *dest, const char *path, 
                       const char *filename, int size);</b></div><br>
   Replaces the specified path+filename with a new filename tail, storing 
   at most <tt>`size'</tt> bytes into the <tt>`dest'</tt> buffer. You can use the same buffer
   both as input and output because Allegro internally works on a copy of
   the input before touching <tt>`dest'</tt>. Example:
<blockquote class="code"><pre>
      char name[200];
      ...
      <a href="#get_executable_name" class="autotype" title="Obtains the full path to the current executable.">get_executable_name</a>(name, sizeof(name));
      <a href="#replace_filename" class="autotype" title="Replaces path+filename with a new filename tail.">replace_filename</a>(name, name, "sound.dat", sizeof(name));</pre></blockquote>
<p><b>Return value:</b>
   Returns a copy of the <tt>`dest'</tt> parameter.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_filename" title="Returns a pointer to the filename portion of a path.">get_filename</a>,
<a class="xref" href="#replace_extension" title="Replaces filename+extension with a new extension tail.">replace_extension</a>,
<a class="xref" href="#append_filename" title="Concatenates a filename to a path.">append_filename</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>char *<a name="replace_extension">replace_extension</a>(char *dest, const char *filename, 
                        const char *ext, int size);</b></div><br>
   Replaces the specified filename+extension with a new extension tail,
   storing at most <tt>`size'</tt> bytes into the <tt>`dest'</tt> buffer. If the filename
   doesn't have any extension at all, <tt>`ext'</tt> will be appended to it, adding
   a dot character if needed. You can use the same buffer both as input and
   output because Allegro internally works on a copy of the input before
   touching <tt>`dest'</tt>. Example:
<blockquote class="code"><pre>
      <a href="#replace_extension" class="autotype" title="Replaces filename+extension with a new extension tail.">replace_extension</a>(buf, "C:\\game\\prog.exe",
                        "dat", sizeof(buf));</pre></blockquote>
<p><b>Return value:</b>
   Returns a copy of the <tt>`dest'</tt> parameter.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_extension" title="Returns a pointer to the extension of a filename.">get_extension</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>.</blockquote>
<div class="al-api"><b>char *<a name="append_filename">append_filename</a>(char *dest, const char *path, 
                      const char *filename, int size);</b></div><br>
   Concatenates the specified filename onto the end of the specified path, 
   storing at most <tt>`size'</tt> bytes into the <tt>`dest'</tt> buffer. If <tt>`path'</tt> doesn't
   have a trailing path separator, the function will append one if needed.
   You can use the same buffer both as input and output because Allegro
   internally works on a copy of the input before touching <tt>`dest'</tt>. Example:
<blockquote class="code"><pre>
      <a href="#append_filename" class="autotype" title="Concatenates a filename to a path.">append_filename</a>(buf, "/home/user",
                      "prog.bin", sizeof(buf));</pre></blockquote>
<p><b>Return value:</b>
   Returns a copy of the <tt>`dest'</tt> parameter.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>.</blockquote>
<div class="al-api"><b>char *<a name="get_filename">get_filename</a>(const char *path);</b></div><br>
   Finds out the filename portion of a completely specified file path. Both
   <tt>`\'</tt> and <tt>`/'</tt> are recognized as directory separators under DOS and Windows.
   However, only <tt>`/'</tt> is recognized as directory separator under other
   platforms. Example:
<blockquote class="code"><pre>
      <a href="#get_executable_name" class="autotype" title="Obtains the full path to the current executable.">get_executable_name</a>(name, sizeof(name));
      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("Running `%s'\n", <a href="#get_filename" class="autotype" title="Returns a pointer to the filename portion of a path.">get_filename</a>(name));
</pre></blockquote>
   Note that Allegro won't perform any IO operations during the verification.
   This means that if you have <tt>`/a/path/like/this/'</tt>, which doesn't have a
   filename, the function will return a pointer to the trailing null
   character. However, if you have <tt>`/a/path/like/this'</tt>, Allegro will return
   a pointer to <tt>`this'</tt>, even if it is a valid directory.
<p><b>Return value:</b>
   Returns a pointer to the portion of <tt>`path'</tt> where the filename starts, or
   the beginning of <tt>`path'</tt> if no valid filename is found (eg. you are
   processing a path with backslashes under Unix).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_extension" title="Returns a pointer to the extension of a filename.">get_extension</a>,
<a class="xref" href="#put_backslash" title="Puts a path separator at the end of a path if needed.">put_backslash</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exmidi" title="Playing MIDI music.">exmidi</a>.</blockquote>
<div class="al-api"><b>char *<a name="get_extension">get_extension</a>(const char *filename);</b></div><br>
   Finds out the extension of the filename (with or without path
   information). Example:
<blockquote class="code"><pre>
      <a href="#get_executable_name" class="autotype" title="Obtains the full path to the current executable.">get_executable_name</a>(name, sizeof(name));
      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("The binary has the extension `%s'\n",
                      <a href="#get_extension" class="autotype" title="Returns a pointer to the extension of a filename.">get_extension</a>(name));</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the portion of <tt>`filename'</tt> where the extension starts,
   or a pointer to the trailing null character if there is no filename or it
   doesn't have extension.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_filename" title="Returns a pointer to the filename portion of a path.">get_filename</a>,
<a class="xref" href="#put_backslash" title="Puts a path separator at the end of a path if needed.">put_backslash</a>,
<a class="xref" href="#replace_extension" title="Replaces filename+extension with a new extension tail.">replace_extension</a>.</blockquote>
<div class="al-api"><b>void <a name="put_backslash">put_backslash</a>(char *filename);</b></div><br>
   If the last character of the filename is not a <tt>`\'</tt>, <tt>`/'</tt>, `#' or a device
   separator (ie. <tt>`:'</tt> under DOS), this routine will concatenate either a <tt>`\'</tt>
   or <tt>`/'</tt> on to it (depending on the platform). Note: ignore the function
   name, it's out of date.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_extension" title="Returns a pointer to the extension of a filename.">get_extension</a>,
<a class="xref" href="#get_filename" title="Returns a pointer to the filename portion of a path.">get_filename</a>.</blockquote>
<div class="al-api"><b>int <a name="file_exists">file_exists</a>(const char *filename, int attrib, int *aret);</b></div><br>
   Checks whether a file matching the given name and attributes (see
   beginning of this chapter) exists. If <tt>`aret'</tt> is not NULL, it will be set
   to the attributes of the matching file. Example:
<blockquote class="code"><pre>
      /* Check for a normal file. */
      if (<a href="#file_exists" class="autotype" title="Tells if a file exists.">file_exists</a>("franken.dat", 0, NULL))
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("It is alive!\n");</pre></blockquote>
<p><b>Return value:</b>
   Returns non-zero if the file exists, or zero if it doesn't or the
   specified attributes mask it out.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#exists" title="Shortcut version of file_exists() for normal files.">exists</a>,
<a class="xref" href="#file_size_ex" title="Returns the size of a file in bytes.">file_size_ex</a>,
<a class="xref" href="#file_time" title="Returns the modification time of a file.">file_time</a>.</blockquote>
<div class="al-api"><b>int <a name="exists">exists</a>(const char *filename);</b></div><br>
   Shortcut version of file_exists(), which checks for normal files, which 
   may have the archive or read-only bits set, but are not hidden, 
   directories, system files, etc.
<p><b>Return value:</b>
   Returns non-zero if the file exists, or zero if it doesn't.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#file_exists" title="Tells if a file exists.">file_exists</a>,
<a class="xref" href="#file_size_ex" title="Returns the size of a file in bytes.">file_size_ex</a>,
<a class="xref" href="#file_time" title="Returns the modification time of a file.">file_time</a>.</blockquote>
<div class="al-api"><b>uint64_t <a name="file_size_ex">file_size_ex</a>(const char *filename);</b></div><br>
   Returns the size of a file, in bytes. If the file does not exist or an 
   error occurs, it will return zero and store the system error code in 
   errno.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#file_exists" title="Tells if a file exists.">file_exists</a>,
<a class="xref" href="#file_time" title="Returns the modification time of a file.">file_time</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>time_t <a name="file_time">file_time</a>(const char *filename);</b></div><br>
   Returns the modification time (number of seconds since 00:00:00 GMT 
   1/1/1970) of a file. If the file does not exist or an error occurs, it 
   will return zero and store the system error code in errno.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#file_exists" title="Tells if a file exists.">file_exists</a>,
<a class="xref" href="#file_size_ex" title="Returns the size of a file in bytes.">file_size_ex</a>.</blockquote>
<div class="al-api"><b>int <a name="delete_file">delete_file</a>(const char *filename);</b></div><br>
   Removes a file from the disk. You can't delete directories, though.
<p><b>Return value:</b>
   Returns zero on success, non-zero on failure.

<p><br>
<div class="al-api"><b>int <a name="for_each_file_ex">for_each_file_ex</a>(const char *name, int in_attrib, int out_attrib,
                     int (*callback)(const char *filename, int attrib,
                     void *param), void *param);</b></div><br>
   Finds all the files on disk which match the given wildcard specification
   and file attributes, and executes callback() once for each. Basically, this
   is a convenient wrapper around al_findfirst(), al_findnext() and
   al_findclose(). <tt>`in_attrib'</tt> is a bitmask specifying the attributes the
   files must carry, <tt>`out_attrib'</tt> is a bitmask specifying the attributes the
   files must not carry; attributes which are not specified in either bitmasks
   are not taken into account for deciding whether callback() is invoked or
   not.

<p>
   The callback function will be passed three arguments: the first is a string
   which contains the completed filename (exactly the same string you passed
   to for_each_file_ex() but with meta characters), the second is the actual
   attributes of the file, and the third is a void pointer which is simply a
   copy of <tt>`param'</tt> (you can use this for whatever you like). The callback must
   return zero to let the enumeration proceed, or any non-zero value to stop
   it. If an error occurs, the error code will be stored in <tt>`errno'</tt> but the
   enumeration won't stop. Example:
<blockquote class="code"><pre>
      int show_name(const char *filename, int attrib, void *param)
      {
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("Caught `%s', attribs %d\n",
                         filename, attrib);
         return 0;
      }
      ...
         count = <a href="#for_each_file_ex" class="autotype" title="Executes callback() for each file matching a wildcard.">for_each_file_ex</a>("data/level*", FA_DIREC,
                                  0, show_name, 0);
         <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("%d game directories\n", count);</pre></blockquote>
<p><b>Return value:</b>
   Returns the number of successful calls made to callback(), that is, the
   number of times callback() was called and returned 0.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#al_findfirst" title="Low-level function for searching files.">al_findfirst</a>,
<a class="xref" href="#al_findnext" title="Finds the next file in a search started by al_findfirst().">al_findnext</a>,
<a class="xref" href="#al_findclose" title="Closes a previously opened search with al_findfirst().">al_findclose</a>.</blockquote>
<div class="al-api"><b>int <a name="al_findfirst">al_findfirst</a>(const char *pattern, struct <a class="autotype" href="#al_ffblk" title="Cross platform structure storing file information.">al_ffblk</a> *info, int attrib);</b></div><br>
   Low-level function for searching files. This function finds the first 
   file which matches the given wildcard specification and file attributes 
   (see above). The information about the file (if any) will be put in the 
   al_ffblk structure which you have to provide. The al_ffblk structure 
   looks like:
<blockquote class="code"><pre>
      struct <a href="#al_ffblk" class="autotype" title="Cross platform structure storing file information.">al_ffblk</a>
      {
         int attrib;       - actual attributes of the file found
         time_t time;      - modification time of file
         char name[512];   - name of file
      };
</pre></blockquote>
   There is some other stuff in the structure as well, but it is there for 
   internal use only. Example:
<blockquote class="code"><pre>
      struct <a href="#al_ffblk" class="autotype" title="Cross platform structure storing file information.">al_ffblk</a> info;

      if (<a href="#al_findfirst" class="autotype" title="Low-level function for searching files.">al_findfirst</a>("*.pcx", &amp;info, FA_ALL) != 0) {
         /* Tell user there are no PCX files. */
         return;
      }</pre></blockquote>
<p><b>Return value:</b>
   The function returns non-zero if no match is found or if an error occurred
   and, in the latter case, sets <tt>`errno'</tt> accordingly. It returns zero if a
   match is found, allocating some memory for internal use in the structure.
   Therefore you have to close your search when you are finished to avoid
   memory leaks in your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#al_findnext" title="Finds the next file in a search started by al_findfirst().">al_findnext</a>,
<a class="xref" href="#al_findclose" title="Closes a previously opened search with al_findfirst().">al_findclose</a>,
<a class="xref" href="#al_ffblk_get_size" title="Get size of file returned by al_findfirst/al_findnext.">al_ffblk_get_size</a>.</blockquote>
<div class="al-api"><b>int <a name="al_findnext">al_findnext</a>(struct <a class="autotype" href="#al_ffblk" title="Cross platform structure storing file information.">al_ffblk</a> *info);</b></div><br>
   This finds the next file in a search started by al_findfirst(). Example:
<blockquote class="code"><pre>
      if (<a href="#al_findfirst" class="autotype" title="Low-level function for searching files.">al_findfirst</a>("*.pcx", &amp;info, 0) != 0)
         return;

      do {
         /* Do something useful here with info.name. */
      } while (<a href="#al_findnext" class="autotype" title="Finds the next file in a search started by al_findfirst().">al_findnext</a>(&amp;info) == 0);

      <a href="#al_findclose" class="autotype" title="Closes a previously opened search with al_findfirst().">al_findclose</a>(&amp;info);</pre></blockquote>
<p><b>Return value:</b>
   Returns zero if a match is found, non-zero if none is found or if an
   error occurred and, in the latter case, sets errno accordingly.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#al_findfirst" title="Low-level function for searching files.">al_findfirst</a>,
<a class="xref" href="#al_findclose" title="Closes a previously opened search with al_findfirst().">al_findclose</a>.</blockquote>
<div class="al-api"><b>void <a name="al_findclose">al_findclose</a>(struct <a class="autotype" href="#al_ffblk" title="Cross platform structure storing file information.">al_ffblk</a> *info);</b></div><br>
   This closes a previously opened search with al_findfirst(). You need to
   call this on all successfully opened searches to avoid memory leaks in
   your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#al_findfirst" title="Low-level function for searching files.">al_findfirst</a>,
<a class="xref" href="#al_findnext" title="Finds the next file in a search started by al_findfirst().">al_findnext</a>.</blockquote>
<div class="al-api"><b>uint64_t <a name="al_ffblk_get_size">al_ffblk_get_size</a>(struct <a class="autotype" href="#al_ffblk" title="Cross platform structure storing file information.">al_ffblk</a> *info);</b></div><br>
   This returns the size of the file returned by al_findfirst or al_findnext.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#al_findfirst" title="Low-level function for searching files.">al_findfirst</a>,
<a class="xref" href="#al_findnext" title="Finds the next file in a search started by al_findfirst().">al_findnext</a>,
<a class="xref" href="#al_ffblk" title="Cross platform structure storing file information.">al_ffblk</a>.</blockquote>
<div class="al-api"><b>int <a name="find_allegro_resource">find_allegro_resource</a>(char *dest, const char *resource, 
                          const char *ext, const char *datafile, 
                          const char *objectname, const char *envvar, 
                          const char *subdir, int size);</b></div><br>
   Searches for a support file, eg. <tt>`allegro.cfg'</tt> or <tt>`language.dat'</tt>. Passed a
   resource string describing what you are looking for, along with extra 
   optional information such as the default extension, what datafile to look 
   inside, what the datafile object name is likely to be, any special 
   environment variable to check, and any subdirectory that you would like 
   to check as well as the default location, this function looks in a hell 
   of a lot of different places :-). Pass NULL for the parameters you are not
   using.

<p>
   Check the documentation chapter specific to your platform for information
   on additional paths this function might search for. Also, don't forget
   about set_allegro_resource_path() to extend the searches. Example:
<blockquote class="code"><pre>
      char path[256];
      int ret;
      ret = <a href="#find_allegro_resource" class="autotype" title="Searches for a support file in many places.">find_allegro_resource</a>(path, "scores.cfg", NULL, NULL,
                                  NULL, NULL, NULL, sizeof(path));
      if (ret == 0) {
         /* Found system wide scores file. */
      } else {
         /* No previous scores, create our own file. */
      }</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success, and stores a full path to the file (at most size
   bytes) into the dest buffer.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_allegro_resource_path" title="Sets a specific resource search path.">set_allegro_resource_path</a>.</blockquote>
<div class="al-api"><b>int <a name="set_allegro_resource_path">set_allegro_resource_path</a>(int priority, const char *path);</b></div><br>
   Sometimes Allegro doesn't look in enough places to find a resource. For
   those special cases, you can call this function before loading your
   resource with additional paths to search for. You set up the priorities,
   higher numbers are searched for first. To modify an already setup path,
   call this function with the same priority and the new path. To remove an
   already setup path, call this function with the priority of the path and
   NULL as the path parameter. Example:
<blockquote class="code"><pre>
      <a href="#set_allegro_resource_path" class="autotype" title="Sets a specific resource search path.">set_allegro_resource_path</a>(10, "my_game/configs");
      <a href="#set_allegro_resource_path" class="autotype" title="Sets a specific resource search path.">set_allegro_resource_path</a>(0, "users/configs/");
      <a href="#set_allegro_resource_path" class="autotype" title="Sets a specific resource search path.">set_allegro_resource_path</a>(-45, "temp");
</pre></blockquote>
   These custom paths will be valid until you call allegro_exit(). You can
   call this function before install_allegro(), but after set_uformat() if
   you want to use a text encoding format other than the default.
<p><b>Return value:</b>
   Returns non-zero on success, zero if the path could not be added or you
   wanted to remove a path and the priority used didn't have any associated
   path. Modification of existing paths always succeeds.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#find_allegro_resource" title="Searches for a support file in many places.">find_allegro_resource</a>.</blockquote>
<div class="al-api"><b>void <a name="packfile_password">packfile_password</a>(const char *password);</b></div><br>
   Sets the encryption password to be used for all read/write operations
   on files opened in future using Allegro's packfile functions (whether
   they are compressed or not), including all the save, load and config
   routines. Files written with an encryption password cannot be read
   unless the same password is selected, so be careful: if you forget the
   key, nobody can make your data come back again! Pass NULL or an empty
   string to return to the normal, non-encrypted mode. If you are using
   this function to prevent people getting access to your datafiles, be
   careful not to store an obvious copy of the password in your executable:
   if there are any strings like "I'm the password for the datafile", it
   would be fairly easy to get access to your data :-)

<p>
   Note #1: when writing a packfile, you can change the password to whatever
   you want after opening the file, without affecting the write operation.
   On the contrary, when writing a sub-chunk of a packfile, you must make
   sure that the password that was active at the time the sub-chunk was
   opened is still active before closing the sub-chunk. This is guaranteed
   to be true if you didn't call the packfile_password() routine in the
   meantime. Read operations, either on packfiles or sub-chunks, have no
   such restriction.

<p>
   Note #2: as explained above, the password is used for all read/write
   operations on files, including for several functions of the library that
   operate on files without explicitly using packfiles (e.g. load_bitmap()).
   The unencrypted mode is mandatory in order for those functions to work.
   Therefore remember to call packfile_password(NULL) before using them if
   you previously changed the password. As a rule of thumb, always call
   packfile_password(NULL) when you are done with operations on packfiles.
   The only exception to this is custom packfiles created with
   pack_fopen_vtable().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#pack_fopen_vtable" title="">pack_fopen_vtable</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *<a name="pack_fopen">pack_fopen</a>(const char *filename, const char *mode);</b></div><br>
   Opens a file according to mode, which may contain any of the flags:
<ul><li>
      <tt>`r'</tt> - open file for reading.
<li>
      <tt>`w'</tt> - open file for writing, overwriting any existing data.
<li>
      <tt>`p'</tt> - open file in packed mode. Data will be compressed as it is
            written to the file, and automatically uncompressed during read 
            operations. Files created in this mode will produce garbage if 
            they are read without this flag being set. 
<li>
      `!' - open file for writing in normal, unpacked mode, but add the
            value F_NOPACK_MAGIC to the start of the file, so that it can 
            later be opened in packed mode and Allegro will automatically 
            detect that the data does not need to be decompressed.
</ul>
   Instead of these flags, one of the constants F_READ, F_WRITE, 
   F_READ_PACKED, F_WRITE_PACKED or F_WRITE_NOPACK may be used as the mode 
   parameter.

<p>
   The packfile functions also understand several "magic" filenames that are 
   used for special purposes. These are:
<ul><li>
      `#' - read data that has been appended to your executable file with
      the exedat utility, as if it was a regular independent disk file.
<li>
      `filename.dat#object_name' - open a specific object from a datafile,
      and read from it as if it was a regular file. You can treat nested 
      datafiles exactly like a normal directory structure, for example 
      you could open `filename.dat#graphics/level1/mapdata'.
<li>
      `#object_name' - combination of the above, reading an object from a
      datafile that has been appended onto your executable.
</ul>
   With these special filenames, the contents of a datafile object or 
   appended file can be read in an identical way to a normal disk file, so 
   any of the file access functions in Allegro (eg. load_pcx() and 
   set_config_file()) can be used to read from them. Note that you can't 
   write to these special files, though: the fake file is read only. Also, 
   you must save your datafile uncompressed or with per-object compression 
   if you are planning on loading individual objects from it (otherwise 
   there will be an excessive amount of seeking when it is read).

<p>
   Finally, be aware that the special Allegro object types aren't the same
   format as the files you import the data from. When you import data like
   bitmaps or samples into the grabber, they are converted into a special
   Allegro-specific format, but the `#' marker file syntax reads the objects
   as raw binary chunks. This means that if, for example, you want to use 
   load_pcx() to read an image from a datafile, you should import it as a
   binary block rather than as a BITMAP object.

<p>
   Example:
<blockquote class="code"><pre>
      <a href="#PACKFILE" class="autotype" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *input_file;

      input_file = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>("scores.dat", "rp");
      if (!input_file)
         abort_on_error("Couldn't read <tt>`scores.dat'</tt>!");</pre></blockquote>
<p><b>Return value:</b>
   On success, pack_fopen() returns a pointer to a PACKFILE structure, and on
   error it returns NULL and stores an error code in <tt>`errno'</tt>. An attempt to
   read a normal file in packed mode will cause <tt>`errno'</tt> to be set to EDOM.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fclose" title="Closes a stream previously opened.">pack_fclose</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>,
<a class="xref" href="#packfile_password" title="Sets the global I/O encryption password.">packfile_password</a>,
<a class="xref" href="#pack_fread" title="Reads n bytes from the stream.">pack_fread</a>,
<a class="xref" href="#pack_getc" title="Returns the next character from a stream.">pack_getc</a>,
<a class="xref" href="#file_select_ex" title="Displays the Allegro file selector with a caption.">file_select_ex</a>,
<a class="xref" href="#pack_fopen_vtable" title="">pack_fopen_vtable</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *<a name="pack_fopen_vtable">pack_fopen_vtable</a>(const <a class="autotype" href="#PACKFILE_VTABLE" title="Packfile vtable structure, for custom packfiles.">PACKFILE_VTABLE</a> *vtable, void *userdata);</b></div><br>
   Creates a new packfile structure that uses the functions specified in
   the vtable instead of the standard functions. The data pointer by <tt>`vtable'</tt>
   and <tt>`userdata'</tt> must remain available for the lifetime of the created
   packfile.

<p>
   While the created packfile structure can be used with other Allegro
   functions, there are two limitations. First, opening chunks using
   pack_fopen_chunk() on top of the returned packfile is not possible at this
   time. And packfile_password() does not have any effect on packfiles opened
   with pack_fopen_vtable().
<p><b>Return value:</b>
   On success, it returns a pointer to a PACKFILE structure, and on error it
   returns NULL and stores an error code in <tt>`errno'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>,
<a class="xref" href="#packfile_password" title="Sets the global I/O encryption password.">packfile_password</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_fclose">pack_fclose</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Closes the stream <tt>`f'</tt> previously opened with pack_fopen() or
   pack_fopen_vtable(). After you have closed the stream, performing
   operations on it will yield errors in your application (e.g. crash it) or
   even block your OS.
<p><b>Return value:</b>
   Returns zero on success. On error, returns an error code which is also
   stored in <tt>`errno'</tt>. This function can fail only when writing to files: if
   the file was opened in read mode, it will always succeed.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_vtable" title="">pack_fopen_vtable</a>,
<a class="xref" href="#packfile_password" title="Sets the global I/O encryption password.">packfile_password</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_fseek">pack_fseek</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f, int offset);</b></div><br>
   Moves the position indicator of the stream <tt>`f'</tt>. Unlike the standard fseek()
   function, this only supports forward movements relative to the current
   position and in read-only streams, so don't use negative offsets. Note that
   seeking is very slow when reading compressed files, and so should be
   avoided unless you are sure that the file is not compressed. Example:
<blockquote class="code"><pre>
      input_file = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>("data.bin", "r");
      if (!input_file)
         abort_on_error("Couldn't open binary data!");
      /* Skip some useless header before reading data. */
      <a href="#pack_fseek" class="autotype" title="Seeks inside a stream.">pack_fseek</a>(input_file, 32);</pre></blockquote>
<p><b>Return value:</b>
   Returns zero on success or a negative number on error, storing the error
   code in <tt>`errno'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_feof">pack_feof</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Finds out if you have reached the end of the file. It does not wait for you
   to attempt to read beyond the end of the file, contrary to the ISO C feof()
   function. The only way to know whether you have read beyond the end of the
   file is to check the return value of the read operation you use (and be
   wary of pack_*getl() as EOF is also a valid return value with these
   functions).
<p><b>Return value:</b>
   Returns non-zero if you are at the end of the file, zero otherwise.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>,
<a class="xref" href="#pack_ferror" title="Tells if an error occurred during an operation on the stream.">pack_ferror</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_ferror">pack_ferror</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Since EOF is used to report errors by some functions, it's often better to
   use the pack_feof() function to check explicitly for end of file and
   pack_ferror() to check for errors. Both functions check indicators that
   are part of the internal state of the stream to detect correctly the
   different situations.
<p><b>Return value:</b>
   Returns nonzero if the error indicator for the stream is set, meaning
   that an error has occurred during a previous operation on the stream.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_getc">pack_getc</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Returns the next character from the stream <tt>`f'</tt>, or EOF if the end of the
   file has been reached.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_ungetc">pack_ungetc</a>(int c, <a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Puts a character back to the file's input buffer. Like with ungetc from
   libc, only a single push back is guaranteed.

<p>
   Note: pack_fgets internally uses pack_ungetc, so never use pack_ungetc
   directly after using pack_fgets on a PACKFILE.
<p><b>Return value:</b>
   Returns c on success, or EOF on error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_getc" title="Returns the next character from a stream.">pack_getc</a>,
<a class="xref" href="#pack_fgets" title="Reads a line from the stream.">pack_fgets</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_putc">pack_putc</a>(int c, <a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Puts a character in the stream f.
<p><b>Return value:</b>
   Returns the character written on success, or EOF on error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_igetw">pack_igetw</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Like pack_getc, but reads a 16-bit word from a file, using Intel byte
   ordering (least significant byte first, a.k.a. little-endian).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_getc" title="Returns the next character from a stream.">pack_getc</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_iputw">pack_iputw</a>(int c, <a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Like pack_putc, but writes a 16-bit word to a file, using Intel byte
   ordering (least significant byte first, a.k.a. little-endian).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_putc" title="Puts a character in the stream.">pack_putc</a>.</blockquote>
<div class="al-api"><b>long <a name="pack_igetl">pack_igetl</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Like pack_getc, but reads a 32-bit long from a file, using Intel byte
   ordering (least significant byte first, a.k.a. little-endian).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_getc" title="Returns the next character from a stream.">pack_getc</a>.</blockquote>
<div class="al-api"><b>long <a name="pack_iputl">pack_iputl</a>(long c, <a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Like pack_putc, but writes a 32-bit long to a file, using Intel byte
   ordering (least significant byte first, a.k.a. little-endian).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_putc" title="Puts a character in the stream.">pack_putc</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_mgetw">pack_mgetw</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Like pack_getc, but reads a 16-bit word from a file, using Motorola byte
   ordering (most significant byte first, a.k.a. big-endian).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_getc" title="Returns the next character from a stream.">pack_getc</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_mputw">pack_mputw</a>(int c, <a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Like pack_putc, but writes a 16-bit word to a file, using Motorola byte
   ordering (most significant byte first, a.k.a. big-endian).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_putc" title="Puts a character in the stream.">pack_putc</a>.</blockquote>
<div class="al-api"><b>long <a name="pack_mgetl">pack_mgetl</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Like pack_getc, but reads a 32-bit long from a file, using Motorola byte
   ordering (most significant byte first, a.k.a. big-endian).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_getc" title="Returns the next character from a stream.">pack_getc</a>.</blockquote>
<div class="al-api"><b>long <a name="pack_mputl">pack_mputl</a>(long c, <a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Like pack_putc, but writes a 32-bit long to a file, using Motorola byte
   ordering (most significant byte first, a.k.a. big-endian).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_putc" title="Puts a character in the stream.">pack_putc</a>.</blockquote>
<div class="al-api"><b>long <a name="pack_fread">pack_fread</a>(void *p, long n, <a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Reads <tt>`n'</tt> bytes from the stream <tt>`f'</tt>, storing them at the memory location
   pointed to by <tt>`p'</tt>. Example:
<blockquote class="code"><pre>
      unsigned char buf[256];
      ...
      if (<a href="#pack_fread" class="autotype" title="Reads n bytes from the stream.">pack_fread</a>(buf, 256, input_file) != 256)
         abort_on_error("Truncated input file!");</pre></blockquote>
<p><b>Return value:</b>
   Returns the number of bytes read, which will be less than <tt>`n'</tt> if EOF is
   reached or an error occurs. Error codes are stored in errno.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>,
<a class="xref" href="#pack_feof" title="Returns nonzero as soon as you reach the end of the file.">pack_feof</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>long <a name="pack_fwrite">pack_fwrite</a>(const void *p, long n, <a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Writes <tt>`n'</tt> bytes to the stream <tt>`f'</tt> from memory location pointed to by <tt>`p'</tt>.
<p><b>Return value:</b>
   Returns the number of bytes written, which will be less than n if an
   error occurs. Error codes are stored in errno.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>,
<a class="xref" href="#pack_feof" title="Returns nonzero as soon as you reach the end of the file.">pack_feof</a>.</blockquote>
<div class="al-api"><b>char *<a name="pack_fgets">pack_fgets</a>(char *p, int max, <a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Reads a line from the stream <tt>`f'</tt>, storing it at location pointed to by
   <tt>`p'</tt>. Stops when a linefeed is encountered, or <tt>`max'</tt> bytes have been read.
   The end of line is handled by detecting the right combination of characters
   for the platform. This supports CR-LF (DOS/Windows), LF (Unix), and CR
   (Mac) formats. However, the trailing carriage return is not included in the
   returned string, in order to provide easy code portability across
   platforms. If you need the carriage return, use pack_fread() and/or
   pack_getc() instead.

<p>
   Note: This function internally may make calls to pack_ungetc, so you cannot
   use pack_ungetc directly afterwards.

<p>
   Example:
<blockquote class="code"><pre>
      char buf[256];
      ...
      while (<a href="#pack_fgets" class="autotype" title="Reads a line from the stream.">pack_fgets</a>(buf, sizeof(buf), input_file)) {
         /* Process input <a href="#line" class="autotype" title="Draws a line onto the bitmap.">line</a>. */
      }
      fclose(input_file);</pre></blockquote>
<p><b>Return value:</b>
   Returns the pointer <tt>`p'</tt> on success, or NULL on error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>,
<a class="xref" href="#pack_fread" title="Reads n bytes from the stream.">pack_fread</a>,
<a class="xref" href="#pack_getc" title="Returns the next character from a stream.">pack_getc</a>,
<a class="xref" href="#pack_ungetc" title="Moves one single character back to the input buffer.">pack_ungetc</a>.</blockquote>
<div class="al-api"><b>int <a name="pack_fputs">pack_fputs</a>(const char *p, <a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Writes a string to the stream <tt>`f'</tt>. The input string is converted from the
   current text encoding format to UTF-8 before writing. Newline characters
   are written as <tt>`\r\n'</tt> on DOS and Windows platforms. If you don't want this
   behaviour, use pack_fwrite() and/or pack_putc() instead.
<p><b>Return value:</b>
   Returns zero on success or a negative number on error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>,
<a class="xref" href="#pack_fwrite" title="Writes n bytes to the stream.">pack_fwrite</a>,
<a class="xref" href="#pack_putc" title="Puts a character in the stream.">pack_putc</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *<a name="pack_fopen_chunk">pack_fopen_chunk</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f, int pack);</b></div><br>
   Opens a sub-chunk of a file. Chunks are primarily intended for use by the 
   datafile code, but they may also be useful for your own file routines. A 
   chunk provides a logical view of part of a file, which can be compressed 
   as an individual entity and will automatically insert and check length 
   counts to prevent reading past the end of the chunk. The PACKFILE
   parameter is a previously opened file, and <tt>`pack'</tt> is a boolean parameter
   which will turn compression on for the sub-chunk if it is non-zero.
   Example:
<blockquote class="code"><pre>
      <a href="#PACKFILE" class="autotype" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *output = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>("out.raw", "w!");
      ...
      /* Create a sub-chunk with compression. */
      output = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>(chunk(output, 1);
      if (!output)
         abort_on_error("Error saving data!");
      /* Write some data to the sub-chunk. */
      ...
      /* Close the sub-chunk, recovering parent file. */
      output = <a href="#pack_fclose_chunk" class="autotype" title="Closes a previously opened sub-chunk.">pack_fclose_chunk</a>(output);
</pre></blockquote>
   The data written to the chunk will be prefixed with two length counts
   (32-bit, a.k.a. big-endian). For uncompressed chunks these will both be
   set to the size of the data in the chunk. For compressed chunks (created
   by setting the <tt>`pack'</tt> flag), the first length will be the raw size of the
   chunk, and the second will be the negative size of the uncompressed data.

<p>
   To read the chunk, use the following code:
<blockquote class="code"><pre>
      <a href="#PACKFILE" class="autotype" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *input = <a href="#pack_fopen" class="autotype" title="Opens a file according to mode.">pack_fopen</a>("out.raw", "rp");
      ...
      input = <a href="#pack_fopen_chunk" class="autotype" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>(input, 1);
      /* Read data from the sub-chunk and close it. */
      ...
      input = <a href="#pack_fclose_chunk" class="autotype" title="Closes a previously opened sub-chunk.">pack_fclose_chunk</a>(input);
</pre></blockquote>
   This sequence will read the length counts created when the chunk was 
   written, and automatically decompress the contents of the chunk if it 
   was compressed. The length will also be used to prevent reading past the 
   end of the chunk (Allegro will return EOF if you attempt this), and to 
   automatically skip past any unread chunk data when you call 
   pack_fclose_chunk().

<p>
   Chunks can be nested inside each other by making repeated calls to 
   pack_fopen_chunk(). When writing a file, the compression status is 
   inherited from the parent file, so you only need to set the pack flag if 
   the parent is not compressed but you want to pack the chunk data. If the 
   parent file is already open in packed mode, setting the pack flag will 
   result in data being compressed twice: once as it is written to the 
   chunk, and again as the chunk passes it on to the parent file.
<p><b>Return value:</b>
   Returns a pointer to the sub-chunked PACKFILE, or NULL if there was some
   error (eg. you are using a custom PACKFILE vtable).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fclose_chunk" title="Closes a previously opened sub-chunk.">pack_fclose_chunk</a>,
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *<a name="pack_fclose_chunk">pack_fclose_chunk</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f);</b></div><br>
   Closes a sub-chunk of a file, previously obtained by calling 
   pack_fopen_chunk().
<p><b>Return value:</b>
   Returns a pointer to the parent of the sub-chunk you just closed. Returns
   NULL if there was some error (eg. you tried to close a PACKFILE which
   wasn't sub-chunked).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#pack_fopen_chunk" title="Opens a sub-chunk of a file.">pack_fopen_chunk</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#LZSS_PACK_DATA" title="Opaque structure for handling LZSS compression.">LZSS_PACK_DATA</a> *<a name="create_lzss_pack_data">create_lzss_pack_data</a>(void);</b></div><br>
   Creates an LZSS_PACK_DATA structure, which can be used for LZSS
   compression with PACKFILEs.
<p><b>Return value:</b>
   Returns a pointer to the structure, or NULL if there was an error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#free_lzss_pack_data" title="Frees an LZSS structure.">free_lzss_pack_data</a>.</blockquote>
<div class="al-api"><b>void <a name="free_lzss_pack_data">free_lzss_pack_data</a>(<a class="autotype" href="#LZSS_PACK_DATA" title="Opaque structure for handling LZSS compression.">LZSS_PACK_DATA</a> *dat);</b></div><br>
   Frees an LZSS_PACK_DATA structure created with create_lzss_pack_data().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_lzss_pack_data" title="Creates an LZSS structure for compression.">create_lzss_pack_data</a>.</blockquote>
<div class="al-api"><b>int <a name="lzss_write">lzss_write</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *file, <a class="autotype" href="#LZSS_PACK_DATA" title="Opaque structure for handling LZSS compression.">LZSS_PACK_DATA</a> *dat, int size,
               unsigned char *buf, int last);</b></div><br>
   Packs <tt>`size'</tt> bytes from <tt>`buf'</tt>, using the pack information contained in
   <tt>`dat'</tt>. The compressed bytes will be stored in <tt>`file'</tt>.
<p><b>Return value:</b>
   Returns 0 on success, or EOF if there was an error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_lzss_pack_data" title="Creates an LZSS structure for compression.">create_lzss_pack_data</a>,
<a class="xref" href="#free_lzss_pack_data" title="Frees an LZSS structure.">free_lzss_pack_data</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#LZSS_UNPACK_DATA" title="Opaque structure for handling LZSS decompression.">LZSS_UNPACK_DATA</a> *<a name="create_lzss_unpack_data">create_lzss_unpack_data</a>(void);</b></div><br>
   Creates an LZSS_UNPACK_DATA structure, which can be used for LZSS
   decompression reading PACKFILEs.
<p><b>Return value:</b>
   Returns a pointer to the structure, or NULL if there was an error.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#free_lzss_unpack_data" title="Frees an LZSS structure.">free_lzss_unpack_data</a>.</blockquote>
<div class="al-api"><b>void <a name="free_lzss_unpack_data">free_lzss_unpack_data</a>(<a class="autotype" href="#LZSS_UNPACK_DATA" title="Opaque structure for handling LZSS decompression.">LZSS_UNPACK_DATA</a> *dat);</b></div><br>
   Frees an LZSS_UNPACK_DATA structure created with create_lzss_pack_data.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_lzss_unpack_data" title="Creates an LZSS structure for decompression.">create_lzss_unpack_data</a>.</blockquote>
<div class="al-api"><b>int <a name="lzss_read">lzss_read</a>(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *file, <a class="autotype" href="#LZSS_UNPACK_DATA" title="Opaque structure for handling LZSS decompression.">LZSS_UNPACK_DATA</a> *dat, int s,
              unsigned char *buf);</b></div><br>
   Unpacks from <tt>`dat'</tt> into <tt>`buf'</tt>, until either EOF is reached or <tt>`s'</tt> bytes
   have been extracted from <tt>`file'</tt>.
<p><b>Return value:</b>
   Returns the number of bytes added to the buffer <tt>`buf'</tt>.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#free_lzss_unpack_data" title="Frees an LZSS structure.">free_lzss_unpack_data</a>.</blockquote>
<h1><a name="Datafile routines">Datafile routines</a></h1>

<p>
Datafiles are created by the grabber utility (see <a href="grabber.html">grabber.txt</a> for more
information), and have a <tt>`.dat'</tt> extension. They can contain bitmaps, palettes,
fonts, samples, MIDI music, FLI/FLC animations, and any other binary data that
you import. You could distribute your bitmaps and samples in a myriad of
separate files, but packing them in a few <tt>`.dat'</tt> binaries has a few
advantages:
<ul><li>
   On some platforms loading a single big datafile at once is faster than
   loading individual resources one by one.
<li>
   Instead of several loops for your resources, you can write a single line of
   code with just a single point of failure to take care of.
<li>
   You can potentially reduce the size of your data by enabling compression
   on your datafiles. Less download time for your end users, less wait during
   loading screens!
<li>
   If you don't need to load the whole datafile at once, you can still enable
   individual file compression. It is slightly worse than global compression,
   but it is very fast with loading times because Allegro can easily seek
   inside the datafile to find a specific object.
<li>
   Even without encryption, most end users of your application won't be able
   to look at or modify the resources for your game. A missing sound file or
   a modified bitmap could potentially crash the game if you haven't
   considered this in your loading code!
<li>
   It looks much more professional and convenient to distribute levels! For
   example, if you found a bug in a level of your game, just distribute your
   new <tt>`level4.dat'</tt> and tell users to overwrite their old version.
</ul>
Allegro allows you to load datafiles once and forget about them. But if you
have many levels it can be wise to load only the resources required for the
current level. You can accomplish the later by separating levels in different
datafiles, or using functions like load_datafile_object() to avoid loading
everything at once. You can even read directly from a specific datafile object
with the pack_fopen() function.

<p>
On some platforms you can attach datafiles to your binary, potentially
reducing your game distribution down to a single executable file. Try the
example exexedat on your platform to see if this is possible. However, this
is not recommended for big programs: a single update to your code or binary
data would force end users to download again a potentially big file, no matter
how small your change is. The same warning goes for the tools dat2s or dat2c,
which convert datafiles into assembler and C code respectively, prepared to be
included directly in your binary.

<p>
Remember that with Allegro truecolor images can only be loaded after you have
set a graphics mode. This is true for datafiles too. Load all your data after
you have set the graphics mode, otherwise the pixel format (RGB or BGR) will
not be known and the datafile may be converted wrongly. Oh, and read carefully
the warning of fixup_datafile() if you plan on switching resolutions during
runtime.

<p>
Note: even though Allegro datafiles provide encryption, you should consider
it weak, so don't plan on hiding there the plans for a Death Star or
something. Determinate knowledgeable users will be able to rip your resources
no matter how hard you try to hide them! Use the encryption only as a slight
deterrent towards unwanted tampering of your data. How to crack an encrypted
datafile is left as an exercise to the reader, though.

<p>
Using datafiles once they are loaded is quite simple: you access the elements
of the DATAFILE as a normal array. Read below the section "Using datafiles"
below for several examples on how to access their data.

<p><br>
<div class="al-api"><b><a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *<a name="load_datafile">load_datafile</a>(const char *filename);</b></div><br>
   Loads a datafile into memory in one go. If the datafile has been encrypted,
   you must first call packfile_password() to set the appropriate key. If the
   datafile contains truecolor graphics, you must set the video mode or call
   set_color_conversion() before loading it. Example:
<blockquote class="code"><pre>
      /* Load the resources for our game. */
      <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat = <a href="#load_datafile" class="autotype" title="Loads a datafile into memory.">load_datafile</a>("game.dat");
      if (!dat)
         abort_on_error("Couldn't load sound resources!");
      /* Use resources. */
      ...
      /* Destroy them when we don't need them any more. */
      <a href="#unload_datafile" class="autotype" title="Frees all the objects in a datafile.">unload_datafile</a>(dat);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the DATAFILE, or NULL on error. Remember to free this
   DATAFILE later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_datafile_callback" title="Loads a datafile into memory, calling a hook per object.">load_datafile_callback</a>,
<a class="xref" href="#unload_datafile" title="Frees all the objects in a datafile.">unload_datafile</a>,
<a class="xref" href="#load_datafile_object" title="Loads a specific object from a datafile.">load_datafile_object</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#fixup_datafile" title="Fixes truecolor images in compiled datafiles.">fixup_datafile</a>,
<a class="xref" href="#packfile_password" title="Sets the global I/O encryption password.">packfile_password</a>,
<a class="xref" href="#find_datafile_object" title="Searches a datafile for an object with a name.">find_datafile_object</a>,
<a class="xref" href="#register_datafile_object" title="Registers load/destroy functions for custom object types.">register_datafile_object</a>,
<a class="xref" href="#Using datafiles" title="">Using datafiles</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exdata" title="Accessing the contents of datafiles.">exdata</a>,
<a class="eref" href="#exexedat" title="Appending datafiles onto your executable.">exexedat</a>,
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *<a name="load_datafile_callback">load_datafile_callback</a>(const char *filename,
                                 void (*callback)(<a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *d));</b></div><br>
   Loads a datafile into memory, calling the specified hook function once for
   each object in the file, passing it a pointer to the object just read. You
   can use this to implement very simple loading screens where every time the
   hook is called, the screen is updated to let the user know your program is
   still loading from disk:
<blockquote class="code"><pre>
      void load_callback(<a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat_obj)
      {
         static const char indicator[] = "-\\|/-.oOXOo.";
         static int current = 0;
          
         /* Show a different character every time. */
         <a href="#textprintf_ex" class="autotype" title="Formatted output of a string.">textprintf_ex</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, <a href="#font" class="autotype" title="A simple 8x8 fixed size font.">font</a>, 0, 0, <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(0, 0, 0),
                       <a href="#makecol" class="autotype" title="Converts an RGB value into the current pixel format.">makecol</a>(255, 255, 255), "%c Loading %c",
                       indicator[current], indicator[current]);
         /* Increase index and check if we need to reset it. */
         current++;
         if (!indicator[current])
            current = 0;
      }
         ...
         dat = <a href="#load_datafile_callback" class="autotype" title="Loads a datafile into memory, calling a hook per object.">load_datafile_callback</a>("data.dat", load_callback);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the DATAFILE or NULL on error. Remember to free this
   DATAFILE later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#unload_datafile" title="Frees all the objects in a datafile.">unload_datafile</a>,
<a class="xref" href="#load_datafile_object" title="Loads a specific object from a datafile.">load_datafile_object</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#fixup_datafile" title="Fixes truecolor images in compiled datafiles.">fixup_datafile</a>,
<a class="xref" href="#packfile_password" title="Sets the global I/O encryption password.">packfile_password</a>,
<a class="xref" href="#find_datafile_object" title="Searches a datafile for an object with a name.">find_datafile_object</a>,
<a class="xref" href="#register_datafile_object" title="Registers load/destroy functions for custom object types.">register_datafile_object</a>.</blockquote>
<div class="al-api"><b>void <a name="unload_datafile">unload_datafile</a>(<a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat);</b></div><br>
   Frees all the objects in a datafile. Use this to avoid memory leaks in
   your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exdata" title="Accessing the contents of datafiles.">exdata</a>,
<a class="eref" href="#exexedat" title="Appending datafiles onto your executable.">exexedat</a>,
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exunicod" title="Using Unicode string functions.">exunicod</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *<a name="load_datafile_object">load_datafile_object</a>(const char *filename, 
                               const char *objectname);</b></div><br>
   Loads a specific object from a datafile. This won't work if you strip the 
   object names from the file, and it will be very slow if you save the file 
   with global compression. Example:
<blockquote class="code"><pre>
      /* Load only the music from the datafile. */
      music_object = <a href="#load_datafile_object" class="autotype" title="Loads a specific object from a datafile.">load_datafile_object</a>("datafile.dat",
                                          "MUSIC");
      /* Play it and wait a moment for it. */
      <a href="#play_midi" class="autotype" title="Starts playing the specified MIDI file.">play_midi</a>(music_object-&gt;dat);
      ...
      /* Destroy unneeded music. */
      <a href="#unload_datafile_object" class="autotype" title="Frees an object previously loaded by load_datafile_object().">unload_datafile_object</a>(music_object);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to a single DATAFILE element whose <tt>`dat'</tt> member points to
   the object, or NULL if there was an error or there was no object with the
   requested name. Remember to free this DATAFILE later to avoid memory leaks,
   but use the correct unloading function!


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#unload_datafile_object" title="Frees an object previously loaded by load_datafile_object().">unload_datafile_object</a>,
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#find_datafile_object" title="Searches a datafile for an object with a name.">find_datafile_object</a>,
<a class="xref" href="#register_datafile_object" title="Registers load/destroy functions for custom object types.">register_datafile_object</a>,
<a class="xref" href="#Using datafiles" title="">Using datafiles</a>.</blockquote>
<div class="al-api"><b>void <a name="unload_datafile_object">unload_datafile_object</a>(<a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat);</b></div><br>
   Frees an object previously loaded by load_datafile_object(). Use this to
   avoid memory leaks in your program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_datafile_object" title="Loads a specific object from a datafile.">load_datafile_object</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *<a name="find_datafile_object">find_datafile_object</a>(const <a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat, const char *objectname);</b></div><br>
   Searches an already loaded datafile for an object with the specified 
   name. In the name you can use <tt>`/'</tt> and `#' separators for nested datafile
   paths. Example:
<blockquote class="code"><pre>
      char level_name[10];
      <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat, *level;
      ...
      <a href="#uszprintf" class="autotype" title="Writes formatted data into a buffer, specifying size.">uszprintf</a>(level_name, sizeof(buffer),
                "LEVEL_%02d", level_number);
      level = <a href="#find_datafile_object" class="autotype" title="Searches a datafile for an object with a name.">find_datafile_object</a>(dat, level_name);
      if (!level)
         abort_on_error("That level doesn't exist!");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to a single DATAFILE element whose <tt>`dat'</tt> member points to
   the object, or NULL if the object could not be found.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#load_datafile_object" title="Loads a specific object from a datafile.">load_datafile_object</a>.</blockquote>
<div class="al-api"><b>DATAFILE_INDEX *<a name="create_datafile_index">create_datafile_index</a>(const char *filename);</b></div><br>
   Creates an index for a datafile, to speed up loading single objects out of
   it. This is mostly useful for big datafiles, which you don't want to load as
   a whole. The index will store the offset of all objects inside the datafile,
   and then you can load it quickly with "load_datafile_object_indexed" later.
   Use destroy_datafile_index to free the memory used by it again.

<p>
   Note: If the datafile uses global compression, there is no performance gain
   from using an index, because seeking to the offset still requires to
   uncompress the whole datafile up to that offset.
   Example:
<blockquote class="code"><pre>
   DATAFILE_INDEX *index = <a href="#create_datafile_index" class="autotype" title="Creates an index for a datafile.">create_datafile_index</a>("huge.dat");
   <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *object = <a href="#load_datafile_object_indexed" class="autotype" title="Loads a single object from a datafile index.">load_datafile_object_indexed</a>(index, 1234);
   ...
   <a href="#unload_datafile_object" class="autotype" title="Frees an object previously loaded by load_datafile_object().">unload_datafile_object</a>(object);
   <a href="#destroy_datafile_index" class="autotype" title="Destroys a datafile index.">destroy_datafile_index</a>(index);</pre></blockquote>
<p><b>Return value:</b>
   A pointer value which you can pass to load_datafile_object_indexed.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#destroy_datafile_index" title="Destroys a datafile index.">destroy_datafile_index</a>,
<a class="xref" href="#load_datafile_object_indexed" title="Loads a single object from a datafile index.">load_datafile_object_indexed</a>,
<a class="xref" href="#Using datafiles" title="">Using datafiles</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *<a name="load_datafile_object_indexed">load_datafile_object_indexed</a>(const DATAFILE_INDEX *index, int item)</b></div><br>
   This loads a single object, using the index created previously with
   create_datafile_index. See create_datafile_index for an example.
<p><b>Return value:</b>
   Returns a pointer to a single DATAFILE element whose "dat" member points to
   the object, or NULL if the object could not be loaded.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_datafile_index" title="Creates an index for a datafile.">create_datafile_index</a>,
<a class="xref" href="#load_datafile_object" title="Loads a specific object from a datafile.">load_datafile_object</a>,
<a class="xref" href="#unload_datafile_object" title="Frees an object previously loaded by load_datafile_object().">unload_datafile_object</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_datafile_index">destroy_datafile_index</a>(DATAFILE_INDEX *index)</b></div><br>
   This function frees the memory used by a datafile index created with
   create_datafile_index earlier.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_datafile_index" title="Creates an index for a datafile.">create_datafile_index</a>.</blockquote>
<div class="al-api"><b>const char *<a name="get_datafile_property">get_datafile_property</a>(const <a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat, int type);</b></div><br>
   Finds the property type of a DATAFILE object. The type parameter must be a
   value created with the DAT_ID() macro. Example:
<blockquote class="code"><pre>
      const char *name;
      ...
      name = <a href="#get_datafile_property" class="autotype" title="Returns the property string for the object.">get_datafile_property</a>(game_data,
                                   <a href="#DAT_ID" class="autotype" title="Makes an ID value from four letters.">DAT_ID</a>('N','A','M','E'));
      if (name == <a href="#empty_string" class="autotype" title="Universal string NULL terminator.">empty_string</a>)
         abort_on_error("Object doesn't have a name!");</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the text string for the object, or a pointer to the
   variable empty_string if the property isn't present.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Using datafiles" title="">Using datafiles</a>,
<a class="xref" href="#DAT_ID" title="Makes an ID value from four letters.">DAT_ID</a>,
<a class="xref" href="#empty_string" title="Universal string NULL terminator.">empty_string</a>.</blockquote>
<div class="al-api"><b>void <a name="register_datafile_object">register_datafile_object</a>(int id, void *(*load)(<a class="autotype" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f, long size),
                              void (*destroy)(void *data));</b></div><br>
   Used to add custom object types, specifying functions to load and destroy 
   objects of this type.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#load_datafile_object" title="Loads a specific object from a datafile.">load_datafile_object</a>,
<a class="xref" href="#DAT_ID" title="Makes an ID value from four letters.">DAT_ID</a>,
<a class="xref" href="#Custom datafile objects" title="">Custom datafile objects</a>.</blockquote>
<div class="al-api"><b>void <a name="fixup_datafile">fixup_datafile</a>(<a class="autotype" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a> *data);</b></div><br>
   If you are using compiled datafiles (produced by the dat2s and dat2c
   utilities) on a platform that doesn't support constructors (currently any
   non GCC-based platform), or if the datafiles contain truecolor images, you
   must call this function once after your set the video mode that you will
   be using. This will ensure the datafiles are properly initialised in the
   first case and convert the color values into the appropriate format in
   the second case. It handles flipping between RGB and BGR formats, and
   converting between different color depths whenever that can be done
   without changing the size of the image (ie. changing 15&lt;-&gt;16-bit
   hicolor for both bitmaps and RLE sprites, and 24&lt;-&gt;32-bit truecolor
   for RLE sprites).

<p>
   Note that you can only call this once and expect it to work correctly,
   because after the call the DATAFILE you fixed up is permanently converted
   to whatever is the current component ordering for your screen mode. If you
   call fixup_datafile again, the function assumes you have a freshly loaded
   datafile. It cannot "undo" the previous conversion.

<p>
   If your program supports changing resolution and/or color depth during
   runtime, you have two choices: either call fixup_datafile() just once and
   hope that the component ordering and bit depth doesn't change when the
   screen mode changes (unlikely). Or, you can reload your datafiles when the
   screen mode changes.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#Differences between platforms" title="">Differences between platforms</a>.</blockquote>
<div class="al-api"><b>Macro <a name="DAT_ID">DAT_ID</a>(a, b, c, d);</b></div><br>
   Every object or property in a datafile is identified by a 4 letter ID,
   which can be created with this macro. For example, to access the NAME
   property of a datafile object, you could use:
<blockquote class="code"><pre>
      <a href="#get_datafile_property" class="autotype" title="Returns the property string for the object.">get_datafile_property</a>(datob, <a href="#DAT_ID" class="autotype" title="Makes an ID value from four letters.">DAT_ID</a>('N','A','M','E'));
</pre></blockquote>



<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#register_datafile_object" title="Registers load/destroy functions for custom object types.">register_datafile_object</a>,
<a class="xref" href="#get_datafile_property" title="Returns the property string for the object.">get_datafile_property</a>,
<a class="xref" href="#Custom datafile objects" title="">Custom datafile objects</a>,
<a class="xref" href="#Using datafiles" title="">Using datafiles</a>.</blockquote>
<br><center><h2><a name="Using datafiles">Using datafiles</a></h2></center><p>

<p>
In order to access the contents of a datafile, you will need to know where
each object is located. The easiest way to do this is by integer index,
using an automatically generated header file. With the grabber, type a name
into the "Header:" field, and the object indexes will be written to this
file whenever the datafile is saved. With the dat utility, use the '-h'
option, eg. "dat filename.dat -h filename.h". The header will define C
preprocessor symbols for each object in the datafile, for example:
<blockquote class="code"><pre>
   #define SOME_DATA                        0        /* DATA */
   #define SOME_MORE_DATA                   1        /* DATA */
</pre></blockquote>
To prevent name conflicts, you can specify a prefix string for these
definitions by typing it into the "Prefix:" field in the grabber or using 
the '-p' option to dat.

<p>
To load a datafile into memory, call the function:
<blockquote class="code"><pre>
   <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *<a href="#load_datafile" class="autotype" title="Loads a datafile into memory.">load_datafile</a>(char *filename);
</pre></blockquote>
This will load the entire file, returning a pointer to it, or NULL on error.
When the data is no longer required, the entire thing can be destroyed by
calling:
<blockquote class="code"><pre>
   void <a href="#unload_datafile" class="autotype" title="Frees all the objects in a datafile.">unload_datafile</a>(<a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat);
</pre></blockquote>
When you load a datafile, you will obtain a pointer to an array of DATAFILE
structures:
<blockquote class="code"><pre>
   typedef struct <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a>
   {
      void *dat;                    - pointer to the actual data
      int type;                     - object type ID
      long size;                    - size of the data, in bytes
      DATAFILE_PROPERTY *prop;      - list of object properties
   } <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a>;</pre></blockquote>

<p>
The only really important piece of information here is the <tt>`dat'</tt> field, which
points to the contents of the object. What type of data this is will depend 
on the type of object: for bitmaps it will be an Allegro BITMAP structure, 
for RLE sprites an RLE_SPRITE, for fonts a FONT structure, etc. If you are 
programming in C you can pass this pointer directly to the relevant Allegro 
library functions, but if you are using C++ you will need to cast it to the 
appropriate type to prevent the compiler giving a warning.

<p>
For example, if you have a datafile called <tt>`myfile.dat'</tt>, which contains a
bitmap called COOL_PICTURE, and you have used it to produce a header called 
<tt>`myfile.h'</tt>, you could display the bitmap with the code:
<blockquote class="code"><pre>
   #include "myfile.h"

   void show_the_bitmap()
   {
      <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat;
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp;

      dat = <a href="#load_datafile" class="autotype" title="Loads a datafile into memory.">load_datafile</a>("myfile.dat");
      if (!dat) {
         /* report an error! */
         return;
      }

      bmp = (<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *)dat[COOL_PICTURE].dat;
      <a href="#blit" class="autotype" title="Copies a rectangular area from one bitmap to another.">blit</a>(bmp, <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, 0, 0, 0, bmp-&gt;w, bmp-&gt;h);
      <a href="#unload_datafile" class="autotype" title="Frees all the objects in a datafile.">unload_datafile</a>(dat);
   }</pre></blockquote>

<p>
If a datafile contains nested child datafiles, the header will prefix the 
names of objects in the sub-files with the name of their parent datafile. It 
will also define a count of the number of objects in the child file, which 
may be useful if for example the child datafile contains several bitmaps 
which form a 'run' animation, and you want your code to automatically 
adjust to the number of frames in the datafile. 

<p>
For example, the following datafile:
<blockquote class="text"><pre>
   "FILE" - NESTED_FILE
            |- "BMP" - A_BITMAP
            |- "FONT" - A_FONT
   "DATA" - SOME_DATA
   "DATA" - SOME_MORE_DATA
</pre></blockquote>
Will produce the header:
<blockquote class="code"><pre>
   #define NESTED_FILE                      0        /* FILE */

   #define NESTED_FILE_A_BITMAP             0        /* BMP  */
   #define NESTED_FILE_A_FONT               1        /* <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> */
   #define NESTED_FILE_COUNT                2

   #define SOME_DATA                        1        /* DATA */
   #define SOME_MORE_DATA                   2        /* DATA */
</pre></blockquote>
The main datafile contains three objects (NESTED_FILE, SOME_DATA, and 
SOME_MORE_DATA) with consecutive indexes, while the child datafile contains 
the two objects A_BITMAP and A_FONT. To access these objects you need to 
reference both the parent and child datafiles, eg:
<blockquote class="code"><pre>
   <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat = <a href="#load_datafile" class="autotype" title="Loads a datafile into memory.">load_datafile</a>("whatever.dat");
   <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *nested = (<a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *)dat[NESTED_FILE].dat;
   <a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *thefont = (<a href="#FONT" class="autotype" title="Stores an Allegro font.">FONT</a> *)nested[NESTED_FILE_A_FONT].dat;
</pre></blockquote>
If you need to access object property strings from within your program, you
can use the function:
<blockquote class="code"><pre>
   char *<a href="#get_datafile_property" class="autotype" title="Returns the property string for the object.">get_datafile_property</a>(<a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat, int type);
</pre></blockquote>
This will return a pointer to the property string if it can be found, and an
empty string (not null!) if it does not exist. One possible use of this 
function is to locate objects by name, rather than using the indexes from a 
header file. The datafile array is ended by an object of type DAT_END, so to 
search the datafile dat for the object "my_object" you could use the code:
<blockquote class="code"><pre>
   const int name_type = <a href="#DAT_ID" class="autotype" title="Makes an ID value from four letters.">DAT_ID</a>('N','A','M','E');
   for (i=0; dat[i].type != DAT_END; i++) {
      if (stricmp(<a href="#get_datafile_property" class="autotype" title="Returns the property string for the object.">get_datafile_property</a>(dat+i, name_type),
                  "my_object") == 0) {
         /* found the object at index i */
      }
   }
   /* not found... */
</pre></blockquote>
If you prefer to access objects by name rather than index number, you can
use the function:
<blockquote class="code"><pre>
   <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *<a href="#find_datafile_object" class="autotype" title="Searches a datafile for an object with a name.">find_datafile_object</a>(<a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat, char *objectname);
</pre></blockquote>
This will search an already loaded datafile for an object with the specified
name, returning a pointer to it, or NULL if the object cannot be found. It 
understands '/' and '#' separators for nested datafile paths.

<p>
It is also possible to selectively load individual objects from a datafile, 
with the function:
<blockquote class="code"><pre>
   <a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *<a href="#load_datafile_object" class="autotype" title="Loads a specific object from a datafile.">load_datafile_object</a>(char *filename, char *objectname);
</pre></blockquote>
This searches the datafile for an object with the specified name, so
obviously it won't work if you strip the name properties out of the file. 
Because this function needs to seek through the data, it will be extremely 
slow if you have saved the file with global compression. If you are planning 
to load objects individually, you should save the file uncompressed or with 
individual compression per-object. Because the returned datafile points to a 
single object rather than an array of objects, you should access it with the 
syntax datafile->dat, rather than datafile[index].dat, and when you are done
you should free the object with the function:
<blockquote class="code"><pre>
   void <a href="#unload_datafile_object" class="autotype" title="Frees an object previously loaded by load_datafile_object().">unload_datafile_object</a>(<a href="#DATAFILE" class="autotype" title="Stores an Allegro datafile in memory.">DATAFILE</a> *dat);
</pre></blockquote>
Example:
<blockquote class="code"><pre>
   music_object = <a href="#load_datafile_object" class="autotype" title="Loads a specific object from a datafile.">load_datafile_object</a>("datafile.dat", "MUSIC");
   <a href="#play_midi" class="autotype" title="Starts playing the specified MIDI file.">play_midi</a>(music_object-&gt;dat);
   ...
   <a href="#unload_datafile_object" class="autotype" title="Frees an object previously loaded by load_datafile_object().">unload_datafile_object</a>(music_object);
</pre></blockquote>
Alternatively, the packfile functions can open and read directly from the
contents of a datafile object. You do this by calling pack_fopen() with a 
fake filename in the form "filename.dat#object_name". The contents of the 
object can then be read in an identical way to a normal disk file, so any of 
the file access functions in Allegro (eg. load_pcx() and set_config_file()) 
can be used to read from datafile objects. Note that you can't write to 
datafiles in this way: the fake file is read only. Also, you should save the 
file uncompressed or with per-object compression if you are planning on 
using this feature. Finally, be aware that the special Allegro object types 
aren't the same format as the files you import the data from, so if for 
example you want to use load_pcx to read an image from a datafile, you 
should import it as a binary data chunk rather than as a BITMAP object.

<p>
If you have appended a datafile to the end of your executable with the 
exedat utility, use load_datafile("#") to read the entire thing into memory, 
load_datafile_object("#", "object_name") to load a specific object, and 
pack_fopen("#object_name", F_READ) to read one of the objects directly with 
your own code. Note that unless you use the previous functions to load the
appended data, the OS will not load it into memory just because you are
running the program, so you shouldn't have problems attaching datafiles to
your binary larger than the available system memory.

<p>
By default, all graphic objects loaded from a datafile will be converted 
into the current color depth. This conversion may be both lossy and very 
slow, particularly when reducing from truecolor to 256 color formats, so you 
may wish to disable it by calling set_color_conversion(COLORCONV_NONE) or 
set_color_conversion(COLORCONV_PARTIAL) before your call to load_datafile().



<p><br>
<br><center><h2><a name="Custom datafile objects">Custom datafile objects</a></h2></center><p>

<p>
Some of the objects in a datafile, for example palettes and FLI animations, 
are simply treated as blocks of binary data, but others are loaded into 
special formats such as bitmap structures or compiled sprites. It is 
possible to extend the datafile system to support your own custom object 
types, eg. map objects for a tile based engine, or level data for a platform 
game. Obviously the grabber has no way of understanding this data, but it 
will allow you to import binary data from external files, so you can grab 
information produced by your own utilities. If you are happy with the data 
being loaded as a simple binary block, that is all you need to do, but if 
you need to load it into a specific structure, read on...

<p>
Your custom objects must be given a unique type ID, which is formed from 
four ASCII characters (by convention all uppercase A-Z). If you don't use 
all four characters, the string should be padded with spaces (ASCII 32). You 
should use this ID when creating the objects in the grabber (select 
New/Other and type in the ID string), and in your code you should define an 
identifier for the type, eg:
<blockquote class="code"><pre>
   #define DAT_MAPDATA  <a href="#DAT_ID" class="autotype" title="Makes an ID value from four letters.">DAT_ID</a>('M','A','P','D')
</pre></blockquote>
You then need to write functions for loading and destroying objects of this
type, in the form:
<blockquote class="code"><pre>
   void *load_mapdata(<a href="#PACKFILE" class="autotype" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a> *f, long size)
   {
      /* Allegro will call this function whenever an object of your custom 
       * type needs to be loaded from a datafile. It will be passed a 
       * pointer to the file from which the data is to be read, and the size 
       * of the object in bytes. It should return a pointer to the loaded 
       * data, which will be stored in the dat field of the datafile object 
       * structure, or NULL if an error occurs. The file will have been 
       * opened as a sub-chunk of the main datafile, so it is safe to read 
       * past the end of the object (if you attempt this, Allegro will 
       * return EOF), and it is also safe to return before reading all the 
       * data in the chunk (if you do this, Allegro will skip any unused 
       * bytes before starting to read the next object). You should _not_ 
       * close the file when you are done: this will be handled by the 
       * calling function. To clarify how all this works, here's an example 
       * implementation of a null-terminated string object:
       */

      #define MAX_LEN  256

      char buf[MAX_LEN];
      char *p;
      int i, c;

      for (i=0; i&lt;;MAX_LEN-1; i++) {
         if ((c = <a href="#pack_getc" class="autotype" title="Returns the next character from a stream.">pack_getc</a>(f)) == EOF)
            break;

         buf[i] = c;
      }

      buf[i] = 0;

      p = malloc(i+1);
      strcpy(p, buf);

      return p;
   }

   void destroy_mapdata(void *data)
   {
      /* Allegro will call this function whenever an object of your custom 
       * type needs to be destroyed. It will be passed a pointer to the 
       * object (as returned by the load function), and should free whatever 
       * memory the object is using. For example, the simple string object 
       * returned by the above loader could be destroyed with the code:
       */

      if (data)
         free(data);
   }
</pre></blockquote>
Finally, before you load your datafile you must tell Allegro about the
custom format, by calling:
<blockquote class="code"><pre>
   <a href="#register_datafile_object" class="autotype" title="Registers load/destroy functions for custom object types.">register_datafile_object</a>(DAT_MAPDATA, load_mapdata, destroy_mapdata);
</pre></blockquote>
It is also possible to integrate support for custom object types directly
into the grabber and dat utilities, by copying some special files into the 
tools/plugins directory. This can be used to add whole new object types and 
menu commands, or to provide additional import/export routines for the 
existing formats. See <tt>`tools/plugins/plugins.txt'</tt> for an overview of how to
write your own grabber plugins.



<p><br>
<h1><a name="Fixed point math routines">Fixed point math routines</a></h1>

<p>
Allegro provides some routines for working with fixed point numbers, and
defines the type <tt>`fixed'</tt> to be a signed 32-bit integer. The high word is 
used for the integer part and the low word for the fraction, giving a range
of -32768 to 32767 and an accuracy of about four or five decimal places.
Fixed point numbers can be assigned, compared, added, subtracted, negated and
shifted (for multiplying or dividing by powers of two) using the normal
integer operators, but you should take care to use the appropriate conversion
routines when mixing fixed point with integer or floating point values.
Writing `fixed_point_1 + fixed_point_2' is OK, but `fixed_point + integer' is
not.

<p>
Unfortunately the only advantage of fixed point math routines is that you
don't require a floating point coprocessor to use them. This was great in the
time period of i386 and i486 machines, but stopped being so useful with the
coming of the Pentium class of processors. From Pentium onwards, CPUs have
increased their strength in floating point operations, equaling or even
surpassing integer math performance.

<p>
Depending on the type of operations your program may need, using floating
point types may be faster than fixed types if you are targeting a specific
machine class. Allegro comes with a test program in the <tt>`allegro/tests'</tt>
directory. Its <tt>`Misc'</tt> menu contains a basic profile test which can give you
an idea of the speed difference between fixed and float types for a few basic
operations on your machine. However, don't forget to profile your program in
real life conditions, tight loop benchmarks are after all artificial.

<p>
Fixed point math is considered "add-on" material and is kept only for
backwards compatibility. Whenever a future release of Allegro breaks backwards
compatibility, fixed point math will likely be moved to a separate add-on
package for the very few users who still find it convenient and useful, and
Allegro functions using fixed point math will use other types.

<p><br>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="itofix">itofix</a>(int x);</b></div><br>
   Converts an integer to fixed point. This is the same thing as x&lt;&lt;16.
   Remember that overflows (trying to convert an integer greater than 32767)
   and underflows (trying to convert an integer lesser than -32768) are not
   detected even in debug builds! The values simply "wrap around". Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> number;
      /* This conversion is OK. */
      number = <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(100);
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(<a href="#fixtoi" class="autotype" title="Converts a fixed point to integer with rounding.">fixtoi</a>(number) == 100);
      number = <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(64000);
      /* This check will fail in debug builds. */
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(<a href="#fixtoi" class="autotype" title="Converts a fixed point to integer with rounding.">fixtoi</a>(number) == 64000);</pre></blockquote>
<p><b>Return value:</b>
   Returns the value of the integer converted to fixed point ignoring
   overflows.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#ftofix" title="Converts a floating point value to fixed point.">ftofix</a>,
<a class="xref" href="#fixtof" title="Converts a fixed point to floating point.">fixtof</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>,
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exfixed" title="Using fixed point maths.">exfixed</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#exsprite" title="Datafiles access and sprite animation.">exsprite</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b>int <a name="fixtoi">fixtoi</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   Converts fixed point to integer, rounding as required to the nearest
   integer. Example:
<blockquote class="code"><pre>
      int result;
      /* This will put 33 into <tt>`result'</tt>. */
      result = <a href="#fixtoi" class="autotype" title="Converts a fixed point to integer with rounding.">fixtoi</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(100) / 3);
      /* But this will round up to 17. */
      result = <a href="#fixtoi" class="autotype" title="Converts a fixed point to integer with rounding.">fixtoi</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(100) / 6);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#ftofix" title="Converts a floating point value to fixed point.">ftofix</a>,
<a class="xref" href="#fixtof" title="Converts a fixed point to floating point.">fixtof</a>,
<a class="xref" href="#fixfloor" title="Returns the greatest integer not greater than x.">fixfloor</a>,
<a class="xref" href="#fixceil" title="Returns the smallest integer not less than x.">fixceil</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>,
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>int <a name="fixfloor">fixfloor</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   Returns the greatest integer not greater than x. That is, it rounds 
   towards negative infinity. Example:
<blockquote class="code"><pre>
      int result;
      /* This will put 33 into <tt>`result'</tt>. */
      result = <a href="#fixfloor" class="autotype" title="Returns the greatest integer not greater than x.">fixfloor</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(100) / 3);
      /* And this will round down to 16. */
      result = <a href="#fixfloor" class="autotype" title="Returns the greatest integer not greater than x.">fixfloor</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(100) / 6);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#fixceil" title="Returns the smallest integer not less than x.">fixceil</a>.</blockquote>
<div class="al-api"><b>int <a name="fixceil">fixceil</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   Returns the smallest integer not less than x. That is, it rounds towards
   positive infinity. Example:
<blockquote class="code"><pre>
      int result;
      /* This will put 34 into <tt>`result'</tt>. */
      result = <a href="#fixceil" class="autotype" title="Returns the smallest integer not less than x.">fixceil</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(100) / 3);
      /* This will round up to 17. */
      result = <a href="#fixceil" class="autotype" title="Returns the smallest integer not less than x.">fixceil</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(100) / 6);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#fixfloor" title="Returns the greatest integer not greater than x.">fixfloor</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="ftofix">ftofix</a>(double x);</b></div><br>
   Converts a floating point value to fixed point. Unlike itofix(), this
   function clamps values which could overflow the type conversion, setting
   <tt>`errno'</tt> to ERANGE in the process if this happens. Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> number;
      number = <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-40000);
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(<a href="#fixfloor" class="autotype" title="Returns the greatest integer not greater than x.">fixfloor</a>(number) == -32768);
      number = <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(64000);
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(<a href="#fixfloor" class="autotype" title="Returns the greatest integer not greater than x.">fixfloor</a>(number) == 32767);
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(!errno); /* This will fail. */</pre></blockquote>
<p><b>Return value:</b>
   Returns the value of the floating point value converted to fixed point
   clamping overflows (and setting <tt>`errno'</tt>).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fixtof" title="Converts a fixed point to floating point.">fixtof</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exfixed" title="Using fixed point maths.">exfixed</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>double <a name="fixtof">fixtof</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   Converts fixed point to floating point. Example:
<blockquote class="code"><pre>
      float result;
      
      /* This will put 33.33333 into <tt>`result'</tt>. */
      result = <a href="#fixtof" class="autotype" title="Converts a fixed point to floating point.">fixtof</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(100) / 3);
      /* This will put 16.66666 into <tt>`result'</tt>. */
      result = <a href="#fixtof" class="autotype" title="Converts a fixed point to floating point.">fixtof</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(100) / 6);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ftofix" title="Converts a floating point value to fixed point.">ftofix</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exfixed" title="Using fixed point maths.">exfixed</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixmul">fixmul</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y);</b></div><br>
   A fixed point value can be multiplied or divided by an integer with the 
   normal `*' and <tt>`/'</tt> operators. To multiply two fixed point values, though,
   you must use this function.

<p>
   If an overflow occurs, <tt>`errno'</tt> will be set and the maximum possible value
   will be returned, but <tt>`errno'</tt> is not cleared if the operation is
   successful. This means that if you are going to test for overflow you
   should set <tt>`errno=0'</tt> before calling fixmul(). Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> result;

      /* This will put 30000 into <tt>`result'</tt>. */
      result = <a href="#fixmul" class="autotype" title="Multiplies two fixed point values together.">fixmul</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(10), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(3000));
      /* But this overflows, and sets <tt>`errno'</tt>. */
      result = <a href="#fixmul" class="autotype" title="Multiplies two fixed point values together.">fixmul</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(100), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(3000));
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(!errno);</pre></blockquote>
<p><b>Return value:</b>
   Returns the clamped result of multiplying <tt>`x'</tt> by <tt>`y'</tt>, setting <tt>`errno'</tt> to
   ERANGE if there was an overflow.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fixadd" title="Safe function to add fixed point numbers clamping overflow.">fixadd</a>,
<a class="xref" href="#fixsub" title="Safe function to subtract fixed point numbers clamping underflow.">fixsub</a>,
<a class="xref" href="#fixdiv" title="Fixed point division.">fixdiv</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exfixed" title="Using fixed point maths.">exfixed</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixdiv">fixdiv</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y);</b></div><br>
   A fixed point value can be divided by an integer with the normal <tt>`/'</tt>
   operator. To divide two fixed point values, though, you must use this
   function. If a division by zero occurs, <tt>`errno'</tt> will be set and the
   maximum possible value will be returned, but <tt>`errno'</tt> is not cleared if the
   operation is successful. This means that if you are going to test for
   division by zero you should set <tt>`errno=0'</tt> before calling fixdiv(). Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> result;
      /* This will put 0.06060 <tt>`result'</tt>. */
      result = <a href="#fixdiv" class="autotype" title="Fixed point division.">fixdiv</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(2), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(33));
      /* This will put 0 into <tt>`result'</tt>. */
      result = <a href="#fixdiv" class="autotype" title="Fixed point division.">fixdiv</a>(0, <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-30));
      /* Sets <tt>`errno'</tt> and puts -32768 into <tt>`result'</tt>. */
      result = <a href="#fixdiv" class="autotype" title="Fixed point division.">fixdiv</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-100), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(0));
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(!errno); /* This will fail. */</pre></blockquote>
<p><b>Return value:</b>
   Returns the result of dividing <tt>`x'</tt> by <tt>`y'</tt>. If <tt>`y'</tt> is zero, returns the
   maximum possible fixed point value and sets <tt>`errno'</tt> to ERANGE.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fixadd" title="Safe function to add fixed point numbers clamping overflow.">fixadd</a>,
<a class="xref" href="#fixsub" title="Safe function to subtract fixed point numbers clamping underflow.">fixsub</a>,
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exfixed" title="Using fixed point maths.">exfixed</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixadd">fixadd</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y);</b></div><br>
   Although fixed point numbers can be added with the normal '+' integer 
   operator, that doesn't provide any protection against overflow. If overflow
   is a problem, you should use this function instead. It is slower than using
   integer operators, but if an overflow occurs it will set <tt>`errno'</tt> and clamp
   the result, rather than just letting it wrap. Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> result;
      /* This will put 5035 into <tt>`result'</tt>. */
      result = <a href="#fixadd" class="autotype" title="Safe function to add fixed point numbers clamping overflow.">fixadd</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(5000), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(35));
      /* Sets <tt>`errno'</tt> and puts -32768 into <tt>`result'</tt>. */
      result = <a href="#fixadd" class="autotype" title="Safe function to add fixed point numbers clamping overflow.">fixadd</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-31000), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-3000));
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(!errno); /* This will fail. */</pre></blockquote>
<p><b>Return value:</b>
   Returns the clamped result of adding <tt>`x'</tt> to <tt>`y'</tt>, setting <tt>`errno'</tt> to ERANGE
   if there was an overflow.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fixsub" title="Safe function to subtract fixed point numbers clamping underflow.">fixsub</a>,
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>,
<a class="xref" href="#fixdiv" title="Fixed point division.">fixdiv</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixsub">fixsub</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y);</b></div><br>
   Although fixed point numbers can be subtracted with the normal '-' integer
   operator, that doesn't provide any protection against overflow. If overflow
   is a problem, you should use this function instead. It is slower than using
   integer operators, but if an overflow occurs it will set <tt>`errno'</tt> and clamp
   the result, rather than just letting it wrap. Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> result;
      /* This will put 4965 into <tt>`result'</tt>. */
      result = <a href="#fixsub" class="autotype" title="Safe function to subtract fixed point numbers clamping underflow.">fixsub</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(5000), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(35));
      /* Sets <tt>`errno'</tt> and puts -32768 into <tt>`result'</tt>. */
      result = <a href="#fixsub" class="autotype" title="Safe function to subtract fixed point numbers clamping underflow.">fixsub</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-31000), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(3000));
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(!errno); /* This will fail. */</pre></blockquote>
<p><b>Return value:</b>
   Returns the clamped result of subtracting <tt>`y'</tt> from <tt>`x'</tt>, setting <tt>`errno'</tt> to
   ERANGE if there was an overflow.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fixadd" title="Safe function to add fixed point numbers clamping overflow.">fixadd</a>,
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>,
<a class="xref" href="#fixdiv" title="Fixed point division.">fixdiv</a>.</blockquote>
<br><center><h2><a name="Fixed point trig">Fixed point trig</a></h2></center><p>
The fixed point square root, sin, cos, tan, inverse sin, and inverse cos 
functions are implemented using lookup tables, which are very fast but not 
particularly accurate. At the moment the inverse tan uses an iterative 
search on the tan table, so it is a lot slower than the others. Note that on
machines with very good floating point processors using these functions could
be slower in real life code due to cache misses: it may be faster to wait
a few extra cycles for a floating point sine result rather than wait for the
CPU to fetch the precalculated table from main memory. Always profile your
code.

<p>
Angles are represented in a binary format with 256 equal to a full circle, 
64 being a right angle and so on. This has the advantage that a simple 
bitwise 'and' can be used to keep the angle within the range zero to a full
circle, eliminating all those tiresome 'if (angle &gt;= 360)' checks.

<p><br>
<div class="al-api"><b>extern const <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixtorad_r">fixtorad_r</a>;</b></div><br>
   This constant gives a ratio which can be used to convert a fixed point
   number in binary angle format to a fixed point number in radians. Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> rad_angle, binary_angle;
      /* Set the binary angle to 90 degrees. */
      binary_angle = 64;
      /* Now convert to radians (about 1.57). */
      rad_angle = <a href="#fixmul" class="autotype" title="Multiplies two fixed point values together.">fixmul</a>(binary_angle, <a href="#fixtorad_r" class="autotype" title="Constant to convert angles in fixed point format to radians.">fixtorad_r</a>);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>,
<a class="xref" href="#radtofix_r" title="Constant to convert radians to fixed point angles.">radtofix_r</a>.</blockquote>
<div class="al-api"><b>extern const <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="radtofix_r">radtofix_r</a>;</b></div><br>
   This constant gives a ratio which can be used to convert a fixed point
   number in radians to a fixed point number in binary angle format. Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> rad_angle, binary_angle;
      ...
      binary_angle = <a href="#fixmul" class="autotype" title="Multiplies two fixed point values together.">fixmul</a>(rad_angle, <a href="#radtofix_r" class="autotype" title="Constant to convert radians to fixed point angles.">radtofix_r</a>);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>,
<a class="xref" href="#fixtorad_r" title="Constant to convert angles in fixed point format to radians.">fixtorad_r</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixsin">fixsin</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   This function finds the sine of a value using a lookup table. The input
   value must be a fixed point binary angle. Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> angle;
      int result;

      /* Set the binary angle to 90 degrees. */
      angle = <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(64);
      /* The sine of 90 degrees is one. */
      result = <a href="#fixtoi" class="autotype" title="Converts a fixed point to integer with rounding.">fixtoi</a>(<a href="#fixsin" class="autotype" title="Fixed point sine of binary angles.">fixsin</a>(angle));
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(result == 1);</pre></blockquote>
<p><b>Return value:</b>
   Returns the sine of a fixed point binary format angle. The return value
   will be in radians.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>,
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixcos">fixcos</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   This function finds the cosine of a value using a lookup table. The input
   value must be a fixed point binary angle. Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> angle;
      float result;

      /* Set the binary angle to 45 degrees. */
      angle = <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(32);
      /* The cosine of 45 degrees is about 0.7071. */
      result = <a href="#fixtof" class="autotype" title="Converts a fixed point to floating point.">fixtof</a>(<a href="#fixcos" class="autotype" title="Fixed point cosine of binary angles.">fixcos</a>(angle));
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(result &gt; 0.7 &amp;&amp; result &lt; 0.71);</pre></blockquote>
<p><b>Return value:</b>
   Returns the cosine of a fixed point binary format angle. The return value
   will be in radians.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="#exblend" title="Using translucency in truecolor modes.">exblend</a>,
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixtan">fixtan</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   This function finds the tangent of a value using a lookup table. The input
   value must be a fixed point binary angle. Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> angle, res_a, res_b;
      float dif;
      
      angle = <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(37);
      /* Prove that tan(angle) == sin(angle) / cos(angle). */
      res_a = <a href="#fixdiv" class="autotype" title="Fixed point division.">fixdiv</a>(<a href="#fixsin" class="autotype" title="Fixed point sine of binary angles.">fixsin</a>(angle), <a href="#fixcos" class="autotype" title="Fixed point cosine of binary angles.">fixcos</a>(angle));
      res_b = <a href="#fixtan" class="autotype" title="Fixed point tangent of binary angles.">fixtan</a>(angle);
      dif = <a href="#fixtof" class="autotype" title="Converts a fixed point to floating point.">fixtof</a>(<a href="#fixsub" class="autotype" title="Safe function to subtract fixed point numbers clamping underflow.">fixsub</a>(res_a, res_b));
      <a href="#allegro_message" class="autotype" title="Used mainly to show error messages to users.">allegro_message</a>("Precision error: %f\n", dif);</pre></blockquote>
<p><b>Return value:</b>
   Returns the tangent of a fixed point binary format angle. The return value
   will be in radians.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixasin">fixasin</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   This function finds the inverse sine of a value using a lookup table. The
   input value must be a fixed point value. The inverse sine is defined only
   in the domain from `-1' to <tt>`1'</tt>. Outside of this input range, the function
   will set <tt>`errno'</tt> to EDOM and return zero. Example:
<blockquote class="code"><pre>
      float angle;
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> val;

      /* Sets <tt>`val'</tt> to a right binary angle (<tt>`64'</tt>). */
      val = <a href="#fixasin" class="autotype" title="Fixed point inverse sine lookup table.">fixasin</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(1));
      /* Sets <tt>`angle'</tt> to 0.2405. */
      angle = <a href="#fixtof" class="autotype" title="Converts a fixed point to floating point.">fixtof</a>(<a href="#fixmul" class="autotype" title="Multiplies two fixed point values together.">fixmul</a>(<a href="#fixasin" class="autotype" title="Fixed point inverse sine lookup table.">fixasin</a>(<a href="#ftofix" class="autotype" title="Converts a floating point value to fixed point.">ftofix</a>(0.238)), <a href="#fixtorad_r" class="autotype" title="Constant to convert angles in fixed point format to radians.">fixtorad_r</a>));
      /* This will trigger the assert. */
      val = <a href="#fixasin" class="autotype" title="Fixed point inverse sine lookup table.">fixasin</a>(<a href="#ftofix" class="autotype" title="Converts a floating point value to fixed point.">ftofix</a>(-1.09));
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(!errno);</pre></blockquote>
<p><b>Return value:</b>
   Returns the inverse sine of a fixed point value, measured as fixed point
   binary format angle, or zero if the input was out of the range. All return
   values of this function will be in the range `-64' to <tt>`64'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixacos">fixacos</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   This function finds the inverse cosine of a value using a lookup table. The
   input value must be a fixed point radian. The inverse cosine is defined
   only in the domain from `-1' to <tt>`1'</tt>. Outside of this input range, the
   function will set <tt>`errno'</tt> to EDOM and return zero. Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> result;

      /* Sets <tt>`result'</tt> to binary angle 128. */
      result = <a href="#fixacos" class="autotype" title="Fixed point inverse cosine lookup table.">fixacos</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-1));</pre></blockquote>
<p><b>Return value:</b>
   Returns the inverse sine of a fixed point value, measured as fixed point
   binary format angle, or zero if the input was out of range. All return
   values of this function will be in the range <tt>`0'</tt> to <tt>`128'</tt>.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixatan">fixatan</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   This function finds the inverse tangent of a value using a lookup table.
   The input value must be a fixed point radian. The inverse tangent is the
   value whose tangent is <tt>`x'</tt>. Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> result;

      /* Sets <tt>`result'</tt> to binary angle 13. */
      result = <a href="#fixatan" class="autotype" title="Fixed point inverse tangent lookup table.">fixatan</a>(<a href="#ftofix" class="autotype" title="Converts a floating point value to fixed point.">ftofix</a>(0.326));</pre></blockquote>
<p><b>Return value:</b>
   Returns the inverse tangent of a fixed point value, measured as a fixed
   point binary format angle.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixatan2">fixatan2</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   This is a fixed point version of the libc atan2() routine. It computes the
   arc tangent of `y / x', but the signs of both arguments are used to
   determine the quadrant of the result, and <tt>`x'</tt> is permitted to be zero. This
   function is useful to convert Cartesian coordinates to polar coordinates.
   Example:
<blockquote class="code"><pre>
      <a href="#fixed" class="autotype" title="Fixed point integer to replace floats.">fixed</a> result;
      
      /* Sets <tt>`result'</tt> to binary angle 64. */
      result = <a href="#fixatan2" class="autotype" title="Fixed point version of the libc atan2() routine.">fixatan2</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(1), 0);
      /* Sets <tt>`result'</tt> to binary angle -109. */
      result = <a href="#fixatan2" class="autotype" title="Fixed point version of the libc atan2() routine.">fixatan2</a>(<a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-1), <a href="#itofix" class="autotype" title="Converts an integer to fixed point.">itofix</a>(-2));
      /* Fails the assert. */
      result = <a href="#fixatan2" class="autotype" title="Fixed point version of the libc atan2() routine.">fixatan2</a>(0, 0);
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(!errno);</pre></blockquote>
<p><b>Return value:</b>
   Returns the arc tangent of `y / x' in fixed point binary format angle,
   from `-128' to <tt>`128'</tt>. If both <tt>`x'</tt> and <tt>`y'</tt> are zero, returns zero and sets
   <tt>`errno'</tt> to EDOM.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixsqrt">fixsqrt</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x);</b></div><br>
   This finds out the non negative square root of <tt>`x'</tt>. If <tt>`x'</tt> is negative,
   <tt>`errno'</tt> is set to EDOM and the function returns zero.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exfixed" title="Using fixed point maths.">exfixed</a>,
<a class="eref" href="#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="fixhypot">fixhypot</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y);</b></div><br>
   Fixed point hypotenuse (returns the square root of `x*x + y*y'). This
   should be better than calculating the formula yourself manually, since
   the error is much smaller.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#Fixed point trig" title="">Fixed point trig</a>.</blockquote>
<br><center><h2><a name="Fix class">Fix class</a></h2></center><p>
If you are programming in C++ you can ignore all the above and use the fix 
class instead, which overloads a lot of operators to provide automatic 
conversion to and from integer and floating point values, and calls the 
above routines as they are required. You should not mix the fix class with 
the fixed typedef though, because the compiler will mistake the fixed values 
for regular integers and insert unnecessary conversions. For example, if x 
is an object of class fix, calling fixsqrt(x) will return the wrong result. 
You should use the overloaded sqrt(x) or x.sqrt() instead.

<p>
On top of that, the Fix class may be slower than using directly the C
functions because of implicit internal conversions from one type to another
which you otherwise could avoid or minimise. Finally, this is the only bit
of C++ in the whole Allegro library, and the developers are certainly going
to move it into add-on space in the next version of Allegro which breaks
source backwards compatibility.



<p><br>
<h1><a name="3D math routines">3D math routines</a></h1>

<p>
Allegro contains some 3d helper functions for manipulating vectors, 
constructing and using transformation matrices, and doing perspective 
projections from 3d space onto the screen. It is not, and never will be, a 
fully fledged 3d library (the goal is to supply generic support routines,
not shrink-wrapped graphics code :-) but these functions may be useful for 
developing your own 3d code.

<p>
Allegro uses a right-handed coordinate system, i.e. if you point the thumb 
of your right hand along the x axis, and the index finger along the y axis, 
your middle finger points in the direction of the z axis.

<p>
Allegro's world coordinate system typically has the positive x axis right,
the positive y axis up, and the positive z axis out of the screen.  What
all this means is this: Assume, the viewer is located at the origin (0/0/0)
in world space, looks along the negative z axis (0/0/-1), and is oriented
so up is along the positive y axis (0/1/0). Then something located at
(100/200/-300) will be 100 to the right, 200 above, and 300 in front of the
viewer. Just like in OpenGL. (Of course, both OpenGL and Allegro allow to
use a different system.) Here's a short piece of code demonstrating the
transformation pipeline of a point from world space to the screen.

<blockquote class="code"><pre>
   /* First, set up the projection viewport. */
   <a href="#set_projection_viewport" class="autotype" title="Sets the viewport used to scale the output of persp_project().">set_projection_viewport</a> (0, 0, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
  
   /* Next, get a camera matrix, depending on the
    * current viewer position and orientation.
    */
   <a href="#get_camera_matrix_f" class="autotype" title="Floating point version of get_camera_matrix().">get_camera_matrix_f</a> (&amp;m,
      0, 0, 0,  /* Viewer position, in this case, 0/0/0. */
      0, 0, -1, /* Viewer direction, in this case along negative z. */
      0, 1, 0,  /* Up vector, in this case positive y. */
      32,       /* The FOV, here 45. */
      (float)<a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a> / (float)<a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>)); /* Aspect ratio. */
  
   /* Applying the matrix transforms the point 100/200/-300
    * from world space into camera space. The transformation
    * moves and rotates the point so it is relative to the
    * camera, scales it according to the FOV and aspect
    * parameters, and also flips up and front direction -
    * ready to project the point to the viewport.
    */
   <a href="#apply_matrix_f" class="autotype" title="Multiplies a point by a transformation matrix.">apply_matrix_f</a> (&amp;m, 100, 200, -300, &amp;x, &amp;y, &amp;z);
  
   /* Finally, the point is projected from
    * camera space to the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>.
    */
   <a href="#persp_project_f" class="autotype" title="Projects a 3d point into 2d screen space.">persp_project_f</a> (cx, cy, cz, &amp;sx, &amp;sy);</pre></blockquote>

<p>
For more details, look at the function descriptions of
set_projection_viewport(), get_camera_matrix(), and persp_project(), as well
as the relevant example programs.

<p>
All the 3d math functions are available in two versions: one which uses 
fixed point arithmetic, and another which uses floating point. The syntax 
for these is identical, but the floating point functions and structures are 
postfixed with '_f', eg. the fixed point function cross_product() has a 
floating point equivalent cross_product_f(). If you are programming in C++, 
Allegro also overloads these functions for use with the 'fix' class.

<p>
3d transformations are accomplished by the use of a modelling matrix. This 
is a 4x4 array of numbers that can be multiplied with a 3d point to produce 
a different 3d point. By putting the right values into the matrix, it can be 
made to do various operations like translation, rotation, and scaling. The 
clever bit is that you can multiply two matrices together to produce a third 
matrix, and this will have the same effect on points as applying the 
original two matrices one after the other. For example, if you have one 
matrix that rotates a point and another that shifts it sideways, you can 
combine them to produce a matrix that will do the rotation and the shift in 
a single step. You can build up extremely complex transformations in this 
way, while only ever having to multiply each point by a single matrix.

<p>
Allegro actually cheats in the way it implements the matrix structure. 
Rotation and scaling of a 3d point can be done with a simple 3x3 matrix, but 
in order to translate it and project it onto the screen, the matrix must be 
extended to 4x4, and the point extended into 4d space by the addition of an 
extra coordinate, w=1. This is a bad thing in terms of efficiency, but 
fortunately an optimisation is possible. Given the 4x4 matrix:
<blockquote class="text"><pre>
   ( a, b, c, d )
   ( e, f, g, h )
   ( i, j, k, l )
   ( m, n, o, p )
</pre></blockquote>
a pattern can be observed in which parts of it do what. The top left 3x3 
grid implements rotation and scaling. The three values in the top right 
column (d, h, and l) implement translation, and as long as the matrix is 
only used for affine transformations, m, n and o will always be zero and p 
will always be 1. If you don't know what affine means, read Foley &amp; Van 
Damme: basically it covers scaling, translation, and rotation, but not 
projection. Since Allegro uses a separate function for projection, the 
matrix functions only need to support affine transformations, which means 
that there is no need to store the bottom row of the matrix. Allegro 
implicitly assumes that it contains (0,0,0,1), and optimises the matrix 
manipulation functions accordingly. Read chapter "Structures and types
defined by Allegro" for an internal view of the MATRIX/_f structures.

<p><br>
<div class="al-api"><b>extern <a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> <a name="identity_matrix">identity_matrix</a>;</b></div><br>
<div class="al-api-cont"><b>extern <a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> <a name="identity_matrix_f">identity_matrix_f</a>;</b></div><br>
   Global variables containing the 'do nothing' identity matrix. Multiplying 
   by the identity matrix has no effect.

<p><br>
<div class="al-api"><b>void <a name="get_translation_matrix">get_translation_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> z);</b></div><br>
<div class="al-api-cont"><b>void <a name="get_translation_matrix_f">get_translation_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float x, float y, float z);</b></div><br>
   Constructs a translation matrix, storing it in m. When applied to the 
   point (px, py, pz), this matrix will produce the point (px+x, py+y, 
   pz+z). In other words, it moves things sideways.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#get_transformation_matrix" title="Constructs X, Y, Z rotation matrices with an angle and scaling.">get_transformation_matrix</a>,
<a class="xref" href="#qtranslate_matrix" title="Optimised routine for translating an already generated matrix.">qtranslate_matrix</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b>void <a name="get_scaling_matrix">get_scaling_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> z);</b></div><br>
<div class="al-api-cont"><b>void <a name="get_scaling_matrix_f">get_scaling_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float x, float y, float z);</b></div><br>
   Constructs a scaling matrix, storing it in m. When applied to the point 
   (px, py, pz), this matrix will produce the point (px*x, py*y, pz*z). In 
   other words, it stretches or shrinks things.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#get_transformation_matrix" title="Constructs X, Y, Z rotation matrices with an angle and scaling.">get_transformation_matrix</a>,
<a class="xref" href="#qscale_matrix" title="Optimised routine for scaling an already generated matrix.">qscale_matrix</a>.</blockquote>
<div class="al-api"><b>void <a name="get_x_rotate_matrix">get_x_rotate_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> r);</b></div><br>
<div class="al-api-cont"><b>void <a name="get_x_rotate_matrix_f">get_x_rotate_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float r);</b></div><br>
   Construct X axis rotation matrices, storing them in m. When applied to a 
   point, these matrices will rotate it about the X axis by the specified 
   angle (given in binary, 256 degrees to a circle format).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#get_rotation_matrix" title="Constructs X, Y, Z rotation matrices.">get_rotation_matrix</a>,
<a class="xref" href="#get_y_rotate_matrix" title="Construct Y axis rotation matrices.">get_y_rotate_matrix</a>,
<a class="xref" href="#get_z_rotate_matrix" title="Construct Z axis rotation matrices.">get_z_rotate_matrix</a>.</blockquote>
<div class="al-api"><b>void <a name="get_y_rotate_matrix">get_y_rotate_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> r);</b></div><br>
<div class="al-api-cont"><b>void <a name="get_y_rotate_matrix_f">get_y_rotate_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float r);</b></div><br>
   Construct Y axis rotation matrices, storing them in m. When applied to a 
   point, these matrices will rotate it about the Y axis by the specified 
   angle (given in binary, 256 degrees to a circle format).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#get_rotation_matrix" title="Constructs X, Y, Z rotation matrices.">get_rotation_matrix</a>,
<a class="xref" href="#get_x_rotate_matrix" title="Construct X axis rotation matrices.">get_x_rotate_matrix</a>,
<a class="xref" href="#get_z_rotate_matrix" title="Construct Z axis rotation matrices.">get_z_rotate_matrix</a>.</blockquote>
<div class="al-api"><b>void <a name="get_z_rotate_matrix">get_z_rotate_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> r);</b></div><br>
<div class="al-api-cont"><b>void <a name="get_z_rotate_matrix_f">get_z_rotate_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float r);</b></div><br>
   Construct Z axis rotation matrices, storing them in m. When applied to a 
   point, these matrices will rotate it about the Z axis by the specified 
   angle (given in binary, 256 degrees to a circle format).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#get_rotation_matrix" title="Constructs X, Y, Z rotation matrices.">get_rotation_matrix</a>,
<a class="xref" href="#get_x_rotate_matrix" title="Construct X axis rotation matrices.">get_x_rotate_matrix</a>,
<a class="xref" href="#get_y_rotate_matrix" title="Construct Y axis rotation matrices.">get_y_rotate_matrix</a>.</blockquote>
<div class="al-api"><b>void <a name="get_rotation_matrix">get_rotation_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> z);</b></div><br>
<div class="al-api-cont"><b>void <a name="get_rotation_matrix_f">get_rotation_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float x, float y, float z);</b></div><br>
   Constructs a transformation matrix which will rotate points around all
   three axes by the specified amounts (given in binary, 256 degrees to a
   circle format). The direction of rotation can simply be found out with
   the right-hand rule: Point the dumb of your right hand towards the
   origin along the axis of rotation, and the fingers will curl in the
   positive direction of rotation. E.g. if you rotate around the y axis,
   and look at the scene from above, a positive angle will rotate in
   clockwise direction.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#get_transformation_matrix" title="Constructs X, Y, Z rotation matrices with an angle and scaling.">get_transformation_matrix</a>,
<a class="xref" href="#get_vector_rotation_matrix" title="Constructs X, Y, Z rotation matrices with an angle.">get_vector_rotation_matrix</a>,
<a class="xref" href="#get_x_rotate_matrix" title="Construct X axis rotation matrices.">get_x_rotate_matrix</a>,
<a class="xref" href="#get_y_rotate_matrix" title="Construct Y axis rotation matrices.">get_y_rotate_matrix</a>,
<a class="xref" href="#get_z_rotate_matrix" title="Construct Z axis rotation matrices.">get_z_rotate_matrix</a>,
<a class="xref" href="#get_align_matrix" title="Rotates a matrix to align it along specified coordinate vectors.">get_align_matrix</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b>void <a name="get_align_matrix">get_align_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> xfront, yfront, zfront, 
                                 <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> xup, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> yup, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> zup);</b></div><br>
   Rotates a matrix so that it is aligned along the specified coordinate 
   vectors (they need not be normalized or perpendicular, but the up and 
   front must not be equal). A front vector of 0,0,-1 and up vector of 0,1,0 
   will return the identity matrix.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#get_camera_matrix" title="Constructs a camera matrix for perspective projection.">get_camera_matrix</a>.</blockquote>
<div class="al-api"><b>void <a name="get_align_matrix_f">get_align_matrix_f</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, float xfront, yfront, zfront, 
                                   float xup, yup, zup);</b></div><br>
   Floating point version of get_align_matrix().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_align_matrix" title="Rotates a matrix to align it along specified coordinate vectors.">get_align_matrix</a>.</blockquote>
<div class="al-api"><b>void <a name="get_vector_rotation_matrix">get_vector_rotation_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, y, z, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> a);</b></div><br>
<div class="al-api-cont"><b>void <a name="get_vector_rotation_matrix_f">get_vector_rotation_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float x, y, z, float a);</b></div><br>
   Constructs a transformation matrix which will rotate points around the 
   specified x,y,z vector by the specified angle (given in binary, 256 
   degrees to a circle format).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#get_rotation_matrix" title="Constructs X, Y, Z rotation matrices.">get_rotation_matrix</a>,
<a class="xref" href="#get_align_matrix" title="Rotates a matrix to align it along specified coordinate vectors.">get_align_matrix</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>.</blockquote>
<div class="al-api"><b>void <a name="get_transformation_matrix">get_transformation_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> scale,
                               <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> xrot, yrot, zrot, x, y, z);</b></div><br>
   Constructs a transformation matrix which will rotate points around all 
   three axes by the specified amounts (given in binary, 256 degrees to a 
   circle format), scale the result by the specified amount (pass 1 for no 
   change of scale), and then translate to the requested x, y, z position.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#get_rotation_matrix" title="Constructs X, Y, Z rotation matrices.">get_rotation_matrix</a>,
<a class="xref" href="#get_scaling_matrix" title="Constructs a scaling matrix.">get_scaling_matrix</a>,
<a class="xref" href="#get_translation_matrix" title="Constructs a translation matrix.">get_translation_matrix</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b>void <a name="get_transformation_matrix_f">get_transformation_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float scale,
                                 float xrot, yrot, zrot, x, y, z);</b></div><br>
   Floating point version of get_transformation_matrix().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_transformation_matrix" title="Constructs X, Y, Z rotation matrices with an angle and scaling.">get_transformation_matrix</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>void <a name="get_camera_matrix">get_camera_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, y, z, xfront, yfront, zfront,
                       <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> xup, yup, zup, fov, aspect);</b></div><br>
   Constructs a camera matrix for translating world-space objects into a
   normalised view space, ready for the perspective projection. The x, y,
   and z parameters specify the camera position, xfront, yfront, and zfront
   are the 'in front' vector specifying which way the camera is facing
   (this can be any length: normalisation is not required), and xup, yup,
   and zup are the 'up' direction vector.

<p>
   The fov parameter specifies the field of view (ie. width of the camera
   focus) in binary, 256 degrees to the circle format. For typical
   projections, a field of view in the region 32-48 will work well. 64
   (90) applies no extra scaling - so something which is one unit away
   from the viewer will be directly scaled to the viewport. A bigger FOV
   moves you closer to the viewing plane, so more objects will appear. A
   smaller FOV moves you away from the viewing plane, which means you see a
   smaller part of the world.

<p>
   Finally, the aspect ratio is used to scale the Y dimensions of the image
   relative to the X axis, so you can use it to adjust the proportions of
   the output image (set it to 1 for no scaling - but keep in mind that the
   projection also performs scaling according to the viewport size).
   Typically, you will pass (float)w/(float)h, where w and h are the
   parameters you passed to set_projection_viewport.

<p>
   Note that versions prior to 4.1.0 multiplied this aspect ratio by 4/3.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#get_align_matrix" title="Rotates a matrix to align it along specified coordinate vectors.">get_align_matrix</a>,
<a class="xref" href="#set_projection_viewport" title="Sets the viewport used to scale the output of persp_project().">set_projection_viewport</a>,
<a class="xref" href="#persp_project" title="Projects a 3d point into 2d screen space.">persp_project</a>.</blockquote>
<div class="al-api"><b>void <a name="get_camera_matrix_f">get_camera_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float x, y, z, xfront, yfront, zfront,
                         float xup, yup, zup, fov, aspect);</b></div><br>
   Floating point version of get_camera_matrix().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_camera_matrix" title="Constructs a camera matrix for perspective projection.">get_camera_matrix</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>,
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>.</blockquote>
<div class="al-api"><b>void <a name="qtranslate_matrix">qtranslate_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> z);</b></div><br>
<div class="al-api-cont"><b>void <a name="qtranslate_matrix_f">qtranslate_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float x, float y, float z);</b></div><br>
   Optimised routine for translating an already generated matrix: this 
   simply adds in the translation offset, so there is no need to build two 
   temporary matrices and then multiply them together.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_translation_matrix" title="Constructs a translation matrix.">get_translation_matrix</a>.</blockquote>
<div class="al-api"><b>void <a name="qscale_matrix">qscale_matrix</a>(<a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> scale);</b></div><br>
<div class="al-api-cont"><b>void <a name="qscale_matrix_f">qscale_matrix_f</a>(<a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float scale);</b></div><br>
   Optimised routine for scaling an already generated matrix: this simply 
   adds in the scale factor, so there is no need to build two temporary 
   matrices and then multiply them together.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_scaling_matrix" title="Constructs a scaling matrix.">get_scaling_matrix</a>.</blockquote>
<div class="al-api"><b>void <a name="matrix_mul">matrix_mul</a>(const <a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m1, const <a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m2, <a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *out);</b></div><br>
<div class="al-api-cont"><b>void <a name="matrix_mul_f">matrix_mul_f</a>(const <a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m1, const <a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m2, <a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *out);</b></div><br>
   Multiplies two matrices, storing the result in out (this may be a 
   duplicate of one of the input matrices, but it is faster when the inputs 
   and output are all different). The resulting matrix will have the same 
   effect as the combination of m1 and m2, ie. when applied to a point p, (p 
   * out) = ((p * m1) * m2). Any number of transformations can be 
   concatenated in this way. Note that matrix multiplication is not 
   commutative, ie. matrix_mul(m1, m2) != matrix_mul(m2, m1).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="vector_length">vector_length</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> z);</b></div><br>
<div class="al-api-cont"><b>float <a name="vector_length_f">vector_length_f</a>(float x, float y, float z);</b></div><br>
   Calculates the length of the vector (x, y, z), using that good 'ole 
   Pythagoras theorem.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#normalize_vector" title="Converts the vector to a unit vector.">normalize_vector</a>.</blockquote>
<div class="al-api"><b>void <a name="normalize_vector">normalize_vector</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> *x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> *y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> *z);</b></div><br>
<div class="al-api-cont"><b>void <a name="normalize_vector_f">normalize_vector_f</a>(float *x, float *y, float *z);</b></div><br>
   Converts the vector (*x, *y, *z) to a unit vector. This points in the 
   same direction as the original vector, but has a length of one.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#vector_length" title="Calculates the length of a vector.">vector_length</a>,
<a class="xref" href="#dot_product" title="Calculates the dot product.">dot_product</a>,
<a class="xref" href="#cross_product" title="Calculates the cross product.">cross_product</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="dot_product">dot_product</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x1, y1, z1, x2, y2, z2);</b></div><br>
<div class="al-api-cont"><b>float <a name="dot_product_f">dot_product_f</a>(float x1, y1, z1, x2, y2, z2);</b></div><br>
   Calculates the dot product (x1, y1, z1) . (x2, y2, z2), returning the 
   result.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#cross_product" title="Calculates the cross product.">cross_product</a>,
<a class="xref" href="#normalize_vector" title="Converts the vector to a unit vector.">normalize_vector</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b>void <a name="cross_product">cross_product</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x1, y1, z1, x2, y2, z2, *xout, *yout, *zout);</b></div><br>
<div class="al-api-cont"><b>void <a name="cross_product_f">cross_product_f</a>(float x1, y1, z1, x2, y2, z2, *xout, *yout, *zout);</b></div><br>
   Calculates the cross product (x1, y1, z1) x (x2, y2, z2), storing the 
   result in (*xout, *yout, *zout). The cross product is perpendicular to 
   both of the input vectors, so it can be used to generate polygon normals.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#dot_product" title="Calculates the dot product.">dot_product</a>,
<a class="xref" href="#polygon_z_normal" title="Finds the Z component of the normal vector to three vertices.">polygon_z_normal</a>,
<a class="xref" href="#normalize_vector" title="Converts the vector to a unit vector.">normalize_vector</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> <a name="polygon_z_normal">polygon_z_normal</a>(const <a class="autotype" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a> *v1, const <a class="autotype" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a> *v2, const <a class="autotype" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a> *v3);</b></div><br>
<div class="al-api-cont"><b>float <a name="polygon_z_normal_f">polygon_z_normal_f</a>(const <a class="autotype" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a> *v1, const <a class="autotype" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a> *v2, const <a class="autotype" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a> *v3);</b></div><br>
   Finds the Z component of the normal vector to the specified three 
   vertices (which must be part of a convex polygon). This is used mainly in 
   back-face culling. The back-faces of closed polyhedra are never visible 
   to the viewer, therefore they never need to be drawn. This can cull on 
   average half the polygons from a scene. If the normal is negative the 
   polygon can safely be culled. If it is zero, the polygon is perpendicular 
   to the screen.

<p>
   However, this method of culling back-faces must only be used once the X and
   Y coordinates have been projected into screen space using persp_project()
   (or if an orthographic (isometric) projection is being used). Note that
   this function will fail if the three vertices are co-linear (they lie on
   the same line) in 3D space.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#cross_product" title="Calculates the cross product.">cross_product</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>.</blockquote>
<div class="al-api"><b>void <a name="apply_matrix">apply_matrix</a>(const <a class="autotype" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a> *m, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, y, z, *xout, *yout, *zout);</b></div><br>
<div class="al-api-cont"><b>void <a name="apply_matrix_f">apply_matrix_f</a>(const <a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, float x, y, z, *xout, *yout, *zout);</b></div><br>
   Multiplies the point (x, y, z) by the transformation matrix m, storing 
   the result in (*xout, *yout, *zout).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#matrix_mul" title="Multiplies two matrices.">matrix_mul</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<div class="al-api"><b>void <a name="set_projection_viewport">set_projection_viewport</a>(int x, int y, int w, int h);</b></div><br>
   Sets the viewport used to scale the output of the persp_project()
   function. Pass the dimensions of the screen area you want to draw onto,
   which will typically be 0, 0, SCREEN_W, and SCREEN_H. Also don't forget
   to pass an appropriate aspect ratio to get_camera_matrix later. The
   width and height you specify here will determine how big your viewport
   is in 3d space. So if an object in your 3D space is w units wide, it
   will fill the complete screen when you run into it (i.e., if it has a
   distance of 1.0 after the camera matrix was applied. The fov and
   aspect-ratio parameters to get_camera_matrix also apply some scaling
   though, so this isn't always completely true). If you pass -1/-1/2/2 as
   parameters, no extra scaling will be performed by the projection.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#persp_project" title="Projects a 3d point into 2d screen space.">persp_project</a>,
<a class="xref" href="#get_camera_matrix" title="Constructs a camera matrix for perspective projection.">get_camera_matrix</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>,
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>void <a name="persp_project">persp_project</a>(<a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> x, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> y, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> z, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> *xout, <a class="autotype" href="#fixed" title="Fixed point integer to replace floats.">fixed</a> *yout);</b></div><br>
<div class="al-api-cont"><b>void <a name="persp_project_f">persp_project_f</a>(float x, float y, float z, float *xout, float *yout);</b></div><br>
   Projects the 3d point (x, y, z) into 2d screen space, storing the result 
   in (*xout, *yout) and using the scaling parameters previously set by 
   calling set_projection_viewport(). This function projects from the 
   normalized viewing pyramid, which has a camera at the origin and facing 
   along the positive z axis. The x axis runs left/right, y runs up/down, 
   and z increases with depth into the screen. The camera has a 90 degree 
   field of view, ie. points on the planes x=z and -x=z will map onto the 
   left and right edges of the screen, and the planes y=z and -y=z map to 
   the top and bottom of the screen. If you want a different field of view 
   or camera location, you should transform all your objects with an 
   appropriate viewing matrix, eg. to get the effect of panning the camera 
   10 degrees to the left, rotate all your objects 10 degrees to the right.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_projection_viewport" title="Sets the viewport used to scale the output of persp_project().">set_projection_viewport</a>,
<a class="xref" href="#get_camera_matrix" title="Constructs a camera matrix for perspective projection.">get_camera_matrix</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exstars" title="3d starfield and lightsourced spaceship.">exstars</a>.</blockquote>
<h1><a name="Quaternion math routines">Quaternion math routines</a></h1>

<p>
Quaternions are an alternate way to represent the rotation part of a
transformation, and can be easier to manipulate than matrices. As with a 
matrix, you can encode a geometric transformations in one, concatenate 
several of them to merge multiple transformations, and apply them to a 
vector, but they can only store pure rotations. The big advantage is that 
you can accurately interpolate between two quaternions to get a part-way 
rotation, avoiding the gimbal problems of the more conventional Euler angle 
interpolation.

<p>
Quaternions only have floating point versions, without any _f suffix. Other 
than that, most of the quaternion functions correspond with a matrix 
function that performs a similar operation.

<p>
Quaternion means 'of four parts', and that's exactly what it is. Here is the 
structure:
<blockquote class="code"><pre>
   typedef struct <a href="#QUAT" class="autotype" title="Stores quaternion information.">QUAT</a>
   {
      float w, x, y, z;
   }
</pre></blockquote>
You will have lots of fun figuring out what these numbers actually mean, but 
that is beyond the scope of this documentation. Quaternions do work -- trust 
me.

<p><br>
<div class="al-api"><b>extern <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> <a name="identity_quat">identity_quat</a>;</b></div><br>
   Global variable containing the 'do nothing' identity quaternion. 
   Multiplying by the identity quaternion has no effect.

<p><br>
<div class="al-api"><b>void <a name="get_x_rotate_quat">get_x_rotate_quat</a>(<a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *q, float r);</b></div><br>
<div class="al-api-cont"><b>void <a name="get_y_rotate_quat">get_y_rotate_quat</a>(<a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *q, float r);</b></div><br>
<div class="al-api-cont"><b>void <a name="get_z_rotate_quat">get_z_rotate_quat</a>(<a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *q, float r);</b></div><br>
   Construct axis rotation quaternions, storing them in q. When applied to a 
   point, these quaternions will rotate it about the relevant axis by the 
   specified angle (given in binary, 256 degrees to a circle format).

<p><br>
<div class="al-api"><b>void <a name="get_rotation_quat">get_rotation_quat</a>(<a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *q, float x, float y, float z);</b></div><br>
   Constructs a quaternion that will rotate points around all three axes by 
   the specified amounts (given in binary, 256 degrees to a circle format).


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>.</blockquote>
<div class="al-api"><b>void <a name="get_vector_rotation_quat">get_vector_rotation_quat</a>(<a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *q, float x, y, z, float a);</b></div><br>
   Constructs a quaternion that will rotate points around the specified 
   x,y,z vector by the specified angle (given in binary, 256 degrees to a 
   circle format).

<p><br>
<div class="al-api"><b>void <a name="quat_to_matrix">quat_to_matrix</a>(const <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *q, <a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m);</b></div><br>
   Constructs a rotation matrix from a quaternion.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>.</blockquote>
<div class="al-api"><b>void <a name="matrix_to_quat">matrix_to_quat</a>(const <a class="autotype" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a> *m, <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *q);</b></div><br>
   Constructs a quaternion from a rotation matrix. Translation is discarded 
   during the conversion. Use get_align_matrix_f() if the matrix is not 
   orthonormalized, because strange things may happen otherwise.

<p><br>
<div class="al-api"><b>void <a name="quat_mul">quat_mul</a>(const <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *p, const <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *q, <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *out);</b></div><br>
   Multiplies two quaternions, storing the result in out. The resulting 
   quaternion will have the same effect as the combination of p and q, ie. 
   when applied to a point, (point * out) = ((point * p) * q). Any number of 
   rotations can be concatenated in this way. Note that quaternion 
   multiplication is not commutative, ie. quat_mul(p, q) != quat_mul(q, p). 

<p><br>
<div class="al-api"><b>void <a name="apply_quat">apply_quat</a>(const <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *q, float x, y, z, *xout, *yout, *zout);</b></div><br>
   Multiplies the point (x, y, z) by the quaternion q, storing the result in 
   (*xout, *yout, *zout). This is quite a bit slower than apply_matrix_f(), 
   so only use it to translate a few points. If you have many points, it is 
   much more efficient to call quat_to_matrix() and then use 
   apply_matrix_f().

<p><br>
<div class="al-api"><b>void <a name="quat_interpolate">quat_interpolate</a>(const <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *from, const <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *to, float t, <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *out);</b></div><br>
   Constructs a quaternion that represents a rotation between from and to. 
   The argument t can be anything between 0 and 1 and represents where 
   between from and to the result will be. 0 returns from, 1 returns to, and 
   0.5 will return a rotation exactly in between. The result is copied to 
   out. This function will create the short rotation (less than 180 degrees) 
   between from and to.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>.</blockquote>
<div class="al-api"><b>void <a name="quat_slerp">quat_slerp</a>(const <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *from, const <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *to, float t, <a class="autotype" href="#QUAT" title="Stores quaternion information.">QUAT</a> *out, int how);</b></div><br>
   The same as quat_interpolate(), but allows more control over how the 
   rotation is done. The how parameter can be any one of the values:
<blockquote class="text"><pre>
      QUAT_SHORT  - like quat_interpolate(), use shortest path
      QUAT_LONG   - rotation will be greater than 180 degrees
      QUAT_CW     - rotate clockwise when viewed from above
      QUAT_CCW    - rotate counterclockwise when viewed from above
      QUAT_USER   - the quaternions are interpolated exactly as
                    given
</pre></blockquote>


<p><br>
<h1><a name="GUI routines">GUI routines</a></h1>

<p>
Allegro contains an object-oriented dialog manager, which was originally 
based on the Atari GEM system (form_do(), objc_draw(), etc: old ST 
programmers will know what we are talking about :-) You can use the GUI as-is
to knock out simple interfaces for things like the test program and grabber 
utility, or you can use it as a basis for more complicated systems of your 
own. Allegro lets you define your own object types by writing new dialog 
procedures, so you can take complete control over the visual aspects of the 
interface while still using Allegro to handle input from the mouse, 
keyboard, joystick, etc.

<p>
A GUI dialog is stored as an array of DIALOG objects, read chapter
"Structures and types defined by Allegro" for an internal description of the
DIALOG structure. The array should end with an object which has the proc
pointer set to NULL. Each object has a flags field which may contain any
combination of the bit flags:
<blockquote class="text"><pre>
   D_EXIT          - this object should close the dialog when it is
                     clicked
   D_SELECTED      - this object is selected
   D_GOTFOCUS      - this object has got the input focus
   D_GOTMOUSE      - the mouse is currently on top of this object
   D_HIDDEN        - this object is hidden and inactive
   D_DISABLED      - this object is greyed-out and inactive
   D_DIRTY         - this object needs to be redrawn
   D_INTERNAL      - don't use this! It is for internal use by the
                     library...
   D_USER          - any powers of two above this are free for your
                     own use
</pre></blockquote>
Each object is controlled by a dialog procedure, which is stored in the proc 
pointer. This will be called by the dialog manager whenever any action 
concerning the object is required, or you can call it directly with the 
object_message() function. The dialog procedure should follow the form:
<blockquote class="code"><pre>
   int foo(int msg, <a href="#DIALOG" class="autotype" title="Stores a GUI description.">DIALOG</a> *d, int c);
</pre></blockquote>
It will be passed a flag (msg) indicating what action it should perform, a 
pointer to the object concerned (d), and if msg is MSG_CHAR or MSG_XCHAR, 
the key that was pressed (c). Note that d is a pointer to a specific object, 
and not to the entire dialog.

<p>
The dialog procedure should return one of the values:
<blockquote class="text"><pre>
   D_O_K          - normal return status
   D_CLOSE        - tells the dialog manager to close the dialog
   D_REDRAW       - tells the dialog manager to redraw the entire
                    dialog
   D_REDRAWME     - tells the dialog manager to redraw the current
                    object
   D_WANTFOCUS    - requests that the input focus be given to this
                    object
   D_USED_CHAR    - MSG_CHAR and MSG_XCHAR return this if they used
                    the key
</pre></blockquote>
Dialog procedures may be called with any of the messages:

<p>
<b>MSG_START:</b><br>
   Tells the object to initialise itself. The dialog manager sends this to 
   all the objects in a dialog just before it displays the dialog.

<p>
<b>MSG_END:</b><br>
   Sent to all objects when closing a dialog, allowing them to perform 
   whatever cleanup operations they require.

<p>
<b>MSG_DRAW:</b><br>
   Tells the object to draw itself onto the screen. The mouse pointer will 
   be turned off when this message is sent, so the drawing code does not 
   need to worry about it.

<p>
<b>MSG_CLICK:</b><br>
   Informs the object that a mouse button has been clicked while the mouse 
   was on top of the object. Typically an object will perform its own mouse 
   tracking as long as the button is held down, and only return from this 
   message handler when it is released.

<p>
   If you process this message, use the functions gui_mouse_*() to read the
   state of the mouse.

<p>
<b>MSG_DCLICK:</b><br>
   Sent when the user double-clicks on an object. A MSG_CLICK will be sent 
   when the button is first pressed, then MSG_DCLICK if it is released and 
   pressed again within a short space of time.

<p>
   If you process this message, use the functions gui_mouse_*() to read the
   state of the mouse.

<p>
<b>MSG_KEY:</b><br>
   Sent when the keyboard shortcut for the object is pressed, or if enter, 
   space, or a joystick button is pressed while it has the input focus.

<p>
<b>MSG_CHAR:</b><br>
   When a key is pressed, this message is sent to the object that has the 
   input focus, with a readkey() format character code (ASCII value in the 
   low byte, scancode in the high byte) as the c parameter. If the object 
   deals with the keypress it should return D_USED_CHAR, otherwise it should 
   return D_O_K to allow the default keyboard interface to operate. If you 
   need to access Unicode character input, you should use MSG_UCHAR instead 
   of MSG_CHAR.

<p>
<b>MSG_UCHAR:</b><br>
   If an object ignores the MSG_CHAR input, this message will be sent 
   immediately after it, passed the full Unicode key value as the c 
   parameter. This enables you to read character codes greater than 255, but 
   cannot tell you anything about the scancode: if you need to know that, 
   use MSG_CHAR instead. This handler should return D_USED_CHAR if it 
   processed the input, or D_O_K otherwise.

<p>
<b>MSG_XCHAR:</b><br>
   When a key is pressed, Allegro will send a MSG_CHAR and MSG_UCHAR to the 
   object with the input focus. If this object doesn't process the key (ie. 
   it returns D_O_K rather than D_USED_CHAR), the dialog manager will look 
   for an object with a matching keyboard shortcut in the key field, and 
   send it a MSG_KEY. If this fails, it broadcasts a MSG_XCHAR to all 
   objects in the dialog, allowing them to respond to special keypresses 
   even when they don't have the input focus. Normally you should ignore 
   this message (return D_O_K rather than D_USED_CHAR), in which case 
   Allegro will perform default actions such as moving the focus in response 
   to the arrow keys and closing the dialog if ESC is pressed.

<p>
<b>MSG_WANTFOCUS:</b><br>
   Queries whether an object is willing to accept the input focus. It should 
   return D_WANTFOCUS if it does, or D_O_K if it isn't interested in getting 
   user input.

<p>
<b>MSG_GOTFOCUS:</b><br>
<b>MSG_LOSTFOCUS:</b><br>
   Sent whenever an object gains or loses the input focus. These messages 
   will always be followed by a MSG_DRAW, to let objects display themselves 
   differently when they have the input focus. If you return D_WANTFOCUS in 
   response to a MSG_LOSTFOCUS event, this will prevent your object from 
   losing the focus when the mouse moves off it onto the screen background 
   or some inert object, so it will only lose the input focus when some 
   other object is ready to take over the focus (this trick is used by the 
   d_edit_proc() object).

<p>
<b>MSG_GOTMOUSE:</b><br>
<b>MSG_LOSTMOUSE:</b><br>
   Sent when the mouse moves on top of or away from an object. Unlike the 
   focus messages, these are not followed by a MSG_DRAW, so if the object is 
   displayed differently when the mouse is on top of it, it is responsible 
   for redrawing itself in response to these messages.

<p>
<b>MSG_IDLE:</b><br>
   Sent whenever the dialog manager has nothing better to do.

<p>
<b>MSG_RADIO:</b><br>
   Sent by radio button objects to deselect other buttons in the same group 
   when they are clicked. The group number is passed in the c message 
   parameter.

<p>
<b>MSG_WHEEL:</b><br>
   Sent to the focused object whenever the mouse wheel moves. The c message 
   parameter contains the number of clicks.

<p>
<b>MSG_LPRESS, MSG_MPRESS, MSG_RPRESS:</b><br>
   Sent when the corresponding mouse button is pressed.

<p>
<b>MSG_LRELEASE, MSG_MRELEASE, MSG_RRELEASE:</b><br>
   Sent when the corresponding mouse button is released.

<p>
<b>MSG_USER:</b><br>
   The first free message value. Any numbers from here on (MSG_USER, 
   MSG_USER+1, MSG_USER+2, ... MSG_USER+n) are free to use for whatever you 
   like.

<p>
Allegro provides several standard dialog procedures. You can use these as 
they are to provide simple user interface objects, or you can call them from 
within your own dialog procedures, resulting in a kind of OOP inheritance. 
For instance, you could make an object which calls d_button_proc to draw 
itself, but handles the click message in a different way, or an object which 
calls d_button_proc for everything except drawing itself, so it would behave 
like a normal button but could look completely different.

<p>
Since the release of Allegro version 3.9.33 (CVS), some GUI objects and 
menus are being drawn differently unlike in previous Allegro versions. The 
changes are the following:
<ul><li>
   Shadows under d_shadow_box_proc and d_button_proc are always black.
<li>
   The most important (and immediately visible) change is, that some objects 
   are being drawn smaller. The difference is exactly one pixel in both 
   height and width, when comparing to previous versions. The reason is, 
   that in previous versions these objects were too large on the screen - 
   their size was d-&gt;w+1 and d-&gt;h+1 pixels (and not d-&gt;w and d-&gt;h, as it
   should be). This change affects the following objects :
<blockquote class="text"><pre>
      d_box_proc,
      d_shadow_box_proc,
      d_button_proc,
      d_check_proc,
      d_radio_proc,
      d_list_proc,
      d_text_list_proc and
      d_textbox_proc.
</pre></blockquote>
   When you want to convert old dialogs to look equally when compiling with 
   the new Allegro version, just increase the size of the mentioned objects 
   by one pixel in both width and height fields. 
<li>
   When a GUI menu item (not in a bar menu) has a child menu, there is a 
   small arrow next to the child menu name, pointing to the right - so the 
   user can immediately see that this menu item has a child menu - and 
   there is no need to use such menu item names as for example "New...", 
   to show that it has a child menu. The submenu will be drawn to the right 
   of the parent menu, trying not to overlap it.
</ul><br>

<p>
Menus had been forgotten during the changes for 3.9.33 (CVS), so they were
still drawn too large until version 4.1.0.

<p><br>
<div class="al-api"><b>int <a name="d_clear_proc">d_clear_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   This just clears the screen when it is drawn. Useful as the first object 
   in a dialog.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_box_proc">d_box_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="d_shadow_box_proc">d_shadow_box_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   These draw boxes onto the screen, with or without a shadow.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>.</blockquote>
<div class="al-api"><b>int <a name="d_bitmap_proc">d_bitmap_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   This draws a bitmap onto the screen, which should be pointed to by the 
   dp field.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>.</blockquote>
<div class="al-api"><b>int <a name="d_text_proc">d_text_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="d_ctext_proc">d_ctext_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
<div class="al-api-cont"><b>int <a name="d_rtext_proc">d_rtext_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   These draw text onto the screen. The dp field should point to the string 
   to display. d_ctext_proc() centers the string horizontally, and
   d_rtext_proc() right aligns it. Any '&amp;' characters in the string will 
   be replaced with lines underneath the following character, for displaying 
   keyboard shortcuts (as in MS Windows). To display a single ampersand, put 
   "&amp;&amp;". To draw the text in something other than the default font, set the 
   dp2 field to point to your custom font data.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>.</blockquote>
<div class="al-api"><b>int <a name="d_button_proc">d_button_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   A button object (the dp field points to the text string). This object can 
   be selected by clicking on it with the mouse or by pressing its keyboard 
   shortcut. If the D_EXIT flag is set, selecting it will close the dialog, 
   otherwise it will toggle on and off. Like d_text_proc(), ampersands can 
   be used to display the keyboard shortcut of the button.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_check_proc">d_check_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   This is an example of how you can derive objects from other objects. Most 
   of the functionality comes from d_button_proc(), but it displays itself 
   as a check box. If the d1 field is non-zero, the text will be printed to 
   the right of the check, otherwise it will be on the left.

<p>
   Note: the object width should allow space for the text as well as the
   check box (which is square, with sides equal to the object height).


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_radio_proc">d_radio_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   A radio button object. A dialog can contain any number of radio button 
   groups: selecting a radio button causes other buttons within the same 
   group to be deselected. The dp field points to the text string, d1 
   specifies the group number, and d2 is the button style (0=circle, 
   1=square).


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_icon_proc">d_icon_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   A bitmap button. The fg color is used for the dotted line showing focus, 
   and the bg color for the shadow used to fill in the top and left sides of 
   the button when "pressed". d1 is the "push depth", ie. the number of 
   pixels the icon will be shifted to the right and down when selected 
   (default 2) if there is no "selected" image. d2 is the distance by which 
   the dotted line showing focus is indented (default 2). dp points to a 
   bitmap for the icon, while dp2 and dp3 are the selected and disabled 
   images respectively (optional, may be NULL).


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_keyboard_proc">d_keyboard_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   This is an invisible object for implementing keyboard shortcuts. You can 
   put an ASCII code in the key field of the dialog object (a character such 
   as 'a' to respond to a simple keypress, or a number 1-26 to respond to a 
   control key a-z), or you can put a keyboard scancode in the d1 and/or d2 
   fields. When one of these keys is pressed, the object will call the 
   function pointed to by dp. This should return an int, which will be 
   passed back to the dialog manager, so it can return D_O_K, D_REDRAW, 
   D_CLOSE, etc.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_edit_proc">d_edit_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   An editable text object (the dp field points to the string). When it has 
   the input focus (obtained by clicking on it with the mouse), text can be 
   typed into this object. The d1 field specifies the maximum number of 
   characters that it will accept, and d2 is the text cursor position within 
   the string.
   
<p>
   Note: dp must point to a buffer at least (d1 + 1) * 4 bytes long because,
   depending on the encoding format in use, a single character can occupy
   up to 4 bytes and room must be reserved for the terminating null character.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_list_proc">d_list_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   A list box object. This will allow the user to scroll through a list of 
   items and to select one by clicking or with the arrow keys. If the D_EXIT 
   flag is set, double clicking on a list item will close the dialog. The 
   index of the selected item is held in the d1 field, and d2 is used to 
   store how far it has scrolled through the list. The dp field points to a 
   function which will be called to obtain information about the contents of 
   the list. This should follow the form:
<blockquote class="code"><pre>
      char *foobar(int index, int *list_size);
</pre></blockquote>
   If index is zero or positive, the function should return a pointer to the 
   string which is to be displayed at position index in the list. If index 
   is negative, it should return NULL and list_size should be set to the 
   number of items in the list. 

<p>
   To create a multiple selection listbox, set the dp2 field to an array of 
   byte flags indicating the selection state of each list item (non-zero for 
   selected entries). This table must be at least as big as the number of 
   objects in the list!


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_text_list_proc">d_text_list_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   Like d_list_proc, but allows the user to type in the first few characters 
   of a listbox entry in order to select it. Uses dp3 internally, so you 
   mustn't store anything important there yourself.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_textbox_proc">d_textbox_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   A text box object. The dp field points to the text which is to be 
   displayed in the box. If the text is long, there will be a vertical 
   scrollbar on the right hand side of the object which can be used to 
   scroll through the text. The default is to print the text with word 
   wrapping, but if the D_SELECTED flag is set, the text will be printed 
   with character wrapping. The d1 field is used internally to store the 
   number of lines of text, and d2 is used to store how far it has scrolled 
   through the text.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_slider_proc">d_slider_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   A slider control object. This object holds a value in d2, in the range 
   from 0 to d1. It will display as a vertical slider if h is greater than 
   or equal to w, otherwise it will display as a horizontal slider. The dp 
   field can contain an optional bitmap to use for the slider handle, and 
   dp2 can contain an optional callback function, which is called each time 
   d2 changes. The callback function should have the following prototype:
<blockquote class="code"><pre>
      int function(void *dp3, int d2);
</pre></blockquote>
   The d_slider_proc object will return the value of the callback function.


<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>.</blockquote>
<div class="al-api"><b>int <a name="d_menu_proc">d_menu_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   This object is a menu bar which will drop down child menus when it is 
   clicked or if an alt+key corresponding to one of the shortcuts in the 
   menu is pressed. It ignores a lot of the fields in the dialog structure, 
   in particular the color is taken from the gui_*_color variables, and the 
   width and height are calculated automatically (the w and h fields from 
   the DIALOG are only used as a minimum size.) The dp field points to an 
   array of menu structures: see do_menu() for more information. The top 
   level menu will be displayed as a horizontal bar, but when child menus 
   drop down from it they will be in the normal vertical format used by 
   do_menu(). When a menu item is selected, the return value from the menu 
   callback function is passed back to the dialog manager, so your callbacks 
   should return D_O_K, D_REDRAW, or D_CLOSE.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#GUI menus" title="">GUI menus</a>,
<a class="xref" href="#active_menu" title="Global pointer to the most recent activated menu.">active_menu</a>,
<a class="xref" href="#gui_menu_draw_menu" title="Hooks to modify the appearance of menus.">gui_menu_draw_menu</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="d_yield_proc">d_yield_proc</a>(int msg, <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   An invisible helper object that yields time slices for the scheduler (if
   the system supports it) when the GUI has nothing to do but waiting for
   user actions. You should put one instance of this object in each dialog 
   array because it may be needed on systems with an unusual scheduling 
   algorithm (for instance QNX) in order to make the GUI fully responsive.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#rest" title="Waits a specified number of milliseconds or yields CPU.">rest</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<br><center><h2><a name="GUI variables">GUI variables</a></h2></center><p>
The behaviour of the dialog manager can be controlled by the following
global variables.

<p><br>
<div class="al-api"><b>extern int <a name="gui_mouse_focus">gui_mouse_focus</a>;</b></div><br>
   If set, the input focus follows the mouse pointer around the dialog, 
   otherwise a click is required to move it.

<p><br>
<div class="al-api"><b>extern int <a name="gui_fg_color">gui_fg_color</a>;</b></div><br>
<div class="al-api-cont"><b>extern int <a name="gui_bg_color">gui_bg_color</a>;</b></div><br>
   The foreground and background colors for the standard dialogs (alerts, 
   menus, and the file selector). They default to 255 and 0.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gui_mg_color" title="The color used for displaying greyed-out dialog objects.">gui_mg_color</a>,
<a class="xref" href="#set_dialog_color" title="Sets the colors of an array of dialog objects.">set_dialog_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>extern int <a name="gui_mg_color">gui_mg_color</a>;</b></div><br>
   The color used for displaying greyed-out dialog objects (with the 
   D_DISABLED flag set). Defaults to 8.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gui_fg_color" title="The foreground and background colors for the standard dialogs.">gui_fg_color</a>,
<a class="xref" href="#set_dialog_color" title="Sets the colors of an array of dialog objects.">set_dialog_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>extern int <a name="gui_font_baseline">gui_font_baseline</a>;</b></div><br>
   If set to a non-zero value, adjusts the keyboard shortcut underscores to 
   account for the height of the descenders in your font.

<p><br>
<div class="al-api"><b>extern int (*<a name="gui_mouse_x">gui_mouse_x</a>)();</b></div><br>
<div class="al-api-cont"><b>extern int (*<a name="gui_mouse_y">gui_mouse_y</a>)();</b></div><br>
<div class="al-api-cont"><b>extern int (*<a name="gui_mouse_z">gui_mouse_z</a>)();</b></div><br>
<div class="al-api-cont"><b>extern int (*<a name="gui_mouse_b">gui_mouse_b</a>)();</b></div><br>
   Hook functions, used by the GUI routines whenever they need to access the 
   mouse state. By default these just return copies of the mouse_x, mouse_y, 
   mouse_z, and mouse_b variables, but they could be used to offset or scale 
   the mouse position, or read input from a different source entirely.

<p>
<br><center><h2><a name="GUI font">GUI font</a></h2></center><p>
You can change the global 'font' pointer to make the GUI objects use 
something other than the standard 8x8 font. The standard dialog procedures, 
menus, and alert boxes, will work with fonts of any size, but the 
gfx_mode_select() dialog will look wrong with anything other than 8x8 fonts.

<p><br>
<div class="al-api"><b>int <a name="gui_textout_ex">gui_textout_ex</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, const char *s, int x, y, color, bg, centre);</b></div><br>
   Helper function for use by the GUI routines. Draws a text string onto the 
   screen, interpreting the '&amp;' character as an underbar for displaying 
   keyboard shortcuts. Returns the width of the output string in pixels.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gui_strlen" title="Returns the length of a string in pixels.">gui_strlen</a>.</blockquote>
<div class="al-api"><b>int <a name="gui_strlen">gui_strlen</a>(const char *s);</b></div><br>
   Helper function for use by the GUI routines. Returns the length of a 
   string in pixels, ignoring '&amp;' characters.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gui_textout_ex" title="Draws a text string onto the screen with keyboard shortcut underbars.">gui_textout_ex</a>.</blockquote>
<div class="al-api"><b>void <a name="gui_set_screen">gui_set_screen</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   This function can be used to change the bitmap surface the GUI routines
   draw to. This can be useful if you are using a double buffering or page 
   flipping system. Passing NULL will cause the default surface (screen) to
   be used again. Example:
<blockquote class="code"><pre>
      <a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *page[2];
      
      /* Allocate two pages of video memory */
      page[0] = <a href="#create_video_bitmap" class="autotype" title="Creates a video memory bitmap.">create_video_bitmap</a>(<a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
      page[1] = <a href="#create_video_bitmap" class="autotype" title="Creates a video memory bitmap.">create_video_bitmap</a>(<a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
      
      /* Page flip */
      <a href="#show_video_bitmap" class="autotype" title="Flips the hardware screen to use the specified page.">show_video_bitmap</a>(page[0]);
      <a href="#gui_set_screen" class="autotype" title="Changes the bitmap surface GUI routines draw to.">gui_set_screen</a>(page[0]);
</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gui_get_screen" title="Returns the bitmap surface GUI routines draw to.">gui_get_screen</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="gui_get_screen">gui_get_screen</a>(void);</b></div><br>
   This function returns the current bitmap surface the GUI routines will
   use for drawing. Note that this function will return screen if you have
   called gui_set_screen(NULL) previously, and will never return NULL.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gui_set_screen" title="Changes the bitmap surface GUI routines draw to.">gui_set_screen</a>.</blockquote>
<div class="al-api"><b>void <a name="position_dialog">position_dialog</a>(<a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *dialog, int x, int y);</b></div><br>
   Moves an array of dialog objects to the specified screen position 
   (specified as the top left corner of the dialog).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#centre_dialog" title="Centers an array of dialog objects.">centre_dialog</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>void <a name="centre_dialog">centre_dialog</a>(<a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *dialog);</b></div><br>
   Moves an array of dialog objects so that it is centered in the screen.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#position_dialog" title="Moves an array of dialog objects to the specified position.">position_dialog</a>,
<a class="xref" href="#set_dialog_color" title="Sets the colors of an array of dialog objects.">set_dialog_color</a>.</blockquote>
<div class="al-api"><b>void <a name="set_dialog_color">set_dialog_color</a>(<a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *dialog, int fg, int bg);</b></div><br>
   Sets the foreground and background colors of an array of dialog objects.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gui_fg_color" title="The foreground and background colors for the standard dialogs.">gui_fg_color</a>,
<a class="xref" href="#gui_mg_color" title="The color used for displaying greyed-out dialog objects.">gui_mg_color</a>,
<a class="xref" href="#centre_dialog" title="Centers an array of dialog objects.">centre_dialog</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>int <a name="find_dialog_focus">find_dialog_focus</a>(<a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *dialog);</b></div><br>
   Searches the dialog for the object which has the input focus, returning 
   an index or -1 if the focus is not set. This is useful if you are calling 
   do_dialog() several times in a row and want to leave the focus in the 
   same place it was when the dialog was last displayed, as you can call 
   do_dialog(dlg, find_dialog_focus(dlg));


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#do_dialog" title="Basic dialog manager function.">do_dialog</a>,
<a class="xref" href="#init_dialog" title="Low level initialisation of a dialog.">init_dialog</a>,
<a class="xref" href="#offer_focus" title="Offers the input focus to a particular object.">offer_focus</a>.</blockquote>
<div class="al-api"><b>int <a name="offer_focus">offer_focus</a>(<a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *dialog, int obj, int *focus_obj, int force);</b></div><br>
   Offers the input focus to a particular object. Normally the function sends
   the MSG_WANTFOCUS message to query whether the object is willing to accept
   the focus. However, passing any non-zero value as force argument instructs
   the function to authoritatively set the focus to the object.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#find_dialog_focus" title="Searches the dialog for the object which has the input focus.">find_dialog_focus</a>.</blockquote>
<div class="al-api"><b>int <a name="object_message">object_message</a>(<a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *dialog, int msg, int c);</b></div><br>
   Sends a message to an object and returns the answer it has generated.
   Remember that the first parameter is the dialog object (not a whole
   array) that you wish to send the message to. For example, to make the
   second object in a dialog draw itself, you might write:
<blockquote class="code"><pre>
      <a href="#object_message" class="autotype" title="Sends a message to an object and returns the answer.">object_message</a>(&amp;dialog[1], MSG_DRAW, 0);
</pre></blockquote>
   The function will take care of scaring and unscaring the mouse if the
   message is MSG_DRAW.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#dialog_message" title="Sends a message to all the objects in an array.">dialog_message</a>,
<a class="xref" href="#scare_mouse" title="Helper for hiding the mouse pointer before drawing.">scare_mouse</a>,
<a class="xref" href="#scare_mouse_area" title="Helper for hiding the mouse cursor before drawing in an area.">scare_mouse_area</a>,
<a class="xref" href="#unscare_mouse" title="Undoes the effect of scare_mouse() or scare_mouse_area().">unscare_mouse</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>.</blockquote>
<div class="al-api"><b>int <a name="dialog_message">dialog_message</a>(<a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *dialog, int msg, int c, int *obj);</b></div><br>
   Sends a message to all the objects in an array. If any of the dialog 
   procedures return values other than D_O_K, it returns the value and sets 
   obj to the index of the object which produced it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#object_message" title="Sends a message to an object and returns the answer.">object_message</a>,
<a class="xref" href="#broadcast_dialog_message" title="Broadcasts a message to all the objects in the active dialog.">broadcast_dialog_message</a>.</blockquote>
<div class="al-api"><b>int <a name="broadcast_dialog_message">broadcast_dialog_message</a>(int msg, int c);</b></div><br>
   Broadcasts a message to all the objects in the active dialog. If any of 
   the dialog procedures return values other than D_O_K, it returns that 
   value.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#dialog_message" title="Sends a message to all the objects in an array.">dialog_message</a>,
<a class="xref" href="#active_dialog" title="Global pointer to the most recent activated dialog.">active_dialog</a>.</blockquote>
<div class="al-api"><b>int <a name="do_dialog">do_dialog</a>(<a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *dialog, int focus_obj);</b></div><br>
   The basic dialog manager function. This displays a dialog (an array of 
   dialog objects, terminated by one with a NULL dialog procedure), and sets 
   the input focus to the focus_obj (-1 if you don't want anything to have 
   the focus). It interprets user input and dispatches messages as they are 
   required, until one of the dialog procedures tells it to close the 
   dialog, at which point it returns the index of the object that caused it 
   to exit, or until ESC is pressed, at which point it returns -1.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#popup_dialog" title="do_dialog() used for popup dialogs.">popup_dialog</a>,
<a class="xref" href="#init_dialog" title="Low level initialisation of a dialog.">init_dialog</a>,
<a class="xref" href="#centre_dialog" title="Centers an array of dialog objects.">centre_dialog</a>,
<a class="xref" href="#set_dialog_color" title="Sets the colors of an array of dialog objects.">set_dialog_color</a>,
<a class="xref" href="#find_dialog_focus" title="Searches the dialog for the object which has the input focus.">find_dialog_focus</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#excustom" title="Creating custom GUI objects.">excustom</a>,
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>,
<a class="eref" href="#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>.</blockquote>
<div class="al-api"><b>int <a name="popup_dialog">popup_dialog</a>(<a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *dialog, int focus_obj);</b></div><br>
   Like do_dialog(), but it stores the data on the screen before drawing the 
   dialog and restores it when the dialog is closed. The screen area to be 
   stored is calculated from the dimensions of the first object in the 
   dialog, so all the other objects should lie within this one.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#do_dialog" title="Basic dialog manager function.">do_dialog</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#DIALOG_PLAYER" title="Stores GUI data internally used by Allegro.">DIALOG_PLAYER</a> *<a name="init_dialog">init_dialog</a>(<a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *dialog, int focus_obj);</b></div><br>
   This function provides lower level access to the same functionality as
   do_dialog(), but allows you to combine a dialog box with your own program 
   control structures. It initialises a dialog, returning a pointer to a 
   player object that can be used with update_dialog() and 
   shutdown_dialog(). With these functions, you could implement your own 
   version of do_dialog() with the lines:
<blockquote class="code"><pre>
      <a href="#DIALOG_PLAYER" class="autotype" title="Stores GUI data internally used by Allegro.">DIALOG_PLAYER</a> *player = <a href="#init_dialog" class="autotype" title="Low level initialisation of a dialog.">init_dialog</a>(dialog, focus_obj);

      while (<a href="#update_dialog" class="autotype" title="Low level function to update a dialog player.">update_dialog</a>(player))
         ;

      return <a href="#shutdown_dialog" class="autotype" title="Destroys a dialog player returned by init_dialog().">shutdown_dialog</a>(player);</pre></blockquote>

<p>
   Note that you are responsible for showing and hiding the mouse cursor, which
   do_dialog would otherwise do for you, or saving and restoring the screen
   contents, as popup_dialog would do for you.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#update_dialog" title="Low level function to update a dialog player.">update_dialog</a>,
<a class="xref" href="#shutdown_dialog" title="Destroys a dialog player returned by init_dialog().">shutdown_dialog</a>,
<a class="xref" href="#do_dialog" title="Basic dialog manager function.">do_dialog</a>.</blockquote>
<div class="al-api"><b>int <a name="update_dialog">update_dialog</a>(<a class="autotype" href="#DIALOG_PLAYER" title="Stores GUI data internally used by Allegro.">DIALOG_PLAYER</a> *player);</b></div><br>
   Updates the status of a dialog object returned by init_dialog(). Returns 
   TRUE if the dialog is still active, or FALSE if it has terminated. Upon a 
   return value of FALSE, it is up to you whether to call shutdown_dialog() 
   or to continue execution. The object that requested the exit can be 
   determined from the player-&gt;obj field.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#init_dialog" title="Low level initialisation of a dialog.">init_dialog</a>.</blockquote>
<div class="al-api"><b>int <a name="shutdown_dialog">shutdown_dialog</a>(<a class="autotype" href="#DIALOG_PLAYER" title="Stores GUI data internally used by Allegro.">DIALOG_PLAYER</a> *player);</b></div><br>
   Destroys a dialog player object returned by init_dialog(), returning the 
   object that caused it to exit (this is the same as the return value from 
   do_dialog()).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#init_dialog" title="Low level initialisation of a dialog.">init_dialog</a>.</blockquote>
<div class="al-api"><b>extern <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *<a name="active_dialog">active_dialog</a>;</b></div><br>
   Global pointer to the most recent activated dialog. This may be useful if 
   an object needs to iterate through a list of all its siblings.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#do_dialog" title="Basic dialog manager function.">do_dialog</a>,
<a class="xref" href="#init_dialog" title="Low level initialisation of a dialog.">init_dialog</a>,
<a class="xref" href="#broadcast_dialog_message" title="Broadcasts a message to all the objects in the active dialog.">broadcast_dialog_message</a>.</blockquote>
<br><center><h2><a name="GUI menus">GUI menus</a></h2></center><p>
Popup or pulldown menus are created as an array of MENU structures. Read
chapter "Structures and types defined by Allegro" for an internal description
of the MENU structure.

<p>
Each menu item contains a text string. This can use the '&amp;' character to 
indicate keyboard shortcuts, or can be an zero-length string to display the 
item as a non-selectable splitter bar. If the string contains a "\t" tab 
character, any text after this will be right-justified, eg. for displaying 
keyboard shortcut information. The proc pointer is a function which will be 
called when the menu item is selected, and child points to another menu, 
allowing you to create nested menus. Both proc and child may be NULL. The 
proc function returns an integer which is ignored if the menu was brought up 
by calling do_menu(), but which is passed back to the dialog manager if it 
was created by a d_menu_proc() object. The array of menu items is terminated 
by an entry with a NULL text pointer.

<p>
Menu items can be disabled (greyed-out) by setting the D_DISABLED bit in the 
flags field, and a check mark can be displayed next to them by setting the 
D_SELECTED bit. With the default alignment and font this will usually 
overlap the menu text, so if you are going to use checked menu items it 
would be a good idea to prefix all your options with a space or two, to 
ensure there is room for the check.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#do_menu" title="Displays an animates a popup menu.">do_menu</a>,
<a class="xref" href="#d_menu_proc" title="Dialog procedure implementing a menu bar object.">d_menu_proc</a>,
<a class="xref" href="#gui_menu_draw_menu" title="Hooks to modify the appearance of menus.">gui_menu_draw_menu</a>.</blockquote>
<div class="al-api"><b>int <a name="do_menu">do_menu</a>(<a class="autotype" href="#MENU" title="Stores the entries of a menu.">MENU</a> *menu, int x, int y);</b></div><br>
   Displays and animates a popup menu at the specified screen coordinates 
   (these will be adjusted if the menu does not entirely fit on the screen). 
   Returns the index of the menu item that was selected, or -1 if the menu 
   was cancelled. Note that the return value cannot indicate selection from 
   child menus, so you will have to use the callback functions if you want 
   multi-level menus.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#GUI menus" title="">GUI menus</a>,
<a class="xref" href="#d_menu_proc" title="Dialog procedure implementing a menu bar object.">d_menu_proc</a>,
<a class="xref" href="#active_menu" title="Global pointer to the most recent activated menu.">active_menu</a>,
<a class="xref" href="#gui_menu_draw_menu" title="Hooks to modify the appearance of menus.">gui_menu_draw_menu</a>,
<a class="xref" href="#update_menu" title="Low level function to update a menu player.">update_menu</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#MENU_PLAYER" title="Stores GUI data internally used by Allegro.">MENU_PLAYER</a> *<a name="init_menu">init_menu</a>(<a class="autotype" href="#MENU" title="Stores the entries of a menu.">MENU</a> *menu, int x, int y);</b></div><br>
   This function provides lower level access to the same functionality as 
   do_menu(), but allows you to combine a popup menu with your own program 
   control structures. It initialises a menu, returning a pointer to a menu
   player object that can be used with update_menu() and shutdown_menu().
   With these functions, you could implement your own version of do_menu()
   with the lines:
<blockquote class="code"><pre>
      <a href="#MENU_PLAYER" class="autotype" title="Stores GUI data internally used by Allegro.">MENU_PLAYER</a> *player = <a href="#init_menu" class="autotype" title="Low level initialisation of a menu.">init_menu</a>(menu, x, y);

      while (<a href="#update_menu" class="autotype" title="Low level function to update a menu player.">update_menu</a>(player))
         ;

      return <a href="#shutdown_menu" class="autotype" title="Destroys a menu player object returned by init_menu().">shutdown_menu</a>(player);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#update_menu" title="Low level function to update a menu player.">update_menu</a>,
<a class="xref" href="#shutdown_menu" title="Destroys a menu player object returned by init_menu().">shutdown_menu</a>,
<a class="xref" href="#do_menu" title="Displays an animates a popup menu.">do_menu</a>.</blockquote>
<div class="al-api"><b>int <a name="update_menu">update_menu</a>(<a class="autotype" href="#MENU_PLAYER" title="Stores GUI data internally used by Allegro.">MENU_PLAYER</a> *player);</b></div><br>
   Updates the status of a menu object returned by init_menu(). Returns TRUE
   if the menu is still active, or FALSE if it has terminated. Upon a return
   value of FALSE, it is up to you to call shutdown_menu() or to continue
   execution.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#init_menu" title="Low level initialisation of a menu.">init_menu</a>,
<a class="xref" href="#shutdown_menu" title="Destroys a menu player object returned by init_menu().">shutdown_menu</a>,
<a class="xref" href="#do_menu" title="Displays an animates a popup menu.">do_menu</a>.</blockquote>
<div class="al-api"><b>int <a name="shutdown_menu">shutdown_menu</a>(<a class="autotype" href="#MENU_PLAYER" title="Stores GUI data internally used by Allegro.">MENU_PLAYER</a> *player);</b></div><br>
   Destroys a menu player object returned by init_menu(), returning the index
   of the menu item that was selected, or -1 if the menu was cancelled (this
   is the same as the return value from do_menu()).
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#init_menu" title="Low level initialisation of a menu.">init_menu</a>,
<a class="xref" href="#update_menu" title="Low level function to update a menu player.">update_menu</a>.</blockquote>
<div class="al-api"><b>extern <a class="autotype" href="#MENU" title="Stores the entries of a menu.">MENU</a> *<a name="active_menu">active_menu</a>;</b></div><br>
   When a menu callback procedure is triggered, this will be set to the menu 
   item that was selected, so your routine can determine where it was called 
   from.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#GUI menus" title="">GUI menus</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>.</blockquote>
<div class="al-api"><b>extern void (*<a name="gui_menu_draw_menu">gui_menu_draw_menu</a>)(int x, int y, int w, int h);</b></div><br>
<div class="al-api-cont"><b>extern void (*<a name="gui_menu_draw_menu_item">gui_menu_draw_menu_item</a>)(<a class="autotype" href="#MENU" title="Stores the entries of a menu.">MENU</a> *m, int x, int y, int w,
                                       int h, int bar, int sel);</b></div><br>
   If set, these functions will be called whenever a menu needs to be
   drawn, so you can change how menus look.

<p>
   gui_menu_draw_menu() is passed the position and size of the
   menu. It should draw the background of the menu onto screen.

<p>
   gui_menu_draw_menu_item() is called once for each menu item that is
   to be drawn. bar will be set if the item is part of a top-level
   horizontal menu bar, and sel will be set if the menu item is
   selected. It should also draw onto screen.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#GUI menus" title="">GUI menus</a>.</blockquote>
<div class="al-api"><b>int <a name="alert">alert</a>(const char *s1, *s2, *s3, const char *b1, *b2, int c1, c2);</b></div><br>
   Displays a popup alert box, containing three lines of text (s1-s3), and 
   with either one or two buttons. The text for these buttons is passed in 
   <tt>`b1'</tt> and <tt>`b2'</tt> (<tt>`b2'</tt> may be NULL), and the keyboard shortcuts in <tt>`c1'</tt> and
   <tt>`c2'</tt> as ASCII value. Example:
<blockquote class="code"><pre>
      if (!<a href="#exists" class="autotype" title="Shortcut version of file_exists() for normal files.">exists</a>(CONFIG_FILE))
         <a href="#alert" class="autotype" title="Displays a popup alert box.">alert</a>(CONFIG_FILE, "not found.", "Using defaults.",
               "&amp;Continue", NULL, 'c', 0);</pre></blockquote>
<p><b>Return value:</b>
   Returns 1 or 2 depending on which button was clicked. If the alert is 
   dismissed by pressing ESC when ESC is not one of the keyboard shortcuts, 
   it treats it as a click on the second button (this is consistent with the 
   common "Ok", "Cancel" alert).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#alert3" title="Like alert(), but with three buttons.">alert3</a>,
<a class="xref" href="#gui_fg_color" title="The foreground and background colors for the standard dialogs.">gui_fg_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#exgui" title="Using the GUI routines.">exgui</a>,
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>,
<a class="eref" href="#exspline" title="Constructing smooth movement paths from spline curves.">exspline</a>.</blockquote>
<div class="al-api"><b>int <a name="alert3">alert3</a>(const char *s1, *s2, *s3, const char *b1, *b2, *b3, int c1, c2, c3);</b></div><br>
   Like alert(), but with three buttons. Returns 1, 2, or 3.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#alert" title="Displays a popup alert box.">alert</a>,
<a class="xref" href="#gui_fg_color" title="The foreground and background colors for the standard dialogs.">gui_fg_color</a>.</blockquote>
<div class="al-api"><b>int <a name="file_select_ex">file_select_ex</a>(const char *message, char *path, const char *ext,
                   int size, int w, int h);</b></div><br>
   Displays the Allegro file selector, with the message as caption. The path 
   parameter contains the initial filename to display (this can be used to 
   set the starting directory, or to provide a default filename for a 
   save-as operation). The user selection is returned by altering the path 
   buffer, whose maximum capacity in bytes is specified by the size parameter.
   Note that it should have room for at least 80 characters (not bytes),
   so you should reserve 6x that amount, just to be sure. The list of files
   is filtered according to the file extensions in the ext parameter.
   Passing NULL includes all files; "PCX;BMP" includes only files with
   .PCX or .BMP extensions. If you wish to control files by their attributes,
   one of the fields in the extension list can begin with a slash, followed
   by a set of attribute characters. Any attribute written on its own, or
   with a '+' before it, indicates to include only files which have that
   attribute set. Any attribute with a '-' before it indicates to leave out
   any files with that attribute. The flag characters are 'r' (read-only),
   'h' (hidden), 's' (system), 'd' (directory) and 'a' (archive). For
   example, an extension string of "PCX;BMP;/+r-h" will display only PCX or
   BMP files that are read-only and not hidden. The directories are not
   affected in the same way as the other files by the extension string: the
   extensions are never taken into account for them and the other attributes
   are taken into account only when 'd' is mentioned in the string; in other
   words, all directories are included when 'd' is not mentioned in the
   string. The file selector is stretched to the width and height specified
   in the w and h parameters, and to the size of the standard Allegro font.
   If either the width or height argument is set to zero, it is stretched
   to the corresponding screen dimension. This function returns zero if it
   was closed with the Cancel button or non-zero if it was OK'd.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gui_fg_color" title="The foreground and background colors for the standard dialogs.">gui_fg_color</a>.</blockquote>
<div class="al-api"><b>int <a name="gfx_mode_select">gfx_mode_select</a>(int *card, int *w, int *h);</b></div><br>
   Displays the Allegro graphics mode selection dialog, which allows the 
   user to select a screen mode and graphics card. Stores the selection in 
   the three variables, and returns zero if it was closed with the Cancel 
   button or non-zero if it was OK'd.

<p>
   The initial values of card, w, h are not used.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gfx_mode_select_ex" title="Extended version of the graphics mode selection dialog.">gfx_mode_select_ex</a>,
<a class="xref" href="#gfx_mode_select_filter" title="Even more extended version of the graphics mode selection dialog.">gfx_mode_select_filter</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#gui_fg_color" title="The foreground and background colors for the standard dialogs.">gui_fg_color</a>.</blockquote>
<div class="al-api"><b>int <a name="gfx_mode_select_ex">gfx_mode_select_ex</a>(int *card, int *w, int *h, int *color_depth);</b></div><br>
   Extended version of the graphics mode selection dialog, which allows the 
   user to select the color depth as well as the resolution and hardware 
   driver.
   
<p>
   This version of the function reads the initial values from the 
   parameters when it activates so you can specify the default values.
   In fact, you should be sure not to pass in uninitialised values.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gfx_mode_select" title="Displays the Allegro graphics mode selection dialog.">gfx_mode_select</a>,
<a class="xref" href="#gfx_mode_select_filter" title="Even more extended version of the graphics mode selection dialog.">gfx_mode_select_filter</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#gui_fg_color" title="The foreground and background colors for the standard dialogs.">gui_fg_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>,
<a class="eref" href="#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>int <a name="gfx_mode_select_filter">gfx_mode_select_filter</a>(int *card, int *w, int *h, int *color_depth,
                            int (*filter)(int, int, int, int));</b></div><br>
   Even more extended version of the graphics mode selection dialog, which
   allows the programmer to customize the contents of the dialog and the user
   to select the color depth as well as the resolution and hardware driver.
   <tt>`filter'</tt> will be passed (card, w, h, color_depth) quadruplets and must
   return 0 to let the specified quadruplet be added to the list of displayed
   modes.

<p>
   This version of the function reads the initial values from the 
   parameters when it activates so you can specify the default values.
   In fact, you should be sure not to pass in uninitialised values.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#gfx_mode_select" title="Displays the Allegro graphics mode selection dialog.">gfx_mode_select</a>,
<a class="xref" href="#gfx_mode_select_ex" title="Extended version of the graphics mode selection dialog.">gfx_mode_select_ex</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#gui_fg_color" title="The foreground and background colors for the standard dialogs.">gui_fg_color</a>.</blockquote>
<div class="al-api"><b>extern int (*<a name="gui_shadow_box_proc">gui_shadow_box_proc</a>)(int msg, struct <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
<div class="al-api-cont"><b>extern int (*<a name="gui_ctext_proc">gui_ctext_proc</a>)(int msg, struct <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
<div class="al-api-cont"><b>extern int (*<a name="gui_button_proc">gui_button_proc</a>)(int msg, struct <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
<div class="al-api-cont"><b>extern int (*<a name="gui_edit_proc">gui_edit_proc</a>)(int msg, struct <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
<div class="al-api-cont"><b>extern int (*<a name="gui_list_proc">gui_list_proc</a>)(int msg, struct <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
<div class="al-api-cont"><b>extern int (*<a name="gui_text_list_proc">gui_text_list_proc</a>)(int msg, struct <a class="autotype" href="#DIALOG" title="Stores a GUI description.">DIALOG</a> *d, int c);</b></div><br>
   If set, these functions will be used by the standard Allegro dialogs.
   This allows you to customise the look and feel, much like gui_fg_color
   and gui_bg_color, but much more flexibly.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#alert" title="Displays a popup alert box.">alert</a>,
<a class="xref" href="#alert3" title="Like alert(), but with three buttons.">alert3</a>,
<a class="xref" href="#file_select_ex" title="Displays the Allegro file selector with a caption.">file_select_ex</a>,
<a class="xref" href="#gfx_mode_select" title="Displays the Allegro graphics mode selection dialog.">gfx_mode_select</a>,
<a class="xref" href="#gui_fg_color" title="The foreground and background colors for the standard dialogs.">gui_fg_color</a>.</blockquote>
<h1><a name="DOS specifics">DOS specifics</a></h1>

<p>
There are four Allegro files which you should redistribute along your program.
These are the files <tt>`keyboard.dat'</tt>, <tt>`language.dat'</tt>, <tt>`allegro.cfg'</tt> and
<tt>`setup.exe'</tt>.

<p>
The first two contain internationalisation information for keyboard mappings
and system messages to show up localised on the user's computer. The
<tt>`setup.exe'</tt> program, which comes in Allegro's <tt>`setup'</tt> directory, is a
standalone tool which you can graphically customise and even embed into your
main binary. The user can generate a configuration file with this tool, to
store special settings or avoid Allegro's autodetection failing on specific
hardware. Even if you distribute <tt>`setup.exe'</tt>, you are recommended to copy too
the empty <tt>`allegro.cfg'</tt> file, in case the setup program itself is unable to
run and the user has to edit manually the configuration with a text editor.

<p>
If you are using get_config_text() in your program to localise text strings,
merge your xxtext.cfg files with the ones provided by Allegro in the
<tt>`resource'</tt> directory before creating <tt>`language.dat'</tt>, and redistribute this
with your program. This file will contain then both Allegro's system
messages and the strings of your program.

<p><br>
<div class="al-api"><b>Drivers <a name="JOY_TYPE_*/DOS">JOY_TYPE_*/DOS</a></b></div><br>
   The DOS library supports the following type parameters for the 
   install_joystick() function:
<ul><li>
   JOY_TYPE_AUTODETECT<br>
      Attempts to autodetect your joystick hardware. It isn't possible to 
      reliably distinguish between all the possible input setups, so this 
      routine can only ever choose the standard joystick, Sidewider, GamePad 
      Pro, or GrIP drivers, but it will use information from the 
      configuration file if one is available (this can be created using the 
      setup utility or by calling the save_joystick_data() function), so you 
      can always use JOY_TYPE_AUTODETECT in your code and then select the 
      exact hardware type from the setup program.
<li>
   JOY_TYPE_NONE<br>
      Dummy driver for machines without any joystick.
<li>
   JOY_TYPE_STANDARD<br>
      A normal two button stick.
<li>
   JOY_TYPE_2PADS<br>
      Dual joystick mode (two sticks, each with two buttons).
<li>
   JOY_TYPE_4BUTTON<br>
      Enable the extra buttons on a 4-button joystick.
<li>
   JOY_TYPE_6BUTTON<br>
      Enable the extra buttons on a 6-button joystick.
<li>
   JOY_TYPE_8BUTTON<br>
      Enable the extra buttons on an 8-button joystick.
<li>
   JOY_TYPE_FSPRO<br>
      CH Flightstick Pro or compatible stick, which provides four buttons, 
      an analogue throttle control, and a 4-direction coolie hat.
<li>
   JOY_TYPE_WINGEX<br>
      A Logitech Wingman Extreme, which should also work with any 
      Thrustmaster Mk.I compatible joystick. It provides support for four 
      buttons and a coolie hat. This also works with the Wingman Warrior, if 
      you plug in the 15 pin plug (remember to unplug the 9-pin plug!) and 
      set the tiny switch in front to the "H" position (you will not be able 
      to use the throttle or the spinner though).
<li>
   JOY_TYPE_SIDEWINDER<br>
      The Microsoft Sidewinder digital pad (supports up to four controllers, 
      each with ten buttons and a digital direction control).
<li>
   JOY_TYPE_SIDEWINDER_AG<br>
      An alternative driver to JOY_TYPE_SIDEWINDER.
      Try this if your Sidewinder isn't recognized with JOY_TYPE_SIDEWINDER.
<li>
   JOY_TYPE_SIDEWINDER_PP<br>
      The Microsoft Sidewinder 3D/Precision/Force Feedback Pro joysticks.
<li>
   JOY_TYPE_GAMEPAD_PRO<br>
      The Gravis GamePad Pro (supports up to two controllers, each with ten 
      buttons and a digital direction control).
<li>
   JOY_TYPE_GRIP<br>
      Gravis GrIP driver, using the grip.gll driver file.
<li>
   JOY_TYPE_GRIP4<br>
      Version of the Gravis GrIP driver that is constrained to only move 
      along the four main axes.
<li>
   JOY_TYPE_SNESPAD_LPT1<br>
   JOY_TYPE_SNESPAD_LPT2<br>
   JOY_TYPE_SNESPAD_LPT3<br>
      SNES joypads connected to LPT1, LPT2, and LPT3 respectively.
<li>
   JOY_TYPE_PSXPAD_LPT1<br>
   JOY_TYPE_PSXPAD_LPT2<br>
   JOY_TYPE_PSXPAD_LPT3<br>
      PSX joypads connected to LPT1, LPT2, and LPT3 respectively. See 
      <a href="http://www.ziplabel.com/dpadpro/index.html">http://www.ziplabel.com/dpadpro/index.html</a> for information 
      about the parallel cable required. The driver automagically detects 
      which types of PSX pads are connected out of digital, analog (red or 
      green mode), NegCon, multi taps, Namco light guns, Jogcons (force 
      feedback steering wheel) and the mouse. If the controller isn't 
      recognised it is treated as an analog controller, meaning the driver 
      should work with just about anything. You can connect controllers in 
      any way you see fit, but only the first 8 will be used.

      The Sony Dual Shock or Namco Jogcon will reset themselves (to digital 
      mode) after not being polled for 5 seconds. This is normal, the same 
      thing happens on a Playstation, it's designed to stop any vibration in 
      case the host machine crashes. Other mode switching controllers may 
      have similar quirks. However, if this happens to a Jogcon controller 
      the mode button is disabled. To reenable the mode button on the Jogcon 
      you need to hold down the Start and Select buttons at the same time.

      The G-con45 needs to be connected to (and pointed at) a TV type monitor
      connected to your computer. The composite video out on my video card 
      works fine for this (a Hercules Stingray 128/3D 8Mb). The TV video 
      modes in Mame should work too.
<li>
   JOY_TYPE_N64PAD_LPT1<br>
   JOY_TYPE_N64PAD_LPT2<br>
   JOY_TYPE_N64PAD_LPT3<br>
      N64 joypads connected to LPT1, LPT2, and LPT3 respectively. See 
      <a href="http://www.st-hans.de/N64.htm">http://www.st-hans.de/N64.htm</a> for information about the 
      necessary hardware adapter. It supports up to four controllers on a 
      single parallel port. There is no need to calibrate the analog stick, 
      as this is done by the controller itself when powered up. This means 
      that the stick has to be centred when the controller is initialised. 
      One possible issue people may have with this driver is that it is 
      physically impossible to move the analog stick fully diagonal, but I 
      can't see this causing any major problems. This is because of the 
      shape of the rim that the analog stick rests against. Like the Gravis 
      Game Pad Pro, this driver briefly needs to disable hardware interrupts 
      while polling. This causes a noticeable performance hit on my machine 
      in both drivers, but there is no way around it. At a (very) rough 
      guess I'd say it slows down Mame 5% - 10%.
<li>
   JOY_TYPE_DB9_LPT1<br>
   JOY_TYPE_DB9_LPT2<br>
   JOY_TYPE_DB9_LPT3<br>
      A pair of two-button joysticks connected to LPT1, LPT2, and LPT3 
      respectively. Port 1 is compatible with Linux joy-db9 driver 
      (multisystem 2-button), and port 2 is compatible with Atari interface 
      for DirectPad Pro. See the source file (src/dos/multijoy.c) for pinout 
      information.
<li>
   JOY_TYPE_TURBOGRAFIX_LPT1<br>
   JOY_TYPE_TURBOGRAFIX_LPT2<br>
   JOY_TYPE_TURBOGRAFIX_LPT3<br>
      These drivers support up to 7 joysticks, each one with up to 5 
      buttons, connected to LPT1, LPT2, and LPT3 respectively. They use the 
      TurboGraFX interface by Steffen Schwenke: see 
      <a href="http://www.burg-halle.de/~schwenke/parport.html">http://www.burg-halle.de/~schwenke/parport.html</a> for details 
      on how to build this.
<li>
   JOY_TYPE_WINGWARRIOR<br>
      A Wingman Warrior joystick.
<li>
   JOY_TYPE_IFSEGA_ISA<br>
   JOY_TYPE_IFSEGA_PCI<br>
   JOY_TYPE_IFSEGA_PCI_FAST<br>
      Drivers for the IF-SEGA joystick interface cards by the IO-DATA 
      company (these come in PCI, PCI2, and ISA variants).
</ul>

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="GFX_*/DOS">GFX_*/DOS</a></b></div><br>
   The DOS library supports the following card parameters for the 
   set_gfx_mode() function:
<ul><li>
   GFX_TEXT<br>
      Return to text mode.
<li>
   GFX_AUTODETECT<br>
      Let Allegro pick an appropriate graphics driver.
<li>
   GFX_AUTODETECT_FULLSCREEN<br>
      Autodetects a graphics driver, but will only use fullscreen drivers,
      failing if these are not available on current platform.
<li>
   GFX_AUTODETECT_WINDOWED<br>
      Same as above, but uses only windowed drivers. This will always fail
      under DOS.
<li>
   GFX_SAFE<br>
      Special driver for when you want to reliably set a graphics mode and 
      don't really care what resolution or color depth you get. See the
      set_gfx_mode() documentation for details.
<li>
   GFX_VGA<br>
      The standard 256-color VGA mode 13h, using the GFX_VGA driver. This is 
      normally sized 320x200, which will work on any VGA but doesn't support 
      large virtual screens and hardware scrolling. Allegro also provides 
      some tweaked variants of the mode which are able to scroll, sized 
      320x100 (with a 200 pixel high virtual screen), 160x120 (with a 409 
      pixel high virtual screen), 256x256 (no scrolling), and 80x80 (with a 
      819 pixel high virtual screen).
<li>
   GFX_MODEX<br>
      Mode-X will work on any VGA card, and provides a range of different 
      256-color tweaked resolutions.
<ul><li>
      Stable mode-X resolutions:
<ul><li>
         Square aspect ratio: 320x240
<li>
         Skewed aspect ratio: 256x224, 256x240, 320x200, 320x400,
                              320x480, 320x600, 360x200, 360x240,
                              360x360, 360x400, 360x480
</ul>
         These have worked on every card/monitor that I've tested.
<li>
      Unstable mode-X resolutions:
<ul><li>
         Square aspect ratio: 360x270, 376x282, 400x300
<li>
         Skewed aspect ratio: 256x200, 256x256, 320x350, 360x600,
                              376x308, 376x564, 400x150, 400x600
</ul>
         These only work on some monitors. They were fine on my old machine, 
         but don't get on very well with my new monitor. If you are worried 
         about the possibility of damaging your monitor by using these 
         modes, don't be. Of course I'm not providing any warranty with any 
         of this, and if your hardware does blow up that is tough, but I 
         don't think this sort of tweaking can do any damage. From the 
         documentation of Robert Schmidt's TWEAK program:

            "Some time ago, putting illegal or unsupported values or 
            combinations of such into the video card registers might prove 
            hazardous to both your monitor and your health. I have *never* 
            claimed that bad things can't happen if you use TWEAK, although 
            I'm pretty sure it never will. I've never heard of any damage 
            arising from trying out TWEAK, or from general VGA tweaking in 
            any case."
</ul>
      Most of the mode-X drawing functions are slower than in mode 13h, due 
      to the complexity of the planar bitmap organisation, but solid area 
      fills and plane-aligned blits from one part of video memory to another 
      can be significantly faster, particularly on older hardware. Mode-X 
      can address the full 256k of VGA RAM, so hardware scrolling and page 
      flipping are possible, and it is possible to split the screen in order 
      to scroll the top part of the display but have a static status 
      indicator at the bottom.
<li>
   GFX_VESA1<br>
      Use the VESA 1.x driver.
<li>
   GFX_VESA2B<br>
      Use the VBE 2.0 banked mode driver.
<li>
   GFX_VESA2L<br>
      Use the VBE 2.0 linear framebuffer driver.
<li>
   GFX_VESA3<br>
      Use the VBE 3.0 driver. This is the only VESA driver that supports the 
      request_refresh_rate() function.

      The standard VESA modes are 640x480, 800x600, and 1024x768. These 
      ought to work with any SVGA card: if they don't, get a copy of the 
      SciTech Display Doctor and see if that fixes it. What color depths are 
      available will depend on your hardware. Most cards support both 15 and 
      16-bit resolutions, but if at all possible I would advise you to 
      support both (it's not hard...) in case one is not available. Some 
      cards provide both 24 and 32-bit truecolor, in which case it is a 
      choice between 24 (saves memory) or 32 (faster), but many older cards 
      have no 32-bit mode and some newer ones don't support 24-bit 
      resolutions. Use the vesainfo test program to see what modes your VESA 
      driver provides.

      Many cards also support 640x400, 1280x1024, and 1600x1200, but these 
      aren't available on everything, for example the S3 chipset has no 
      640x400 mode. Other weird resolution may be possible, eg. some Tseng 
      boards can do 640x350, and the Avance Logic has a 512x512 mode.

      The SciTech Display Doctor provides several scrollable low resolution 
      modes in a range of different color depths (320x200, 320x240, 320x400, 
      320x480, 360x200, 360x240, 360x400, and 360x480 all work on my ET4000 
      with 8, 15, or 16 bits per pixel). These are lovely, allowing 
      scrolling and page flipping without the complexity of the mode-X 
      planar setup, but unfortunately they aren't standard so you will need 
      Display Doctor in order to use them.
<li>
   GFX_VBEAF<br>
      VBE/AF is a superset of the VBE 2.0 standard, which provides an API 
      for accessing hardware accelerator features. VBE/AF drivers are 
      currently only available from the FreeBE/AF project or as part of the 
      SciTech Display Doctor package, but they can give dramatic speed 
      improvements when used with suitable hardware. For a detailed 
      discussion of hardware acceleration issues, refer to the documentation 
      for the gfx_capabilities flag.

      You can use the afinfo test program to check whether you have a VBE/AF 
      driver, and to see what resolutions it supports.

      The SciTech VBE/AF drivers require nearptr access to be enabled, so 
      any stray pointers are likely to crash your machine while their 
      drivers are in use. This means it may be a good idea to use VESA while 
      debugging your program, and only switch to VBE/AF once the code is 
      working correctly. The FreeBE/AF drivers do not have this problem.
<li>
   GFX_XTENDED<br>
      An unchained 640x400 mode, as described by Mark Feldman in the PCGPE. 
      This uses VESA to select an SVGA mode (so it will only work on cards 
      supporting the VESA 640x400 resolution), and then unchains the VGA 
      hardware as for mode-X. This allows the entire screen to be addressed 
      without the need for bank switching, but hardware scrolling and page 
      flipping are not possible. This driver will never be autodetected (the 
      normal VESA 640x400 mode will be chosen instead), so if you want to 
      use it you will have to explicitly pass GFX_XTENDED to set_gfx_mode().
</ul>
   There are a few things you need to be aware of for scrolling:
   most VESA implementations can only handle horizontal scrolling in four 
   pixel increments, so smooth horizontal panning is impossible in SVGA modes. 
   A significant number of VESA implementations seem to be very buggy when it 
   comes to scrolling in truecolor video modes, so you shouldn't depend on 
   this routine working correctly in the truecolor resolutions unless you can
   be sure that SciTech Display Doctor is installed. Hardware scrolling may
   also not work at all under Windows.

<p>
   Triple buffering is only possible with certain drivers: it will work in any
   DOS mode-X resolution if the timer retrace simulator is active (but this
   doesn't work correctly under Windows 95), plus it is supported by the
   VBE 3.0 and VBE/AF drivers for a limited number graphics cards.

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="DIGI_*/DOS">DIGI_*/DOS</a></b></div><br>
   The DOS sound functions support the following digital sound cards:
<blockquote class="text"><pre>
      DIGI_AUTODETECT      - let Allegro pick a digital sound driver
      DIGI_NONE            - no digital sound
      DIGI_SB              - Sound Blaster (autodetect type)
      DIGI_SB10            - SB 1.0 (8-bit mono single shot DMA)
      DIGI_SB15            - SB 1.5 (8-bit mono single shot DMA)
      DIGI_SB20            - SB 2.0 (8-bit mono auto-initialised
                             DMA)
      DIGI_SBPRO           - SB Pro (8-bit stereo)
      DIGI_SB16            - SB16 (16-bit stereo)
      DIGI_AUDIODRIVE      - ESS AudioDrive
      DIGI_SOUNDSCAPE      - Ensoniq Soundscape
      DIGI_WINSOUNDSYS     - Windows Sound System</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_digi_driver" title="Detects whether the specified digital sound device is available.">detect_digi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="MIDI_*/DOS">MIDI_*/DOS</a></b></div><br>
   The DOS sound functions support the following MIDI sound cards:
<blockquote class="text"><pre>
      MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
      MIDI_NONE            - no MIDI sound
      MIDI_ADLIB           - Adlib or SB FM synth (autodetect type)
      MIDI_OPL2            - OPL2 synth (mono, used in Adlib and SB)
      MIDI_2XOPL2          - dual OPL2 synths (stereo, used in
                             SB Pro-I)
      MIDI_OPL3            - OPL3 synth (stereo, SB Pro-II
                             and above)
      MIDI_SB_OUT          - SB MIDI interface
      MIDI_MPU             - MPU-401 MIDI interface
      MIDI_DIGMID          - sample-based software wavetable player
      MIDI_AWE32           - AWE32 (EMU8000 chip)</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_midi_driver" title="Detects whether the specified MIDI sound device is available.">detect_midi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<br><center><h2><a name="DOS integration routines">DOS integration routines</a></h2></center><p>

<p><br>
<div class="al-api"><b>extern int <a name="i_love_bill">i_love_bill</a>;</b></div><br>
   When running in clean DOS mode, the timer handler dynamically reprograms 
   the clock chip to generate interrupts at exactly the right times, which 
   gives an extremely high accuracy. Unfortunately, this constant speed 
   adjustment doesn't work under most multitasking systems (notably 
   Windows), so there is an alternative mode that just locks the hardware 
   timer interrupt to a speed of 200 ticks per second. This reduces the 
   accuracy of the timer (for instance, rest() will round the delay time to 
   the nearest 5 milliseconds), and prevents the vertical retrace simulator 
   from working, but on the plus side, it makes Allegro programs work under 
   Windows. This flag is set by allegro_init() if it detects the presence of
   a multitasking OS, and enables the fixed rate timer mode.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#os_type" title="Stores the detected type of the OS.">os_type</a>.</blockquote>
<h1><a name="Windows specifics">Windows specifics</a></h1>

<p>
In terms of file redistribution, the Windows platform behaves practically the
same as the DOS platform. Read section chapter "Dos specifics" in the manual
to learn more about this.

<p>
A Windows program that uses the Allegro library is only required to include
one or more header files from the include/allegro tree, or allegro.h; however,
if it also needs to directly call non portable Win32 API functions, it must
include the Windows-specific header file winalleg.h after the Allegro headers,
and before any Win32 API header file. By default winalleg.h includes the main
Win32 C API header file windows.h. If instead you want to use the C++
interface to the Win32 API (a.k.a. the Microsoft Foundation Classes), define
the preprocessor symbol ALLEGRO_AND_MFC before including any Allegro header
so that afxwin.h will be included. Note that, in this latter case, the Allegro
debugging macros ASSERT() and TRACE() are renamed AL_ASSERT() and AL_TRACE()
respectively.

<p>
Windows GUI applications start with a WinMain() entry point, rather than the
standard main() entry point. Allegro is configured to build GUI applications
by default and to do some magic in order to make a regular main() work with
them, but you have to help it out a bit by writing END_OF_MAIN() right after
your main() function. If you don't want to do that, you can just include
winalleg.h and write a WinMain() function. Note that this magic may bring
about conflicts with a few programs using direct calls to Win32 API
functions; for these programs, the regular WinMain() is required and the
magic must be disabled by defining the preprocessor symbol
ALLEGRO_NO_MAGIC_MAIN before including Allegro headers.

<p>
If you want to build a console application using Allegro, you have to define
the preprocessor symbol ALLEGRO_USE_CONSOLE before including Allegro headers;
it will instruct the library to use console features and also to disable the
special processing of the main() function described above.

<p>
When creating the main window, Allegro searches the executable for an ICON 
resource named "allegro_icon". If it is present, Allegro automatically
loads it and uses it as its application icon; otherwise, Allegro uses the 
default IDI_APPLICATION icon. See the manual of your compiler for a method 
to create an ICON resource, or use the wfixicon utility from the tools/win 
directory.

<p>
DirectX requires that system and video bitmaps (including the screen) be 
locked before you can draw onto them. This will be done automatically, but 
you can usually get much better performance by doing it yourself: see the 
acquire_bitmap() function for details.

<p>
Due to a major oversight in the design of DirectX, there is no way to 
preserve the contents of video memory when the user switches away from your 
program. You need to be prepared for the fact that your screen contents, and 
the contents of any video memory bitmaps, may be destroyed at any point. You 
can use the set_display_switch_callback() function to find out when this 
happens.

<p>
On the Windows platform, the only return values for the desktop_color_depth()
function are 8, 16, 24 and 32. This means that 15-bit and 16-bit desktops 
cannot be differentiated and are both reported as 16-bit desktops. See
below for the consequences for windowed and overlay DirectX drivers.

<p><br>
<div class="al-api"><b>Drivers <a name="JOY_TYPE_*/Windows">JOY_TYPE_*/Windows</a></b></div><br>
   The Windows library supports the following type parameters for the 
   install_joystick() function:
<ul><li>
   JOY_TYPE_AUTODETECT<br>
      Attempts to autodetect your joystick hardware. It will use information 
      from the configuration file if one is available (this can be created 
      using the setup utility or by calling the save_joystick_data()
      function), so you can always use JOY_TYPE_AUTODETECT in your code and
      then select the exact hardware type from the setup program.
<li>
   JOY_TYPE_NONE<br>
      Dummy driver for machines without any joystick.
<li>
   JOY_TYPE_DIRECTX<br>
      Use DirectInput to access the joystick.
<li>
   JOY_TYPE_WIN32<br>
      Use the regular Win32 interface rather than DirectInput to access the
      joystick.
</ul>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="GFX_*/Windows">GFX_*/Windows</a></b></div><br>
   The Windows library supports the following card parameters for the 
   set_gfx_mode() function:
<ul><li>
   GFX_TEXT<br>
      This closes any graphics mode previously opened with set_gfx_mode.
<li>
   GFX_AUTODETECT<br>
      Let Allegro pick an appropriate graphics driver.
<li>
   GFX_AUTODETECT_FULLSCREEN<br>
      Autodetects a graphics driver, but will only use fullscreen drivers,
      failing if these are not available on current platform.
<li>
   GFX_AUTODETECT_WINDOWED<br>
      Same as above, but uses only windowed drivers.
<li>
   GFX_SAFE<br>
      Special driver for when you want to reliably set a graphics mode and 
      don't really care what resolution or color depth you get. See the
      set_gfx_mode() documentation for details.
<li>
   GFX_DIRECTX<br>
      Alias for GFX_DIRECTX_ACCEL.
<li>
   GFX_DIRECTX_ACCEL<br>
      The regular fullscreen DirectX driver, running with hardware 
      acceleration enabled.
<li>
   GFX_DIRECTX_SOFT<br>
      DirectX fullscreen driver that only uses software drawing, rather than 
      any hardware accelerated features.
<li>
   GFX_DIRECTX_SAFE<br>
      Simplified fullscreen DirectX driver that doesn't support any hardware 
      acceleration, video or system bitmaps, etc.
<li>
   GFX_DIRECTX_WIN<br>
      The regular windowed DirectX driver, running in color conversion mode 
      when the color depth doesn't match that of the Windows desktop. Color 
      conversion is much slower than direct drawing and is not supported 
      between 15-bit and 16-bit color depths. This limitation is needed to 
      work around that of desktop_color_depth() (see above) and allows to 
      select the direct drawing mode in a reliable way on desktops reported 
      as 16-bit:
<blockquote class="code"><pre>
         if (<a href="#desktop_color_depth" class="autotype" title="Finds out the desktop color depth.">desktop_color_depth</a>() == 16) {
            <a href="#set_color_depth" class="autotype" title="Sets the global pixel color depth.">set_color_depth</a>(16);
            if (<a href="#set_gfx_mode" class="autotype" title="Sets a graphic video mode.">set_gfx_mode</a>(GFX_DIRECTX_WIN, 640, 480, 0, 0)
                != 0) {
               <a href="#set_color_depth" class="autotype" title="Sets the global pixel color depth.">set_color_depth</a>(15);
               if (<a href="#set_gfx_mode" class="autotype" title="Sets a graphic video mode.">set_gfx_mode</a>(GFX_DIRECTX_WIN, 640, 480, 0, 0)
                   != 0) {
                  /* 640x480 direct drawing mode not supported */
                  goto Error;
               }
            }
            /* ok, we are in direct drawing mode */
         }
</pre></blockquote>
      Note that, mainly for performance reasons, this driver requires the
      width of the screen to be a multiple of 4.
      This driver is capable of displaying a hardware cursor, but there are
      size restrictions. Typically, the cursor image cannot be more than
      32x32 pixels.
<li>
   GFX_DIRECTX_OVL<br>
      The DirectX overlay driver. It uses special hardware features to run 
      your program in a windowed mode: it doesn't work on all hardware, but 
      performance is excellent on cards that are capable of it. It requires 
      the color depth to be the same as that of the Windows desktop. In light 
      of the limitation of desktop_color_depth() (see above), the reliable 
      way of setting the overlay driver on desktops reported as 16-bit is:
<blockquote class="code"><pre>
         if (<a href="#desktop_color_depth" class="autotype" title="Finds out the desktop color depth.">desktop_color_depth</a>() == 16) {
            <a href="#set_color_depth" class="autotype" title="Sets the global pixel color depth.">set_color_depth</a>(16);
            if (<a href="#set_gfx_mode" class="autotype" title="Sets a graphic video mode.">set_gfx_mode</a>(GFX_DIRECTX_OVL, 640, 480, 0, 0)
                != 0) {
               <a href="#set_color_depth" class="autotype" title="Sets the global pixel color depth.">set_color_depth</a>(15);
               if (<a href="#set_gfx_mode" class="autotype" title="Sets a graphic video mode.">set_gfx_mode</a>(GFX_DIRECTX_OVL, 640, 480, 0, 0)
                   != 0) {
                  /* 640x480 overlay driver not supported */
                  goto Error;
               }
            }
            /* ok, the 640x480 overlay driver is running */
         }</pre></blockquote>
<li>
   GFX_GDI<br>
      The windowed GDI driver. It is extremely slow, but is guaranteed to 
      work on all hardware, so it can be useful for situations where you 
      want to run in a window and don't care about performance. Note that 
      this driver features a hardware mouse cursor emulation in order to 
      speed up basic mouse operations (like GUI operations).
</ul>

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="DIGI_*/Windows">DIGI_*/Windows</a></b></div><br>
   The Windows sound functions support the following digital sound cards:
<blockquote class="text"><pre>
      DIGI_AUTODETECT      - let Allegro pick a digital sound driver
      DIGI_NONE            - no digital sound
      DIGI_DIRECTX(n)      - use DirectSound device #n (zero-based)
                             with direct mixing
      DIGI_DIRECTAMX(n)    - use DirectSound device #n (zero-based)
                             with Allegro mixing
      DIGI_WAVOUTID(n)     - high (n=0) or low (n=1) quality WaveOut
                             device</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_digi_driver" title="Detects whether the specified digital sound device is available.">detect_digi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="MIDI_*/Windows">MIDI_*/Windows</a></b></div><br>
   The Windows sound functions support the following MIDI sound cards:
<blockquote class="text"><pre>
      MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
      MIDI_NONE            - no MIDI sound
      MIDI_WIN32MAPPER     - use win32 MIDI mapper
      MIDI_WIN32(n)        - use win32 device #n (zero-based)
      MIDI_DIGMID          - sample-based software wavetable player</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_midi_driver" title="Detects whether the specified MIDI sound device is available.">detect_midi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<br><center><h2><a name="Windows integration routines">Windows integration routines</a></h2></center><p>

<p>
The following functions provide a platform specific interface to seamlessly 
integrate Allegro into general purpose Win32 programs. To use these routines, 
you must include winalleg.h after other Allegro headers.

<p><br>
<div class="al-api"><b>HWND <a name="win_get_window">win_get_window</a>(void);</b></div><br>
   Retrieves a handle to the window used by Allegro. Note that Allegro
   uses an underlying window even though you don't set any graphics mode,
   unless you have installed the neutral system driver (SYSTEM_NONE).

<p><br>
<div class="al-api"><b>void <a name="win_set_window">win_set_window</a>(HWND wnd);</b></div><br>
   Registers an user-created window to be used by Allegro. This function is
   meant to be called before initialising the library with allegro_init()
   or installing the autodetected system driver (SYSTEM_AUTODETECT). It
   lets you attach Allegro to any already existing window and prevents the
   library from creating its own, thus leaving you total control over the
   window; in particular, you are responsible for processing the events as
   usual (Allegro will automatically monitor a few of them, but will not
   filter out any of them). You can then use every component of the library
   (graphics, mouse, keyboard, sound, timers and so on), bearing in mind
   that some Allegro functions are blocking (e.g. readkey() if the key buffer
   is empty) and thus must be carefully manipulated by the window thread.

<p>
   However you can also call it after the library has been initialised,
   provided that no graphics mode is set. In this case the keyboard, mouse,
   joystick, sound and sound recording modules will be restarted.

<p>
   Passing NULL instructs Allegro to switch back to its built-in window if
   an user-created window was registered, or to request a new handle from
   Windows for its built-in window if this was already in use.

<p><br>
<div class="al-api"><b>void <a name="win_set_wnd_create_proc">win_set_wnd_create_proc</a>(HWND (*proc)(WNDPROC));</b></div><br>
   Registers an user-defined procedure to be used by Allegro for creating
   its window. This function must be called *before* initializing the
   library with allegro_init() or installing the autodetected system
   driver (SYSTEM_AUTODETECT). It lets you customize Allegro's window but
   only by its creation: unlike with win_set_window(), you have no control
   over the window once it has been created (in particular, you are not
   responsible for processing the events). The registered function will be
   passed a window procedure (WNDPROC object) that it must make the 
   procedure of the new window of and it must return a handle to the new 
   window. You can then use the full-featured library in the regular way.

<p><br>
<div class="al-api"><b>HDC <a name="win_get_dc">win_get_dc</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Retrieves a handle to the device context of a DirectX video or system
   bitmap.

<p><br>
<div class="al-api"><b>void <a name="win_release_dc">win_release_dc</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, HDC dc);</b></div><br>
   Releases a handle to the device context of the bitmap that was
   previously retrieved with win_get_dc().

<p>
<br><center><h2><a name="GDI routines">GDI routines</a></h2></center><p>

<p>
The following GDI routines are a very platform specific thing, to allow 
drawing Allegro memory bitmaps onto a Windows device context. When you want 
to use this, you'll have to install the neutral system driver (SYSTEM_NONE) 
or attach Allegro to an external window with win_set_window().

<p>
There are two ways to draw your Allegro bitmaps to the Windows GDI. When you 
are using static bitmaps (for example just some pictures loaded from a 
datafile), you can convert them to DDB (device-dependent bitmaps) with 
convert_bitmap_to_hbitmap() and then just use Win32's BitBlt() to draw it.

<p>
When you are using dynamic bitmaps (for example some things which react to 
user input), it's better to use set_palette_to_hdc() and blit_to_hdc() 
functions, which work with DIB (device-independent bitmaps).

<p>
There are also functions to blit from a device context into an Allegro 
BITMAP, so you can do things like screen capture.

<p>
All the drawing and conversion functions use the current palette as a color 
conversion table. You can alter the current palette with the 
set_palette_to_hdc() or select_palette() functions. Warning: when the GDI 
system color palette is explicitly changed, (by another application, for 
example) the current Allegro palette is not updated along with it!

<p>
To use these routines, you must include winalleg.h after Allegro headers.

<p><br>
<div class="al-api"><b>void <a name="set_gdi_color_format">set_gdi_color_format</a>(void);</b></div><br>
   Tells Allegro to use the GDI color layout for truecolor images. This is 
   optional, but it will make the conversions work faster. If you are going 
   to call this, you should do it right after initialising Allegro and 
   before creating any graphics.

<p><br>
<div class="al-api"><b>void <a name="set_palette_to_hdc">set_palette_to_hdc</a>(HDC dc, <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal);</b></div><br>
   Selects and realizes an Allegro palette on the specified device context.

<p><br>
<div class="al-api"><b>HPALETTE <a name="convert_palette_to_hpalette">convert_palette_to_hpalette</a>(<a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal);</b></div><br>
   Converts an Allegro palette to a Windows palette and returns a handle to 
   it. You should call DeleteObject() when you no longer need it.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#convert_hpalette_to_palette" title="Converts a Windows palette to an Allegro palette.">convert_hpalette_to_palette</a>.</blockquote>
<div class="al-api"><b>void <a name="convert_hpalette_to_palette">convert_hpalette_to_palette</a>(HPALETTE hpal, <a class="autotype" href="#PALETTE" title="Stores palette information.">PALETTE</a> pal);</b></div><br>
   Converts a Windows palette to an Allegro palette.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#convert_palette_to_hpalette" title="Converts an Allegro palette to a Windows palette.">convert_palette_to_hpalette</a>.</blockquote>
<div class="al-api"><b>HBITMAP <a name="convert_bitmap_to_hbitmap">convert_bitmap_to_hbitmap</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap);</b></div><br>
   Converts an Allegro memory bitmap to a Windows DDB and returns a handle 
   to it. This bitmap uses its own memory, so you can destroy the original 
   bitmap without affecting the converted one. You should call 
   DeleteObject() when you no longer need this bitmap.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#convert_hbitmap_to_bitmap" title="Creates an Allegro memory bitmap from a Windows DDB.">convert_hbitmap_to_bitmap</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="convert_hbitmap_to_bitmap">convert_hbitmap_to_bitmap</a>(HBITMAP bitmap);</b></div><br>
   Creates an Allegro memory bitmap from a Windows DDB.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#convert_bitmap_to_hbitmap" title="Converts an Allegro memory bitmap to a Windows DDB.">convert_bitmap_to_hbitmap</a>.</blockquote>
<div class="al-api"><b>void <a name="draw_to_hdc">draw_to_hdc</a>(HDC dc, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int x, int y);</b></div><br>
   Draws an entire Allegro bitmap to a Windows device context, using the 
   same parameters as the draw_sprite() function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#blit_to_hdc" title="Blits an Allegro memory bitmap to a Windows device context.">blit_to_hdc</a>,
<a class="xref" href="#stretch_blit_to_hdc" title="Blits an Allegro memory bitmap to a Windows device context.">stretch_blit_to_hdc</a>,
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>.</blockquote>
<div class="al-api"><b>void <a name="blit_to_hdc">blit_to_hdc</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, HDC dc, int sx, sy, dx, dy, w, h);</b></div><br>
   Blits an Allegro memory bitmap to a Windows device context, using the 
   same parameters as the blit() function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_to_hdc" title="Draws an Allegro bitmap to a Windows device context.">draw_to_hdc</a>,
<a class="xref" href="#stretch_blit_to_hdc" title="Blits an Allegro memory bitmap to a Windows device context.">stretch_blit_to_hdc</a>,
<a class="xref" href="#blit_from_hdc" title="Blits from a Windows device context to an Allegro memory bitmap.">blit_from_hdc</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>.</blockquote>
<div class="al-api"><b>void <a name="stretch_blit_to_hdc">stretch_blit_to_hdc</a>(<a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, HDC dc, int sx, sy, sw, sh,
                                                 int dx, dy, dw, dh);</b></div><br>
   Blits an Allegro memory bitmap to a Windows device context, using the 
   same parameters as the stretch_blit() function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#draw_to_hdc" title="Draws an Allegro bitmap to a Windows device context.">draw_to_hdc</a>,
<a class="xref" href="#blit_to_hdc" title="Blits an Allegro memory bitmap to a Windows device context.">blit_to_hdc</a>,
<a class="xref" href="#stretch_blit_from_hdc" title="Blits from a Windows device context to an Allegro memory bitmap.">stretch_blit_from_hdc</a>,
<a class="xref" href="#stretch_blit" title="Scales a rectangular area from one bitmap to another.">stretch_blit</a>.</blockquote>
<div class="al-api"><b>void <a name="blit_from_hdc">blit_from_hdc</a>(HDC hdc, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int sx, sy, dx, dy, w, h);</b></div><br>
   Blits from a Windows device context to an Allegro memory bitmap, using 
   the same parameters as the blit() function. See stretch_blit_from_hdc() 
   for details.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#stretch_blit_from_hdc" title="Blits from a Windows device context to an Allegro memory bitmap.">stretch_blit_from_hdc</a>,
<a class="xref" href="#blit_to_hdc" title="Blits an Allegro memory bitmap to a Windows device context.">blit_to_hdc</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>.</blockquote>
<div class="al-api"><b>void <a name="stretch_blit_from_hdc">stretch_blit_from_hdc</a>(HDC hcd, <a class="autotype" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int sx, sy, sw, sh,
                                                    int dx, dy, dw, dh);</b></div><br>
   Blits from a Windows device context to an Allegro memory bitmap, using 
   the same parameters as the stretch_blit() function. It uses the current 
   Allegro palette and does conversion to this palette, regardless of the 
   current DC palette. So if you are blitting from 8-bit mode, you should 
   first set the DC palette with the set_palette_to_hdc() function.



<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#blit_from_hdc" title="Blits from a Windows device context to an Allegro memory bitmap.">blit_from_hdc</a>,
<a class="xref" href="#stretch_blit_to_hdc" title="Blits an Allegro memory bitmap to a Windows device context.">stretch_blit_to_hdc</a>,
<a class="xref" href="#stretch_blit" title="Scales a rectangular area from one bitmap to another.">stretch_blit</a>.</blockquote>
<h1><a name="Unix specifics">Unix specifics</a></h1>

<p>
Under Unix you usually have two ways of redistributing your binaries. You
either pack everything in a single directory, even providing Allegro in
binary or source form for the user to compile. Or your program is being
packaged separately from Allegro and stored in different paths. For the
first case of redistribution, read section "Files shared by Allegro" from
the "Dos specifics" chapter to learn more about this.

<p>
For the second type, you can ignore redistributing the setup, keyboard
mappings and language datafiles, because they will be already installed in
the system. This, however, is problematic if you are using get_config_text()
to localise your program's text strings.

<p>
The problem is that on other platforms you usually mix your program's text
strings with those of Allegro (found in the <tt>`resources'</tt> directory) to create
a special language.dat. And it is likely that the Allegro library installed
on the user's system already contains a datafile.dat. You can go ahead and
still provide your own language.dat file, but this will mean that if Allegro
is updated, your language.dat file may not contain all the text strings used
by the new version.

<p>
Given the slow paced release cycle of Allegro, this might not be a concern.
However, if you want to make it easy on system administrators, instead of
providing your own <tt>`language.dat'</tt>, you should provide the separate
<tt>`xxtext.cfg'</tt> files it in a separate directory. Then, before showing the
strings to the user you can detect the language setting and use
override_config_file() with the appropriate localisation file and call
reload_config_texts().

<p>
In order to locate things like the config and translation files, Allegro
needs to know the path to your executable. Since there is no standard way to 
find that, it needs to capture a copy of your argv[] parameter, and it does 
this with some preprocessor macro trickery. Unfortunately it can't quite 
pull this off without a little bit of your help, so you will have to write 
END_OF_MAIN() right after your main() function. Pretty easy, really, and if 
you forget, you'll get a nice linker error about a missing _mangled_main 
function to remind you :-)

<p>
Under Unix resources are searched for in many different paths (see above).
When a configuration resource is looked for, it is usually tried with the
variations <tt>`name.cfg'</tt> or <tt>`.namerc'</tt> in multiple paths: the current directory,
the directory pointed to by the ALLEGRO environment variable, the user's home
directory, one or more global system directories which usually only the
root user has access to and any custom paths set up with
set_allegro_resource_path(). Text files, like the main allegro config file or
a language text translation files are looked for in the following places:
<blockquote class="text"><pre>
   ./allegro.cfg
   $ALLEGRO/allegro.cfg
   ~/allegro.cfg
   ~/.allegrorc
   /etc/allegro.cfg
   /etc/allegrorc
</pre></blockquote>
Binary resources like the language translation files packfile (language.dat)
are looked for in:
<blockquote class="text"><pre>
   ./language.dat
   $ALLEGRO/language.dat
   ~/language.dat
   /etc/language.dat
   /usr/share/allegro/language.dat
   /usr/local/share/allegro/language.dat
</pre></blockquote>
Note that if you have installed Allegro from the source distribution with
the typical `<tt>make install</tt>', global files like <tt>`language.dat'</tt> and
<tt>`allegro.cfg'</tt> will not have been installed. As a system administrator you are
required to install them manually wherever you prefer to have them. If you
suspect that an Allegro program is somehow not finding the correct
configuration file, you could try using the following command:
<blockquote class="text"><pre>
   strace program 2>&amp;1|egrep "(open|stat)"
</pre></blockquote>
The strace program traces system calls and signals. By default it outputs
the information to stderr, so that's why we redirect it to stdin with `<tt>2>&amp;1</tt>'.
Since we are interested only in files being (un)successfully opened, we
restrict the output of the log to stat or open calls with the extended grep
command. You could add another grep to filter only lines with text like
<tt>`language'</tt> or <tt>`allegro'</tt>.

<p><br>
<div class="al-api"><b>Drivers <a name="JOY_TYPE_*/Linux">JOY_TYPE_*/Linux</a></b></div><br>
   The Linux library supports the following type parameters for the 
   install_joystick() function:
<ul><li>
   JOY_TYPE_AUTODETECT<br>
      Attempts to autodetect your joystick hardware. It will use information 
      from the configuration file if one is available (this can be created 
      using the setup utility or by calling the save_joystick_data()
      function), so you can always use JOY_TYPE_AUTODETECT in your code and
      then select the exact hardware type from the setup program.
<li>
   JOY_TYPE_NONE<br>
      Dummy driver for machines without any joystick.
<li>
   JOY_TYPE_LINUX_ANALOGUE<br>
      Regular joystick interface. Joystick support needs to be enabled in your
      kernel.
</ul>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="GFX_*/Linux">GFX_*/Linux</a></b></div><br>
   When running in Linux console mode, Allegro supports the following card 
   parameters for the set_gfx_mode() function:
<ul><li>
   GFX_TEXT<br>
      Return to text mode.
<li>
   GFX_AUTODETECT<br>
      Let Allegro pick an appropriate graphics driver.
<li>
   GFX_AUTODETECT_FULLSCREEN<br>
      Autodetects a graphics driver, but will only use fullscreen drivers,
      failing if these are not available on current platform.
<li>
   GFX_AUTODETECT_WINDOWED<br>
      Same as above, but uses only windowed drivers. This will always fail
      under Linux console mode.
<li>
   GFX_SAFE<br>
      Special driver for when you want to reliably set a graphics mode and 
      don't really care what resolution or color depth you get. See the
      set_gfx_mode() documentation for details.
<li>
   GFX_FBCON<br>
      Use the framebuffer device (eg. /dev/fb0). This requires you to have 
      framebuffer support compiled into your kernel, and correctly 
      configured for your hardware. It is currently the only console mode 
      driver that will work without root permissions, unless you are using
      a development version of SVGAlib.
<li>
   GFX_VBEAF<br>
      Use a VBE/AF driver (vbeaf.drv), assuming that you have installed one 
      which works under Linux (currently only two of the FreeBE/AF project 
      drivers are capable of this: I don't know about the SciTech ones). 
      VBE/AF requires root permissions, but is currently the only Linux 
      driver which supports hardware accelerated graphics.
<li>
   GFX_SVGALIB<br>
      Use the SVGAlib library for graphics output. This requires root
      permissions if your version of SVGAlib requires them.
<li>
   GFX_VGA<br>
   GFX_MODEX<br>
      Use direct hardware access to set standard VGA or mode-X resolutions, 
      supporting the same modes as in the DOS versions of these drivers. 
      Requires root permissions.
</ul>

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#GFX_*/X" title="Supported X graphic drivers.">GFX_*/X</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="GFX_*/X">GFX_*/X</a></b></div><br>
   When running in X mode, Allegro supports the following card parameters 
   for the set_gfx_mode() function:
<ul><li>
   GFX_TEXT<br>
      This closes any graphics mode previously opened with set_gfx_mode.
<li>
   GFX_AUTODETECT<br>
      Let Allegro pick an appropriate graphics driver.
<li>
   GFX_AUTODETECT_FULLSCREEN<br>
      Autodetects a graphics driver, but will only use fullscreen drivers,
      failing if these are not available on current platform.
<li>
   GFX_AUTODETECT_WINDOWED<br>
      Same as above, but uses only windowed drivers.
<li>
   GFX_SAFE<br>
      Special driver for when you want to reliably set a graphics mode and 
      don't really care what resolution or color depth you get. See the
      set_gfx_mode() documentation for details.
<li>
   GFX_XWINDOWS<br>
      The standard X graphics driver. This should work on any Unix system, 
      and can operate remotely. It does not require root permissions.
      If the ARGB cursor extension is available, this driver is capable
      of displaying a hardware cursor. This needs to be enabled by calling
      enable_hardware_cursor() because it cannot be used reliably alongside
      get_mouse_mickeys().
<li>
   GFX_XWINDOWS_FULLSCREEN<br>
      The same as above, but while GFX_XWINDOWS runs windowed, this one uses
      the XF86VidMode extension to make it run in fullscreen mode even
      without root permissions. You're still using the standard X protocol
      though, so expect the same low performances as with the windowed
      driver version.
      If the ARGB cursor extension is available, this driver is capable
      of displaying a hardware cursor. This needs to be enabled by calling
      enable_hardware_cursor() because it cannot be used reliably alongside
      get_mouse_mickeys().
<li>
   GFX_XDGA2<br>
      Use new DGA 2.0 extension provided by XFree86 4.0.x. This will work
      in fullscreen mode, and it will support hardware acceleration if
      available. This driver requires root permissions.
<li>
   GFX_XDGA2_SOFT<br>
      The same as GFX_XDGA2, but turns off hardware acceleration support.
      This driver requires root permissions.
</ul>

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#GFX_*/Linux" title="Supported Linux console graphic drivers.">GFX_*/Linux</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="DIGI_*/Unix">DIGI_*/Unix</a></b></div><br>
   The Unix sound functions support the following digital sound cards:
<blockquote class="text"><pre>
      DIGI_AUTODETECT      - let Allegro pick a digital sound driver
      DIGI_NONE            - no digital sound
      DIGI_OSS             - Open Sound System
      DIGI_ESD             - Enlightened Sound Daemon
      DIGI_ARTS            - aRts (Analog Real-Time Synthesizer)
      DIGI_ALSA            - ALSA sound driver
      DIGI_JACK            - JACK sound driver</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_digi_driver" title="Detects whether the specified digital sound device is available.">detect_digi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="MIDI_*/Unix">MIDI_*/Unix</a></b></div><br>
   The Unix sound functions support the following MIDI sound cards:
<blockquote class="text"><pre>
      MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
      MIDI_NONE            - no MIDI sound
      MIDI_OSS             - Open Sound System
      MIDI_DIGMID          - sample-based software wavetable player
      MIDI_ALSA            - ALSA RawMIDI driver</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_midi_driver" title="Detects whether the specified MIDI sound device is available.">detect_midi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<br><center><h2><a name="Unix integration routines">Unix integration routines</a></h2></center><p>

<p><br>
<div class="al-api"><b>void <a name="xwin_set_window_name">xwin_set_window_name</a>(const char *name, const char *group);</b></div><br>
   This function is only available under X. It lets you to specify the
   window name and group (or class). They are important because they allow
   the window manager to remember the window attributes (position, layer,
   etc). Note that the name and the title of the window are two different
   things: the title is what appears in the title bar of the window, but
   usually has no other effects on the behaviour of the application.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_window_title" title="Sets the window title of the Allegro program.">set_window_title</a>.</blockquote>
<div class="al-api"><b>extern void *<a name="allegro_icon">allegro_icon</a>;</b></div><br>
   This is a pointer to the Allegro X11 icon, which is in the format of 
   standard .xpm bitmap data.
   You do not normally have to bother with this at all: you can use the
   xfixicon.sh utility from the tools/x11 directory to convert a true 
   colour bitmap to a C file that you only need to link with your own code
   to set the icon.



<p><br>
<h1><a name="BeOS specifics">BeOS specifics</a></h1>

<p>
In terms of file redistribution, the BeOS platform behaves practically the
same as the DOS platform. Read section chapter "Dos specifics" in the manual
to learn more about this.

<p><br>
<div class="al-api"><b>Drivers <a name="GFX_*/BeOS">GFX_*/BeOS</a></b></div><br>
   BeOS Allegro supports the following card parameters for the
   set_gfx_mode() function:
<ul><li>
   GFX_TEXT<br>
      This closes any graphics mode previously opened with set_gfx_mode.
<li>
   GFX_AUTODETECT<br>
      Let Allegro pick an appropriate graphics driver.
<li>
   GFX_AUTODETECT_FULLSCREEN<br>
      Autodetects a graphics driver, but will only use fullscreen drivers,
      failing if these are not available on current platform.
<li>
   GFX_AUTODETECT_WINDOWED<br>
      Same as above, but uses only windowed drivers.
<li>
   GFX_SAFE<br>
      Special driver for when you want to reliably set a graphics mode and 
      don't really care what resolution. See the set_gfx_mode() 
      documentation for details.
<li>
   GFX_BWINDOWSCREEN_ACCEL<br>
      Fullscreen exclusive mode. Supports only resolutions higher or equal
      to 640x480, and uses hardware acceleration if available.
<li>
   GFX_BWINDOWSCREEN<br>
      Works the same as GFX_BWINDOWSCREEN_ACCEL, but disables acceleration.
<li>
   GFX_BDIRECTWINDOW<br>
      Fast windowed mode using the BDirectWindow class. Not all graphics
      cards support this.
<li>
   GFX_BWINDOW<br>
      Normal windowed mode using the BWindow class. Slow but always works.
<li>
   GFX_BWINDOW_OVERLAY<br>
      Fullscreen mode using BWindow with a BBitmap overlay. This mode isn't
      supported by all graphics cards, only supports 15, 16 and 32-bit color
      depths, but allows any fullscreen resolution, even low ones that are
      normally unavailable under BeOS.
</ul>

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="DIGI_*/BeOS">DIGI_*/BeOS</a></b></div><br>
   The BeOS sound functions support the following digital sound cards:
<blockquote class="text"><pre>
      DIGI_AUTODETECT      - let Allegro pick a digital sound driver
      DIGI_NONE            - no digital sound
      DIGI_BEOS            - BeOS digital output</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_digi_driver" title="Detects whether the specified digital sound device is available.">detect_digi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="MIDI_*/BeOS">MIDI_*/BeOS</a></b></div><br>
   The BeOS sound functions support the following MIDI sound cards:
<blockquote class="text"><pre>
      MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
      MIDI_NONE            - no MIDI sound
      MIDI_BEOS            - BeOS MIDI output
      MIDI_DIGMID          - sample-based software wavetable player
</pre></blockquote>



<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_midi_driver" title="Detects whether the specified MIDI sound device is available.">detect_midi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<h1><a name="QNX specifics">QNX specifics</a></h1>

<p>
In terms of file redistribution, the QNX platform behaves practically the
same as the DOS platform. Read section chapter "Dos specifics" in the manual
to learn more about this.

<p><br>
<div class="al-api"><b>Drivers <a name="GFX_*/QNX">GFX_*/QNX</a></b></div><br>
   QNX Allegro supports the following card parameters for the
   set_gfx_mode() function:
<ul><li>
   GFX_TEXT<br>
      This closes any graphics mode previously opened with set_gfx_mode.
<li>
   GFX_AUTODETECT<br>
      Let Allegro pick an appropriate graphics driver.
<li>
   GFX_AUTODETECT_FULLSCREEN<br>
      Autodetects a graphics driver, but will only use fullscreen drivers,
      failing if these are not available on current platform.
<li>
   GFX_AUTODETECT_WINDOWED<br>
      Same as above, but uses only windowed drivers.
<li>
   GFX_SAFE<br>
      Special driver for when you want to reliably set a graphics mode and 
      don't really care what resolution. See the set_gfx_mode() 
      documentation for details.
<li>
   GFX_PHOTON<br>
      Alias for GFX_PHOTON_ACCEL.
<li>
   GFX_PHOTON_ACCEL<br>
      Fullscreen exclusive mode through Photon, running with hardware 
      acceleration enabled.
<li>
   GFX_PHOTON_SOFT<br>
      Fullscreen exclusive mode that only uses software drawing, rather than
      any hardware accelerated features.
<li>
   GFX_PHOTON_SAFE<br>
      Simplified fullscreen exclusive driver that doesn't support any
      hardware acceleration, video or system bitmaps, etc.
<li>
   GFX_PHOTON_WIN<br>
      The regular windowed Photon driver, running in color conversion mode 
      when the color depth doesn't match that of the Photon desktop. Color 
      conversion is much slower than direct drawing. Note that, mainly for
      performance reasons, this driver requires the width of the screen to
      be a multiple of 4.
</ul>

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="DIGI_*/QNX">DIGI_*/QNX</a></b></div><br>
   The QNX sound functions support the following digital sound cards:
<blockquote class="text"><pre>
      DIGI_AUTODETECT      - let Allegro pick a digital sound driver
      DIGI_NONE            - no digital sound
      DIGI_ALSA            - ALSA sound driver</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_digi_driver" title="Detects whether the specified digital sound device is available.">detect_digi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="MIDI_*/QNX">MIDI_*/QNX</a></b></div><br>
   The QNX sound functions support the following MIDI sound cards:
<blockquote class="text"><pre>
      MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
      MIDI_NONE            - no MIDI sound
      MIDI_ALSA            - ALSA RawMIDI driver
      MIDI_DIGMID          - sample-based software wavetable player
</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_midi_driver" title="Detects whether the specified MIDI sound device is available.">detect_midi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<br><center><h2><a name="QNX integration routines">QNX integration routines</a></h2></center><p>

<p>
The following functions provide a platform specific interface to seamlessly 
integrate Allegro into general purpose QNX programs. To use these routines, 
you must include qnxalleg.h after other Allegro headers.

<p><br>
<div class="al-api"><b>PtWidget_t <a name="qnx_get_window">qnx_get_window</a>(void);</b></div><br>
   Retrieves a handle to the window used by Allegro. Note that Allegro
   uses an underlying window even though you don't set any graphics mode,
   unless you have installed the neutral system driver (SYSTEM_NONE).



<p><br>
<h1><a name="MacOS X specifics">MacOS X specifics</a></h1>

<p>
In terms of file redistribution, the MacOS X platform behaves practically the
same as the DOS platform. Read section chapter "Dos specifics" in the manual
to learn more about this.

<p>
Allegro programs under MacOS X are Cocoa applications; in order to hide all
the Cocoa interfacing to the end-user, you need to add the END_OF_MAIN()
macro right after your main() function. This is a necessary step: if you omit
it, your program will not compile.

<p>
The END_OF_MAIN() macro simply does some magic to make sure your program
executes another function before your main(); this function is defined into
the liballeg-main.a static library, which is automatically linked if you use
the allegro-config script when linking. Otherwise be sure you link against it
unless you want to get undefined symbol errors.

<p>
To behave nicely with the MacOS X user interface, Allegro apps will provide a
standard application menu with the "Quit" menu item in it. The default
behaviour when the user hits Command-Q or selects "Quit" is to do nothing.
To override this behaviour you must call the set_close_button_callback() function; under MacOS
X the supplied callback will be used either if the user clicks the window
close button either on Command-Q or "Quit" selection. In this last case the
application will not shutdown, but you are supposed to set some quit flag
in your callback and check for it on a regular basis in your main program
loop.

<p>
If you would like to use InterfaceBuilder to design a more
fully-featured menu, Allegro will automatically load it if you create
a bundle for your application. The use of InterfaceBuilder is beyond
the scope of this document. Briefly, you need to create a Nib, called
MainMenu.nib, containing a main menu and a controller. Then, when you
create the bundle, install MainMenu.nib into the Contents/Resources
subdirectory. Note that the actions attached to the menu items will be
called from a different thread than the one in which your Allegro code
is running. Therefore you should not do any work there (especially,
don't call Allegro functions.) Instead, set a variable, and test it in
your main loop.

<p><br>
<div class="al-api"><b>Drivers <a name="GFX_*/MacOSX">GFX_*/MacOSX</a></b></div><br>
   MacOS X Allegro supports the following card parameters for the
   set_gfx_mode() function:
<ul><li>
   GFX_TEXT<br>
      This closes any graphics mode previously opened with set_gfx_mode.
<li>
   GFX_AUTODETECT<br>
      Let Allegro pick an appropriate graphics driver.
<li>
   GFX_AUTODETECT_FULLSCREEN<br>
      Autodetects a graphics driver, but will only use fullscreen drivers,
      failing if these are not available on current platform.
<li>
   GFX_AUTODETECT_WINDOWED<br>
      Same as above, but uses only windowed drivers.
<li>
   GFX_SAFE<br>
      Special driver for when you want to reliably set a graphics mode and 
      don't really care what resolution. See the set_gfx_mode() 
      documentation for details.
<li>
   GFX_QUARTZ_FULLSCREEN<br>
      Fullscreen exclusive mode, using the CGDirectDisplay interface. 
      Supports only resolutions higher or equal to 640x480, and uses 
      hardware acceleration if available.
<li>
   GFX_QUARTZ_WINDOW<br>
      Windowed mode using QuickDraw in a Cocoa window.
</ul>

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="DIGI_*/MacOSX">DIGI_*/MacOSX</a></b></div><br>
   The MacOS X sound functions support the following digital sound cards:
<blockquote class="text"><pre>
      DIGI_AUTODETECT      - let Allegro pick a digital sound driver
      DIGI_NONE            - no digital sound
      DIGI_CORE_AUDIO      - CoreAudio digital output (OS >= X.2 required)
      DIGI_SOUND_MANAGER   - Carbon Sound Manager digital output
</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_digi_driver" title="Detects whether the specified digital sound device is available.">detect_digi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<div class="al-api"><b>Drivers <a name="MIDI_*/MacOSX">MIDI_*/MacOSX</a></b></div><br>
   The MacOS X sound functions support the following MIDI sound cards:
<blockquote class="text"><pre>
      MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
      MIDI_NONE            - no MIDI sound
      MIDI_CORE_AUDIO      - CoreAudio MIDI synthesizer (OS >= X.2 required)
      MIDI_QUICKTIME       - QuickTime Music Note Allocator MIDI output
      MIDI_DIGMID          - sample-based software wavetable player
</pre></blockquote>



<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#detect_midi_driver" title="Detects whether the specified MIDI sound device is available.">detect_midi_driver</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_sound_input" title="Initialises the sound recorder module.">install_sound_input</a>.</blockquote>
<h1><a name="Differences between platforms">Differences between platforms</a></h1>

<p>
Here's a quick summary of things that may cause problems when moving your 
code from one platform to another (you can find a more detailed version of 
this in the docs section of the Allegro website).

<p>
The Windows, Unix and MacOS X versions require you to write END_OF_MAIN() 
after your main() function. This is used to magically turn an ISO C style 
main() into a Windows style WinMain(), or by the Unix code to grab a copy
of your argv[] parameter, or by the MacOS X code to shell the user main() 
inside a Cocoa application.

<p>
On many platforms Allegro runs very slowly if you rely on it in order to 
automatically lock bitmaps when drawing onto them. For good performance, 
you need to call acquire_bitmap() and release_bitmap() yourself, and try 
to keep the amount of locking to a minimum.

<p>
The Windows version may lose the contents of video memory if the user 
switches away from your program, so you need to deal with that.

<p>
None of the currently supported platforms require input polling, but it is 
possible that some future ones might, so if you want to ensure 100% 
portability of your program, you should call poll_mouse() and 
poll_keyboard() in all the relevant places.

<p>
On Unix the shared files by Allegro (like <tt>`language.dat'</tt>) may require a
special use due to the nature of distributing the resources in separate paths
instead of putting everything in the same directory. Check the beginning of
your platform's specific chapter to learn more about this.

<p>
Allegro defines a number of standard macros that can be used to check 
various attributes of the current platform:

<p>
<b>ALLEGRO_PLATFORM_STR</b><br>
   Text string containing the name of the current platform.

<p>
<b>ALLEGRO_DOS</b><br>
<b>ALLEGRO_DJGPP</b><br>
<b>ALLEGRO_WATCOM</b><br>
<b>ALLEGRO_WINDOWS</b><br>
<b>ALLEGRO_MSVC</b><br>
<b>ALLEGRO_MINGW32</b><br>
<b>ALLEGRO_BCC32</b><br>
<b>ALLEGRO_UNIX</b><br>
<b>ALLEGRO_LINUX</b><br>
<b>ALLEGRO_BEOS</b><br>
<b>ALLEGRO_QNX</b><br>
<b>ALLEGRO_DARWIN</b><br>
<b>ALLEGRO_MACOSX</b><br>
<b>ALLEGRO_GCC</b><br>
   Defined if you are building for a relevant system. Often several of these 
   will apply, eg. DOS+Watcom, or Windows+GCC+MinGW.

<p>
   Note that ALLEGRO_LINUX is a misnomer. It will only be defined if
   <i>Linux console</i> support is enabled. It is not a reliable way to check
   if the program is being built on a Linux system.

<p>
<b>ALLEGRO_AMD64</b><br>
<b>ALLEGRO_I386</b><br>
<b>ALLEGRO_BIG_ENDIAN</b><br>
<b>ALLEGRO_LITTLE_ENDIAN</b><br>
   Defined if you are building for a processor of the relevant type.

<p>
<b>ALLEGRO_MULTITHREADED</b><br>
   Defined if the library is internally multi-threaded on this system.

<p>
<b>ALLEGRO_USE_CONSTRUCTOR</b><br>
   Defined if the compiler supports constructor/destructor functions.

<p>
<b>ALLEGRO_VRAM_SINGLE_SURFACE</b><br>
   Defined if the screen is a single large surface that is then partitioned 
   into multiple video sub-bitmaps (eg. DOS), rather than each video bitmap 
   being a totally unique entity (eg. Windows).

<p>
<b>ALLEGRO_CONSOLE_OK</b><br>
   Defined if when you are not in a graphics mode, there is a text mode 
   console that you can printf() to, and from which the user could 
   potentially redirect stdout to capture it even while you are in a 
   graphics mode. If this define is absent, you are running in an 
   environment like Windows that has no stdout at all.

<p>
<b>ALLEGRO_MAGIC_MAIN</b><br>
   Defined if Allegro uses a magic main, i.e takes over the main() entry 
   point and turns it into a secondary entry point suited to its needs.

<p>
<b>ALLEGRO_LFN</b><br>
   Non-zero if long filenames are supported, or zero if you are limited to 
   8.3 format (in the DJGPP version, this is a variable depending on the 
   runtime environment).

<p>
<b>LONG_LONG</b><br>
   Defined to whatever represents a 64-bit "long long" integer for the 
   current compiler, or not defined if that isn't supported.

<p>
<b>OTHER_PATH_SEPARATOR</b><br>
   Defined to a path separator character other than a forward slash for 
   platforms that use one (eg. a backslash under DOS and Windows), or 
   defined to a forward slash if there is no other separator character.

<p>
<b>DEVICE_SEPARATOR</b><br>
   Defined to the filename device separator character (a colon for DOS and 
   Windows), or to zero if there are no explicit devices in paths (Unix).

<p>
Allegro can be customized at compile time to a certain extent with the
following macros:

<p>
<b>ALLEGRO_NO_MAGIC_MAIN</b><br>
   If you define this prior to including Allegro headers, Allegro won't
   touch the main() entry point. This effectively removes the requirement
   on a program to be linked against the Allegro library when it includes
   the allegro.h header file. Note that the configuration and file routines
   are not guaranteed to work on Unix systems when this symbol is defined.
   Moreover, on Darwin/MacOS X systems, this symbol simply prevents the
   program from being linked against the Allegro library! This highly non
   portable feature is primarily intended to be used under Windows.

<p>
<b>ALLEGRO_USE_CONSOLE</b><br>
   If you define this prior to including Allegro headers, Allegro will be 
   set up for building a console application rather than the default GUI 
   program on some platforms (especially Windows).

<p>
<b>ALLEGRO_NO_STD_HEADER</b><br>
   If you define this prior to including Allegro headers, Allegro will not
   automatically include some standard headers (eg &lt;stddef.h&gt;) its own
   headers depend upon.

<p>
<b>ALLEGRO_NO_KEY_DEFINES</b><br>
   If you define this prior to including Allegro headers, Allegro will omit
   the definition of the KEY_* constants, which may clash with other headers.

<p>
<b>ALLEGRO_NO_FIX_ALIASES</b><br>
   The fixed point functions used to be named with an "f" prefix instead of
   "fix", eg. fixsqrt() used to be fsqrt(), but were renamed due to conflicts
   with some libc implementations. So backwards compatibility aliases are
   provided as static inline functions which map the old names to the new
   names, eg. fsqrt() calls fixsqrt(). If you define this symbol prior to
   including Allegro headers, the aliases will be turned off.

<p>
<b>ALLEGRO_NO_FIX_CLASS</b><br>
   If you define this symbol prior to including Allegro headers in a C++
   source file, the 'fix' class will not be made available. This mitigates
   problems with the 'fix' class's overloading getting in the way.

<p>
<b>ALLEGRO_NO_VHLINE_ALIAS</b><br>
   The <tt>`curses'</tt> API also defines functions called vline() and hline().
   To avoid a linker conflict when both libraries are used, we have
   internally renamed our functions and added inline function aliases which
   remap vline() and hline(). This should not be noticeable to most users.

<p>
   If you define ALLEGRO_NO_VHLINE_ALIAS prior to including Allegro headers,
   Allegro will not define the vline() and hline() aliases, e.g. so you can
   include curses.h and allegro.h in the same module.

<p>
<b>ALLEGRO_NO_CLEAR_BITMAP_ALIAS</b><br>
   If you define this prior to including Allegro headers, Allegro will not
   define the clear() backwards compatibility alias to clear_bitmap().

<p>
<b>ALLEGRO_NO_COMPATIBILITY</b><br>
   If you define this prior to including Allegro headers, Allegro will not
   include the backward compatibility layer. It is undefined by default so
   old programs can still be compiled with the minimum amount of issues,
   but you should define this symbol if you intend to maintain your code
   up to date with the latest versions of Allegro. It automatically turns
   off all backwards compatibility aliases.

<p>
Allegro also defines a number of standard macros that can be used to 
insulate you from some of the differences between systems:

<p>
<b>INLINE</b><br>
   Use this in place of the regular "inline" function modifier keyword, and 
   your code will work correctly on any of the supported compilers.

<p>
<b>RET_VOLATILE</b><br>
   Use this to declare a function with a volatile return value.

<p>
<b>ZERO_SIZE_ARRAY(type, name)</b><br>
   Use this to declare zero-sized arrays in terminal position inside 
   structures, like in the BITMAP structure. These arrays are effectively 
   equivalent to the flexible array members of ISO C99.

<p>
<b>AL_CONST</b><br>
   Use this in place of the regular "const" object modifier keyword, and 
   your code will work correctly on any of the supported compilers.

<p>
<b>AL_RAND()</b><br>
   On platforms that require it, this macro does a simple shift 
   transformation of the libc rand() function, in order to improve the 
   perceived randomness of the output series in the lower 16 bits.
   Where not required, it directly translates into a rand() call.



<p><br>
<h1><a name="Reducing your executable size">Reducing your executable size</a></h1>

<p>
Some people complain that Allegro produces very large executables. This is 
certainly true: with the DJGPP version, a simple "hello world" program will 
be about 200k, although the per-executable overhead is much less for 
platforms that support dynamic linking. But don't worry, Allegro takes up a 
relatively fixed amount of space, and won't increase as your program gets 
larger. As George Foot so succinctly put it, anyone who is concerned about 
the ratio between library and program code should just get to work and write 
more program code to catch up :-)

<p>
Having said that, there are several things you can do to make your programs 
smaller:
<ul><li>
For all platforms, you can use an executable compressor called UPX, which
is available at <a href="http://upx.sourceforge.net/">http://upx.sourceforge.net/</a>. This usually manages a
compression ratio of about 40%.
<li>
When using DJGPP: for starters, read the DJGPP FAQ section 8.14, and take
note of the -s switch. And don't forget to compile your program with
optimisation enabled!
<li>
If a DOS program is only going to run in a limited number of graphics modes, 
you can specify which graphics drivers you would like to include with the 
code:
<blockquote class="code"><pre>
   BEGIN_GFX_DRIVER_LIST
      driver1
      driver2
      etc...
   END_GFX_DRIVER_LIST
</pre></blockquote>
where the driver names are any of the defines:
<blockquote class="text"><pre>
   GFX_DRIVER_VBEAF
   GFX_DRIVER_VGA
   GFX_DRIVER_MODEX
   GFX_DRIVER_VESA3
   GFX_DRIVER_VESA2L
   GFX_DRIVER_VESA2B
   GFX_DRIVER_XTENDED
   GFX_DRIVER_VESA1
</pre></blockquote>
This construct must be included in only one of your C source files. The 
ordering of the names is important, because the autodetection routine works 
down from the top of the list until it finds the first driver that is able 
to support the requested mode. I suggest you stick to the default ordering 
given above, and simply delete whatever entries you aren't going to use.
<li>
If your DOS program doesn't need to use all the possible color depths, you 
can specify which pixel formats you want to support with the code:
<blockquote class="code"><pre>
   BEGIN_COLOR_DEPTH_LIST
      depth1
      depth2
      etc...
   END_COLOR_DEPTH_LIST
</pre></blockquote>
where the color depth names are any of the defines:
<blockquote class="text"><pre>
   COLOR_DEPTH_8
   COLOR_DEPTH_15
   COLOR_DEPTH_16
   COLOR_DEPTH_24
   COLOR_DEPTH_32
</pre></blockquote>
Removing any of the color depths will save quite a bit of space, with the 
exception of the 15 and 16-bit modes: these share a great deal of code, so 
if you are including one of them, there is no reason not to use both. Be 
warned that if you try to use a color depth which isn't in this list, your 
program will crash horribly!
<li>
In the same way as the above, you can specify which DOS sound drivers you 
want to support with the code:
<blockquote class="code"><pre>
   BEGIN_DIGI_DRIVER_LIST
      driver1
      driver2
      etc...
   END_DIGI_DRIVER_LIST
</pre></blockquote>
using the digital sound driver defines:
<blockquote class="text"><pre>
   DIGI_DRIVER_SOUNDSCAPE
   DIGI_DRIVER_AUDIODRIVE
   DIGI_DRIVER_WINSOUNDSYS
   DIGI_DRIVER_SB
</pre></blockquote>
and for the MIDI music:
<blockquote class="code"><pre>
   BEGIN_MIDI_DRIVER_LIST
      driver1
      driver2
      etc...
   END_MIDI_DRIVER_LIST
</pre></blockquote>
using the MIDI driver defines:
<blockquote class="text"><pre>
   MIDI_DRIVER_AWE32
   MIDI_DRIVER_DIGMID
   MIDI_DRIVER_ADLIB
   MIDI_DRIVER_MPU
   MIDI_DRIVER_SB_OUT
</pre></blockquote>
If you are going to use either of these sound driver constructs, you must 
include both.
<li>
Likewise for the DOS joystick drivers, you can declare an inclusion list:
<blockquote class="code"><pre>
   BEGIN_JOYSTICK_DRIVER_LIST
      driver1
      driver2
      etc...
   END_JOYSTICK_DRIVER_LIST
</pre></blockquote>
using the joystick driver defines:
<blockquote class="text"><pre>
   JOYSTICK_DRIVER_WINGWARRIOR
   JOYSTICK_DRIVER_SIDEWINDER
   JOYSTICK_DRIVER_GAMEPAD_PRO
   JOYSTICK_DRIVER_GRIP
   JOYSTICK_DRIVER_STANDARD
   JOYSTICK_DRIVER_SNESPAD
   JOYSTICK_DRIVER_PSXPAD
   JOYSTICK_DRIVER_N64PAD
   JOYSTICK_DRIVER_DB9
   JOYSTICK_DRIVER_TURBOGRAFX
   JOYSTICK_DRIVER_IFSEGA_ISA
   JOYSTICK_DRIVER_IFSEGA_PCI
   JOYSTICK_DRIVER_IFSEGA_PCI_FAST
</pre></blockquote>
The standard driver includes support for the dual joysticks, increased 
numbers of buttons, Flightstick Pro, and Wingman Extreme, because these are 
all quite minor variations on the basic code.
<li>
If you are _really_ serious about this size, thing, have a look at the top 
of include/allegro/alconfig.h and you will see the lines:
<blockquote class="code"><pre>
   #define ALLEGRO_COLOR8
   #define ALLEGRO_COLOR16
   #define ALLEGRO_COLOR24
   #define ALLEGRO_COLOR32
</pre></blockquote>
If you comment out any of these definitions and then rebuild the library, 
you will get a version without any support for the absent color depths, 
which will be even smaller than using the DECLARE_COLOR_DEPTH_LIST() macro. 
Removing the ALLEGRO_COLOR16 define will get rid of the support for both 15 
and 16-bit hicolor modes, since these share a lot of the same code.
</ul>
Note: the aforementioned methods for removing unused hardware drivers only 
apply to statically linked versions of the library, eg. DOS. On Windows and 
Unix platforms, you can build Allegro as a DLL or shared library, which 
prevents these methods from working, but saves so much space that you 
probably won't care about that. Removing unused color depths from alconfig.h 
will work on any platform, though.

<p>
If you are distributing a copy of the setup program along with your game, 
you may be able to get a dramatic size reduction by merging the setup code 
into your main program, so that only one copy of the Allegro routines will 
need to be linked. See setup.txt for details. In the DJGPP version, after 
compressing the executable, this will probably save you about 200k compared 
to having two separate programs for the setup and the game itself.



<p><br>
<h1><a name="Debugging">Debugging</a></h1>

<p>
There are three versions of the Allegro library: the normal optimised code, 
one with extra debugging support, and a profiling version. See the platform 
specific readme files for information about how to install and link with 
these alternative libs. Although you will obviously want to use the 
optimised library for the final version of your program, it can be very 
useful to link with the debug lib while you are working on it, because this 
will make debugging much easier, and includes assert tests that will help to 
locate errors in your code at an earlier stage. Allegro also contains some 
debugging helper functions:

<p><br>
<div class="al-api"><b>void <a name="ASSERT">ASSERT</a>(condition);</b></div><br>
   Debugging helper macro. Normally compiles away to nothing, but if you 
   defined the preprocessor symbol DEBUGMODE before including Allegro headers,
   it will check the supplied condition and call al_assert() if it fails,
   whose default action is to stop the program and report the assert. You can
   use this macro even when Allegro has not been initialised. Example:
<blockquote class="code"><pre>
      #define DEBUGMODE
      #include <allegro.h>
      ...
      void my_blitter(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *source, int flags)
      {
         int some_variables;
         <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(source != NULL);
         <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(flags &amp; GAME_RUNNING);
         ...
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#al_assert" title="Asserts at the specified file and line number.">al_assert</a>,
<a class="xref" href="#TRACE" title="Debugging helper macro to trace messages.">TRACE</a>,
<a class="xref" href="#register_assert_handler" title="Registers a custom handler for assert failures.">register_assert_handler</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="#expackf" title="Using custom PACKFILE vtables.">expackf</a>.</blockquote>
<div class="al-api"><b>void <a name="TRACE">TRACE</a>(char *msg, ...);</b></div><br>
   Debugging helper macro. Normally compiles away to nothing, but if you 
   defined the preprocessor symbol DEBUGMODE before including Allegro headers,
   it passes the supplied message given in ASCII format to al_trace().
   Example:
<blockquote class="code"><pre>
      #define DEBUGMODE
      #include <allegro.h>
      ...
      void my_blitter(<a href="#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *source, int flags)
      {
         static int count_call = 0;
         <a href="#TRACE" class="autotype" title="Debugging helper macro to trace messages.">TRACE</a>("my_blitter() called %d times.\n", count_call++);
         ...
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#al_trace" title="Outputs a debugging trace message.">al_trace</a>,
<a class="xref" href="#ASSERT" title="Debugging helper macro to assert.">ASSERT</a>,
<a class="xref" href="#register_trace_handler" title="Registers a custom handler for trace output.">register_trace_handler</a>.</blockquote>
<div class="al-api"><b>void <a name="register_assert_handler">register_assert_handler</a>(int (*handler)(const char *msg));</b></div><br>
   Supplies a custom handler function for dealing with assert failures. Your 
   callback will be passed a formatted error message in ASCII, and should 
   return non-zero if it has processed the error, or zero to continue with 
   the default actions. You could use this to ignore assert failures, or to 
   display the error messages on a graphics mode screen without aborting the 
   program. You can call this function even when Allegro has not been
   initialised. Example:
<blockquote class="code"><pre>
   int show_but_continue(const char *text)
   {
       <a href="#alert" class="autotype" title="Displays a popup alert box.">alert</a>("Uh oh...", "Fasten your seat belts.", text,
             "&amp;Go on!", NULL, 'g', 0);
       return 1;
   }
   ...
      register_assert(show_but_continue);
      <a href="#ASSERT" class="autotype" title="Debugging helper macro to assert.">ASSERT</a>(0); /* This won't crash the program now. */</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#al_assert" title="Asserts at the specified file and line number.">al_assert</a>,
<a class="xref" href="#ASSERT" title="Debugging helper macro to assert.">ASSERT</a>,
<a class="xref" href="#register_trace_handler" title="Registers a custom handler for trace output.">register_trace_handler</a>.</blockquote>
<div class="al-api"><b>void <a name="register_trace_handler">register_trace_handler</a>(int (*handler)(const char *msg));</b></div><br>
   Supplies a custom handler function for dealing with trace output. Your 
   callback will be passed a formatted error message in ASCII, and should 
   return non-zero if it has processed the message, or zero to continue with 
   the default actions. You could use this to ignore trace output, or to 
   display the messages on a second monochrome monitor, etc. You can call
   this function even when Allegro has not been initialised. Example:
<blockquote class="code"><pre>
   int network_broadcaster(const char *text)
   {
      int f;

      for (int f = 0; f < connected_clients; f++)
         send_msg_to_client(client[f], text);
         
      return 0; /* Let normal tracing occur. */
   }
   ...
      <a href="#register_trace_handler" class="autotype" title="Registers a custom handler for trace output.">register_trace_handler</a>(network_broadcaster);
      <a href="#TRACE" class="autotype" title="Debugging helper macro to trace messages.">TRACE</a>("Networked tracing activated\n");</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#al_trace" title="Outputs a debugging trace message.">al_trace</a>,
<a class="xref" href="#TRACE" title="Debugging helper macro to trace messages.">TRACE</a>,
<a class="xref" href="#register_assert_handler" title="Registers a custom handler for assert failures.">register_assert_handler</a>.</blockquote>
<div class="al-api"><b>void <a name="al_assert">al_assert</a>(const char *file, int line);</b></div><br>
   Raises an assert for an error at the specified file and line number. The 
   file parameter is always given in ASCII format. By default, this will call
   the system driver's assert handler. If there is none, the error will be
   sent to stderr and the program will abort. However, if the environment
   variable ALLEGRO_ASSERT is set, this function writes a message into the
   file specified by the environment variable and program execution will
   continue. If none of this behaviours is wanted, you can override them with
   a custom assert handler.

<p>
   You will usually want to use the ASSERT() macro instead of calling this
   function directly.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ASSERT" title="Debugging helper macro to assert.">ASSERT</a>,
<a class="xref" href="#al_trace" title="Outputs a debugging trace message.">al_trace</a>,
<a class="xref" href="#register_assert_handler" title="Registers a custom handler for assert failures.">register_assert_handler</a>.</blockquote>
<div class="al-api"><b>void <a name="al_trace">al_trace</a>(const char *msg, ...);</b></div><br>
   Outputs a debugging trace message, using a printf() format string given 
   in ASCII. If you have installed a custom trace handler it uses that, or 
   if the environment variable ALLEGRO_TRACE is set it writes into the file 
   specified by the environment, otherwise it writes the message to 
   "allegro.log" in the current directory. You will usually want to use the 
   TRACE() macro instead of calling this function directly.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#TRACE" title="Debugging helper macro to trace messages.">TRACE</a>,
<a class="xref" href="#al_assert" title="Asserts at the specified file and line number.">al_assert</a>,
<a class="xref" href="#register_trace_handler" title="Registers a custom handler for trace output.">register_trace_handler</a>.</blockquote>
<h1><a name="Makefile targets">Makefile targets</a></h1>

<p>
There are a number of options that you can use to control exactly how 
Allegro will be compiled. On Unix platforms, you do this by passing arguments 
to the configure script (run "configure --help" for a list), but on other 
platforms you can set the following environment variables:
<ul><li>
   DEBUGMODE=1<br>
   Selects a debug build, rather than the normal optimised version.
<li>
   DEBUGMODE=2<br>
   Selects a build intended to debug Allegro itself, rather than the
   normal optimised version.
<li>
   PROFILEMODE=1<br>
   Selects a profiling build, rather than the normal optimised version.
<li>
   WARNMODE=1<br>
   Selects strict compiler warnings. If you are planning to work on Allegro 
   yourself, rather than just using it in your programs, you should be sure 
   to have this mode enabled.
<li>
   STATICLINK=1 (MinGW, MSVC, BeOS, MacOS X only)<br>
   Link as a static library, rather than the default dynamic library.
<li>
   STATICRUNTIME=1 (MSVC only)<br>
   Link against static runtime libraries, rather than the default dynamic
   runtime libraries.
<li>
   TARGET_ARCH_COMPAT=[cpu] (GCC-based platforms only)<br>
   This option will optimize for the given processor while maintaining
   compatibility with older processors.
   Example: set TARGET_ARCH_COMPAT=i586
<li>
   TARGET_ARCH_EXCL=[cpu] (GCC-based platforms only)<br>
   This option will optimize for the given processor. Please note that
   using it will cause the code to *NOT* run on older processors.
   Example: set TARGET_ARCH_EXCL=i586
<li>
   TARGET_OPTS=[opts] (GCC-based platforms only)<br>
   This option allows you to customize general compiler optimisations.
<li>
   TARGET_ARCH_EXCL=[opts] (MSVC only)<br>
   This option allows you to optimize exclusively for a given architecture.
   Pass B to optimize for a PentiumPro or 7 to optimize for Pentium 4. Note
   that the options you can pass may be different between MSVC 6 and 7.
   Example: set TARGET_ARCH_EXCL=7
<li>
   CROSSCOMPILE=1 (DJGPP, MinGW only)<br>
   Allows you to build the library under Linux by using a cross-compiler.
<li>
   ALLEGRO_USE_C=1 (GCC-based platforms only)<br>
   Allows you to build the library using C drawing code instead of the usual
   asm routines. This is only really useful for testing, since the asm
   version is faster.
<li>
   UNIX_TOOLS=1<br>
   Instructs the build process to use Unix-like tools instead of DOS tools.
   Note that you usually don't need to set it because the build process will
   try to autodetect this configuration.
<li>
   COMPILER_MSVC7=1 (MSVC only)<br>
   Enables special optimizations for MSVC 7 (the default is MSVC 6). You don't
   normally need to set this flag since <i>fix.bat msvc7</i> should do the same
   thing and is the preferred way of doing this.
<li>
   COMPILER_ICL=1 (MSVC only)<br>
   Instructs the build process to use the Intel command line compiler icl rather
   than Microsoft's command line compiler cl. You don't normally need to pass 
   this flag since <i>fix.bat icl</i> should do the same thing and is the 
   preferred way of doing this. Do not try COMPILER_MSVC7=1 and COMPILER_ICL=1
   at the same time.
</ul>
If you only want to recompile a specific test program or utility, you can 
specify it as an argument to make, eg. "make demo" or "make grabber". The 
makefiles also provide some special pseudo-targets:
<ul><li>
   'info' (Unix only)<br>
   Tells you which options this particular build of Allegro will use.
   Especially useful to verify that the required libraries were detected
   and you won't get a 'half-featured' Allegro.
<li>
   'default'<br>
   The normal build process. Compiles the current library version (one of 
   optimised, debugging, or profiling, selected by the above environment 
   variables), builds the test and example programs, and converts the 
   documentation files.
<li>
   'all' (non-Unix only)<br>
   Compiles all three library versions (optimised, debugging, and 
   profiling), builds the test and example programs, and converts the 
   documentation files.
<li>
   'lib'<br>
   Compiles the current library version (one of optimised, debugging, or 
   profiling, selected by the above environment variables).
<li>
   'modules' (Unix only)<br>
    This will compile all the modules currently configured. The 'lib' and
    'modules' targets together are needed to build a working copy of the
    library, without documentation or programs.
<li>
   'install'<br>
   Copies the current library version (one of optimised, debugging, or 
   profiling, selected by the above environment variables), into your 
   compiler lib directory, recompiling it as required, and installs the 
   Allegro headers.
<li>
   'install-lib' (Unix only)<br>
   You can use this to install the library and the modules only, without
   documentation or programs.  Use the 'install' target to install
   everything.
<li>
   'installall' (non-Unix only)<br>
   Copies all three library versions (optimised, debugging, and profiling), 
   into your compiler lib directory, recompiling them as required, and 
   installs the Allegro headers.
<li>
   'uninstall'<br>
   Removes the Allegro library and headers from your compiler directories. 
<li>
   'docs'<br>
   Converts the documentation files from the ._tx sources.
<li>
   'chm-docs' (Windows only)<br>
   Creates a compiled HTML file from the previously generated html output.
   This is not a default target, since you need Microsoft's HTML compiler
   (<a href="http://go.microsoft.com/fwlink/?LinkId=14188">http://go.microsoft.com/fwlink/?LinkId=14188</a>),
   and it has to be installed somewhere in your PATH. Also, this only works
   if you use '@multiplefiles' (see the top of docs/src/allegro._tx).
<li>
   'docs-dvi' (Unix only)<br>
   Creates the allegro.dvi device independent documentation file. This is
   not a default target, since you need the texi2dvi tool to create it. The
   generated file is especially prepared to be printed on paper.
<li>
   'docs-ps' or 'docs-gzipped-ps' or 'docs-bzipped-ps' (Unix only)<br>
   Creates a PostScript file from the previously generated DVI file. This is
   not a default target, since you need the texi2dvi and dvips tools to
   create it. The second and third targets compress the generated Postscript
   file. The generated file is especially prepared to be printed on paper.
<li>
   'docs-pdf' (Unix only)<br>
   Creates a PDF file. This is not a default target, since you need the
   texi2pdf tool to create it. The generated file is especially prepared to
   be printed on paper, and it also has hyperlinks.
<li>
   'docs-devhelp' (Unix only)<br>
   Creates normal HTML documentation with an additional xml index file which
   can be used by tools like Devhelp (<a href="http://www.devhelp.net/">http://www.devhelp.net/</a>) to
   show context sensitive help within any editor using Devhelp, like for
   example <a href="http://anjuta.sourceforge.net/">http://anjuta.sourceforge.net/</a>. The Allegro 'book' will be
   created in <tt>`docs/devhelp/allegro.devhelp'</tt>, you have to install it
   manually.
<li>
   'install-man' (Unix and Mac OS X only)<br>
   Generates Unix man pages for each Allegro function or variable and
   installs them.
<li>
   'install-gzipped-man' or 'install-bzipped-man' (Unix only)<br>
   Like install-man, but also compresses the manual pages after installing
   them (run only one of these).
<li>
   'uninstall-man' (Unix)<br>
   Uninstalls any man pages previously installed with 'install-man',
   'install-gzipped-man', or 'install-bzipped-man'.
<li>
   'install-info' or 'install-gzipped-info' or 'install-bzipped-info'
   (Unix only)<br>
   Converts the documentation to Info format and installs it. The second
   and third targets compress the info file after installing it (run only
   one of them).
<li>
   'uninstall-info' (Unix only)<br>
   Uninstalls any man pages previously installed with 'install-info',
   'install-gzipped-info', or 'install-bzipped-info'.
<li>
   'clean'<br>
   Removes generated object and library files, either to recover disk space 
   or to force a complete rebuild the next time you run make. This target is 
   designed so that if you run a "make install" followed by "make clean", 
   you will still have a functional version of Allegro.
<li>
   'distclean'<br>
   Like "make clean", but more so. This removes all the executable files and 
   the documentation, leaving you with only the same files that are included
   when you unzip a new Allegro distribution.
<li>
   'veryclean'<br>
   Use with extreme caution! This target deletes absolutely all generated 
   files, including some that may be non-trivial to recreate. After you run 
   "make veryclean", a simple rebuild will not work: at the very least you 
   will have to run "make depend", and perhaps also fixdll.bat if you are 
   using the Windows library. These targets make use of non-standard tools 
   like SED, so unless you know what you are doing and have all this stuff 
   installed, you should not use them.
<li>
   'compress' (DJGPP, MinGW and MSVC only)<br>
   Uses the DJP or UPX executable compressors (whichever you have installed) 
   to compress the example executables and utility programs, which can 
   recover a significant amount of disk space.
<li>
   'depend'<br>
   Regenerates the dependency files (obj/*/makefile.dep). You need to run 
   this after "make veryclean", or whenever you add new headers to the 
   Allegro sources.
</ul>



<p><br>
<h1><a name="Available Allegro examples">Available Allegro examples</a></h1>

<p>
With Allegro comes quite a bunch of examples, which go from the simple
introductory `Hello world' to more complicated programs featuring truecolor
blending effects. This chapter describes these examples which you can find
in the allegro/examples folder. You don't have to go through them in the same
order as this documentation, but doing so you will learn the basic functions
and avoid missing any important bit of information.

<p><br>
<div class="al-api"><b>Example <a name="exhello">exhello</a></b></div><br>
   This is a very simple program showing how to get into graphics
   mode and draw text onto the screen.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exmem">exmem</a></b></div><br>
   This program demonstrates the use of memory bitmaps. It creates
   a small temporary bitmap in memory, draws some circles onto it,
   and then blits lots of copies of it onto the screen.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>.</blockquote>
<div class="al-api"><b>Example <a name="expal">expal</a></b></div><br>
   This program demonstrates how to manipulate the palette. It draws
   a set of concentric circles onto the screen and animates them by
   cycling the palette.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#black_palette" title="A palette containing solid black colors.">black_palette</a>,
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>.</blockquote>
<div class="al-api"><b>Example <a name="expat">expat</a></b></div><br>
   This program demonstrates the use of patterned drawing and sub-bitmaps.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#masked_blit" title="Copies a rectangle skipping pixels with the mask color.">masked_blit</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#solid_mode" title="Shortcut for selecting solid drawing mode.">solid_mode</a>,
<a class="xref" href="#text_height" title="Returns the height of a font in pixels.">text_height</a>,
<a class="xref" href="#text_length" title="Returns the length of a string in pixels.">text_length</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exflame">exflame</a></b></div><br>
   This program demonstrates how to write directly to video memory.
   It implements a simple fire effect, first by calling getpixel() and
   putpixel(), then by accessing video memory directly a byte at a
   time, and finally using block memory copy operations.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#bmp_read_line" title="Direct access bank switching line selection for reading.">bmp_read_line</a>,
<a class="xref" href="#bmp_unwrite_line" title="Direct access bank switching line release.">bmp_unwrite_line</a>,
<a class="xref" href="#bmp_write_line" title="Direct access bank switching line selection for writing.">bmp_write_line</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#getpixel" title="Reads a pixel from a bitmap.">getpixel</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#putpixel" title="Writes a pixel into a bitmap.">putpixel</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exdbuf">exdbuf</a></b></div><br>
   This program demonstrates the use of double buffering.
   It moves a circle across the screen, first just erasing and
   redrawing directly to the screen, then with a double buffer.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#retrace_count" title="Retrace count simulator.">retrace_count</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exflip">exflip</a></b></div><br>
   This program moves a circle across the screen, first with a
   double buffer and then using page flips.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#retrace_count" title="Retrace count simulator.">retrace_count</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#show_video_bitmap" title="Flips the hardware screen to use the specified page.">show_video_bitmap</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exfixed">exfixed</a></b></div><br>
   This program demonstrates how to use fixed point numbers, which
   are signed 32-bit integers storing the integer part in the
   upper 16 bits and the decimal part in the 16 lower bits. This
   example also uses the unusual approach of communicating with
   the user exclusively via the allegro_message() function.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#fixdiv" title="Fixed point division.">fixdiv</a>,
<a class="xref" href="#fixed" title="Fixed point integer to replace floats.">fixed</a>,
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>,
<a class="xref" href="#fixsqrt" title="Fixed point square root.">fixsqrt</a>,
<a class="xref" href="#fixtof" title="Converts a fixed point to floating point.">fixtof</a>,
<a class="xref" href="#ftofix" title="Converts a floating point value to fixed point.">ftofix</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>.</blockquote>
<div class="al-api"><b>Example <a name="exfont">exfont</a></b></div><br>
   This is a very simple program showing how to load and manipulate fonts.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#FONT" title="Stores an Allegro font.">FONT</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_font" title="Frees the memory being used by a font structure.">destroy_font</a>,
<a class="xref" href="#extract_font_range" title="Extracts a range of characters from a font.">extract_font_range</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#load_font" title="Loads a font from a file.">load_font</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#merge_fonts" title="Merges two fonts into one font.">merge_fonts</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exmouse">exmouse</a></b></div><br>
   This program demonstrates how to get mouse input. The
   first part of the test retrieves the raw mouse input data
   and displays it on the screen without using any mouse
   cursor. When you press a key the standard arrow-like mouse
   cursor appears.  You are not restricted to this shape,
   and a second key press modifies the cursor to be several
   concentric colored circles. They are not joined together,
   so you can still see bits of what's behind when you move the
   cursor over the printed text message.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>,
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_mouse_mickeys" title="How far the mouse has moved since the last call to this function.">get_mouse_mickeys</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#mouse_b" title="Global variable with the mouse position/button state.">mouse_b</a>,
<a class="xref" href="#mouse_w" title="Global variable with the mouse position/button state.">mouse_w</a>,
<a class="xref" href="#mouse_x" title="Global variable with the mouse position/button state.">mouse_x</a>,
<a class="xref" href="#mouse_y" title="Global variable with the mouse position/button state.">mouse_y</a>,
<a class="xref" href="#mouse_z" title="Global variable with the mouse position/button state.">mouse_z</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#poll_mouse" title="Polls the mouse.">poll_mouse</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_mouse_sprite" title="Sets the mouse sprite.">set_mouse_sprite</a>,
<a class="xref" href="#set_mouse_sprite_focus" title="Sets the mouse sprite focus.">set_mouse_sprite_focus</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#textprintf_right_ex" title="Formatted right aligned output of a string.">textprintf_right_ex</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="extimer">extimer</a></b></div><br>
   This program demonstrates how to use the timer routines.
   These can be a bit of a pain, because you have to be sure
   you lock all the memory that is used inside your interrupt
   handlers.  The first part of the example shows a basic use of
   timing using the blocking function rest(). The second part
   shows how to use three timers with different frequencies in
   a non blocking way.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_FUNCTION" title="Locks the code used by a timer.">END_OF_FUNCTION</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#LOCK_FUNCTION" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>,
<a class="xref" href="#LOCK_VARIABLE" title="Locks the memory of a variable used by a timer.">LOCK_VARIABLE</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#rest" title="Waits a specified number of milliseconds or yields CPU.">rest</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exkeys">exkeys</a></b></div><br>
   This program demonstrates how to access the keyboard. The
   first part shows the basic use of readkey(). The second part
   shows how to extract the ASCII value. Next come the scan codes.
   The fourth test detects modifier keys like alt or shift. The
   fifth test requires some focus to be passed. The final step
   shows how to use the global key array to read simultaneous
   key presses.
   The last method to detect key presses are keyboard callbacks.
   This is demonstrated by by installing a keyboard callback,
   which marks all pressed keys by drawing to a grid.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_FUNCTION" title="Locks the code used by a timer.">END_OF_FUNCTION</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#LOCK_FUNCTION" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#key_shifts" title="Bitmask containing the current state of modifier keys.">key_shifts</a>,
<a class="xref" href="#keyboard_lowlevel_callback" title="User specified low level keyboard event handler.">keyboard_lowlevel_callback</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#rest" title="Waits a specified number of milliseconds or yields CPU.">rest</a>,
<a class="xref" href="#scancode_to_name" title="Converts a scancode to a key name.">scancode_to_name</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#ureadkey" title="Returns the next unicode character from the keyboard buffer.">ureadkey</a>,
<a class="xref" href="#usprintf" title="Writes formatted data into a buffer.">usprintf</a>,
<a class="xref" href="#ustrzncpy" title="Copies a string into another one, specifying size.">ustrzncpy</a>.</blockquote>
<div class="al-api"><b>Example <a name="exjoy">exjoy</a></b></div><br>
   This program uses the Allegro library to detect and read the value
   of a joystick. The output of the program is a small target sight
   on the screen which you can move. At the same time the program will
   tell you what you are doing with the joystick (moving or firing).


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#calibrate_joystick" title="Calibrates the specified joystick.">calibrate_joystick</a>,
<a class="xref" href="#calibrate_joystick_name" title="Returns the next calibration text string.">calibrate_joystick_name</a>,
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#default_palette" title="The default IBM BIOS palette.">default_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_joystick" title="Initialises the joystick.">install_joystick</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#joy" title="Global array of joystick state information.">joy</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#num_joysticks" title="Global variable saying how many joysticks there are.">num_joysticks</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#poll_joystick" title="Polls the joystick.">poll_joystick</a>,
<a class="xref" href="#putpixel" title="Writes a pixel into a bitmap.">putpixel</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exsample">exsample</a></b></div><br>
   This program demonstrates how to play samples. You have to
   use this example from the command line to specify as first
   parameter a WAV or VOC sound file to play. If the file is
   loaded successfully, the sound will be played in an infinite
   loop. While it is being played, you can use the left and right
   arrow keys to modify the panning of the sound. You can also
   use the up and down arrow keys to modify the pitch.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SAMPLE" title="Stores sound data.">SAMPLE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#adjust_sample" title="Alters the parameters of a sample while it is playing.">adjust_sample</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_sample" title="Destroys a sample structure when you are done with it.">destroy_sample</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#load_sample" title="Loads a sample from a file.">load_sample</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#play_sample" title="Plays a sample.">play_sample</a>,
<a class="xref" href="#poll_keyboard" title="Polls the keyboard.">poll_keyboard</a>,
<a class="xref" href="#rest" title="Waits a specified number of milliseconds or yields CPU.">rest</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exmidi">exmidi</a></b></div><br>
   This program demonstrates how to play MIDI files.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#MIDI" title="Stores MIDI data.">MIDI</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_midi" title="Destroys a MIDI structure when you are done with it.">destroy_midi</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_filename" title="Returns a pointer to the filename portion of a path.">get_filename</a>,
<a class="xref" href="#get_midi_length" title="Determines the total playing time of a midi, in seconds.">get_midi_length</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#load_midi" title="Loads a MIDI file.">load_midi</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#midi_pause" title="Pauses the MIDI player.">midi_pause</a>,
<a class="xref" href="#midi_pos" title="Stores the current position in the MIDI file.">midi_pos</a>,
<a class="xref" href="#midi_resume" title="Resumes playback of a paused MIDI file.">midi_resume</a>,
<a class="xref" href="#midi_time" title="The current position in the MIDI file, in seconds.">midi_time</a>,
<a class="xref" href="#play_midi" title="Starts playing the specified MIDI file.">play_midi</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#rest" title="Waits a specified number of milliseconds or yields CPU.">rest</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_display_switch_mode" title="Tells Allegro how the program handles background switching.">set_display_switch_mode</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#text_height" title="Returns the height of a font in pixels.">text_height</a>,
<a class="xref" href="#text_length" title="Returns the length of a string in pixels.">text_length</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exgui">exgui</a></b></div><br>
   This program demonstrates how to use the GUI routines. From
   the simple dialog controls that display a text or a bitmap to
   more complex multiple choice selection lists, Allegro provides
   a framework which can be customised to suit your needs.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a>,
<a class="xref" href="#DIALOG" title="Stores a GUI description.">DIALOG</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#MENU" title="Stores the entries of a menu.">MENU</a>,
<a class="xref" href="#active_menu" title="Global pointer to the most recent activated menu.">active_menu</a>,
<a class="xref" href="#alert" title="Displays a popup alert box.">alert</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#d_bitmap_proc" title="Dialog procedure drawing a bitmap.">d_bitmap_proc</a>,
<a class="xref" href="#d_box_proc" title="Dialog procedure drawing boxes onto the screen.">d_box_proc</a>,
<a class="xref" href="#d_button_proc" title="Dialog procedure implementing a button object.">d_button_proc</a>,
<a class="xref" href="#d_check_proc" title="Dialog procedure implementing a check box object.">d_check_proc</a>,
<a class="xref" href="#d_clear_proc" title="Dialog procedure to clear the screen.">d_clear_proc</a>,
<a class="xref" href="#d_ctext_proc" title="Dialogs procedure drawing text onto the screen.">d_ctext_proc</a>,
<a class="xref" href="#d_edit_proc" title="Dialog procedure implementing an editable text object.">d_edit_proc</a>,
<a class="xref" href="#d_icon_proc" title="Dialog procedure implementing a bitmap button.">d_icon_proc</a>,
<a class="xref" href="#d_keyboard_proc" title="Invisible dialog procedure for implementing keyboard shortcuts.">d_keyboard_proc</a>,
<a class="xref" href="#d_list_proc" title="Dialog procedure implementing a list box object.">d_list_proc</a>,
<a class="xref" href="#d_menu_proc" title="Dialog procedure implementing a menu bar object.">d_menu_proc</a>,
<a class="xref" href="#d_radio_proc" title="Dialog procedure implementing a radio button object.">d_radio_proc</a>,
<a class="xref" href="#d_rtext_proc" title="Dialogs procedure drawing text onto the screen.">d_rtext_proc</a>,
<a class="xref" href="#d_shadow_box_proc" title="Dialog procedure drawing boxes onto the screen.">d_shadow_box_proc</a>,
<a class="xref" href="#d_slider_proc" title="Dialog procedure implementing a slider control object.">d_slider_proc</a>,
<a class="xref" href="#d_text_list_proc" title="Dialog procedure implementing a list box object with type ahead.">d_text_list_proc</a>,
<a class="xref" href="#d_text_proc" title="Dialogs procedure drawing text onto the screen.">d_text_proc</a>,
<a class="xref" href="#d_textbox_proc" title="Dialog procedure implementing a text box object.">d_textbox_proc</a>,
<a class="xref" href="#d_yield_proc" title="Invisible dialog procedure that yields CPU time slices.">d_yield_proc</a>,
<a class="xref" href="#do_dialog" title="Basic dialog manager function.">do_dialog</a>,
<a class="xref" href="#gui_bg_color" title="The foreground and background colors for the standard dialogs.">gui_bg_color</a>,
<a class="xref" href="#gui_fg_color" title="The foreground and background colors for the standard dialogs.">gui_fg_color</a>,
<a class="xref" href="#gui_mg_color" title="The color used for displaying greyed-out dialog objects.">gui_mg_color</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#position_dialog" title="Moves an array of dialog objects to the specified position.">position_dialog</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_dialog_color" title="Sets the colors of an array of dialog objects.">set_dialog_color</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#unload_datafile" title="Frees all the objects in a datafile.">unload_datafile</a>,
<a class="xref" href="#ustrtok" title="Retrieves tokens from a string.">ustrtok</a>,
<a class="xref" href="#ustrzcat" title="Concatenates a string to another one, specifying size.">ustrzcat</a>,
<a class="xref" href="#ustrzcpy" title="Copies a string into another one, specifying size.">ustrzcpy</a>,
<a class="xref" href="#uszprintf" title="Writes formatted data into a buffer, specifying size.">uszprintf</a>.</blockquote>
<div class="al-api"><b>Example <a name="excustom">excustom</a></b></div><br>
   A follow up of the exgui.c example showing how to customise the
   default Allegro framework. In this case a dialog procedure
   animates a graphical clock without disrupting other GUI
   dialogs.  A more simple option shows how to dynamically change
   the font used by all GUI elements.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a>,
<a class="xref" href="#DIALOG" title="Stores a GUI description.">DIALOG</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#FONT" title="Stores an Allegro font.">FONT</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#d_button_proc" title="Dialog procedure implementing a button object.">d_button_proc</a>,
<a class="xref" href="#d_check_proc" title="Dialog procedure implementing a check box object.">d_check_proc</a>,
<a class="xref" href="#d_clear_proc" title="Dialog procedure to clear the screen.">d_clear_proc</a>,
<a class="xref" href="#d_edit_proc" title="Dialog procedure implementing an editable text object.">d_edit_proc</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#do_dialog" title="Basic dialog manager function.">do_dialog</a>,
<a class="xref" href="#fixcos" title="Fixed point cosine of binary angles.">fixcos</a>,
<a class="xref" href="#fixed" title="Fixed point integer to replace floats.">fixed</a>,
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>,
<a class="xref" href="#fixsin" title="Fixed point sine of binary angles.">fixsin</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#object_message" title="Sends a message to an object and returns the answer.">object_message</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#unload_datafile" title="Frees all the objects in a datafile.">unload_datafile</a>.</blockquote>
<div class="al-api"><b>Example <a name="exunicod">exunicod</a></b></div><br>
   This program demonstrates the use of the 16-bit Unicode text
   encoding format with Allegro. The example displays a message
   translated to different languages scrolling on the screen
   using an external font containing the required characters to
   display those messages.
   
<p>
   Note how the Allegro unicode string functions resemble the
   functions you can find in the standard C library, only these
   handle Unicode on all platforms.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#FONT" title="Stores an Allegro font.">FONT</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#rest" title="Waits a specified number of milliseconds or yields CPU.">rest</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_uformat" title="Set the global current text encoding format.">set_uformat</a>,
<a class="xref" href="#set_window_title" title="Sets the window title of the Allegro program.">set_window_title</a>,
<a class="xref" href="#text_height" title="Returns the height of a font in pixels.">text_height</a>,
<a class="xref" href="#text_length" title="Returns the length of a string in pixels.">text_length</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#uconvert_ascii" title="Converts string from ASCII into the current format.">uconvert_ascii</a>,
<a class="xref" href="#unload_datafile" title="Frees all the objects in a datafile.">unload_datafile</a>,
<a class="xref" href="#ustrcat" title="Concatenates a string to another one.">ustrcat</a>,
<a class="xref" href="#ustrcpy" title="Copies a string into another one.">ustrcpy</a>,
<a class="xref" href="#ustrsize" title="Size of the string in bytes without null terminator.">ustrsize</a>,
<a class="xref" href="#ustrsizez" title="Size of the string in bytes including null terminator.">ustrsizez</a>.</blockquote>
<div class="al-api"><b>Example <a name="exbitmap">exbitmap</a></b></div><br>
   This program demonstrates how to load and display a bitmap
   file.  You have to use this example from the command line to
   specify as first parameter a graphic file in one of Allegro's
   supported formats.  If the file is loaded successfully,
   it will be displayed until you press a key.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>.</blockquote>
<div class="al-api"><b>Example <a name="exscale">exscale</a></b></div><br>
   This example demonstrates how to use PCX files, palettes and stretch
   blits. It loads a PCX file, sets its palette and does some random
   stretch_blits. Don't worry - it's VERY slowed down using vsync().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#load_pcx" title="Loads a PCX bitmap from a file.">load_pcx</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#stretch_blit" title="Scales a rectangular area from one bitmap to another.">stretch_blit</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="exconfig">exconfig</a></b></div><br>
   This is a very simple program showing how to use the Allegro
   configuration (ini file) routines. A first look at the example
   shows nothing more than a static graphic and the wait for
   a key press. However, the way this graphic is displayed is
   configured through a custom exconfig.ini file which is loaded
   manually. From this file the example obtains parameters like
   fullscreen/windowed mode, a specific graphic resolution to set
   up, which graphic to show, how to blit it on the screen, etc.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_config_argv" title="Reads a token list from the configuration file.">get_config_argv</a>,
<a class="xref" href="#get_config_int" title="Retrieves an integer from the configuration file.">get_config_int</a>,
<a class="xref" href="#get_config_string" title="Retrieves a string from the configuration file.">get_config_string</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#pop_config_state" title="Pops a previously pushed configuration state.">pop_config_state</a>,
<a class="xref" href="#push_config_state" title="Pushes the current configuration state.">push_config_state</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_config_file" title="Sets the configuration file.">set_config_file</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#stretch_blit" title="Scales a rectangular area from one bitmap to another.">stretch_blit</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>,
<a class="xref" href="#ustrdup" title="Duplicates a string.">ustrdup</a>,
<a class="xref" href="#ustricmp" title="Compares two strings ignoring case.">ustricmp</a>.</blockquote>
<div class="al-api"><b>Example <a name="exdata">exdata</a></b></div><br>
   This program demonstrates how to access the contents of an
   Allegro datafile (created by the grabber utility). The example
   loads the file <tt>`example.dat'</tt>, then blits a bitmap and shows
   a font, both from this datafile.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#unload_datafile" title="Frees all the objects in a datafile.">unload_datafile</a>.</blockquote>
<div class="al-api"><b>Example <a name="exsprite">exsprite</a></b></div><br>
   This example demonstrates how to use datafiles, various sprite
   drawing routines and flicker-free animation.
   
<p>
   Why is the animate() routine coded in that way?  As you
   probably know, VIDEO RAM is much slower than "normal"
   RAM, so it's advisable to reduce VRAM blits to a minimum.
   Drawing sprite on the screen (meaning in VRAM) and then
   clearing a background for it is not very fast. This example
   uses a different method which is much faster, but require a
   bit more memory.
   
<p>
   First the buffer is cleared (it's a normal BITMAP), then the
   sprite is drawn on it, and when the drawing is finished this
   buffer is copied directly to the screen. So the end result is
   that there is a single VRAM blit instead of blitting/clearing
   the background and drawing a sprite on it.  It's a good method
   even when you have to restore the background. And of course,
   it completely removes any flickering effect.
   
<p>
   When one uses a big (ie. 800x600 background) and draws
   something on it, it's wise to use a copy of background
   somewhere in memory and restore background using this
   "virtual background". When blitting from VRAM in SVGA modes,
   it's probably, that drawing routines have to switch banks on
   video card. I think, I don't have to remind how slow is it.
   
<p>
   Note that on modern systems, the above isn't true anymore, and
   you usually get the best performance by caching all your
   animations in video ram and doing only VRAM->VRAM blits, so
   there is no more RAM->VRAM transfer at all anymore. And usually,
   such transfers can run in parallel on the graphics card's
   processor as well, costing virtually no main cpu time at all.
   See the exaccel example for an example of this.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a>,
<a class="xref" href="#END_OF_FUNCTION" title="Locks the code used by a timer.">END_OF_FUNCTION</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#LOCK_FUNCTION" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>,
<a class="xref" href="#LOCK_VARIABLE" title="Locks the memory of a variable used by a timer.">LOCK_VARIABLE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#draw_sprite" title="Draws a copy of the sprite onto the destination bitmap.">draw_sprite</a>,
<a class="xref" href="#draw_sprite_h_flip" title="Draws the sprite transformed to the destination bitmap.">draw_sprite_h_flip</a>,
<a class="xref" href="#draw_sprite_v_flip" title="Draws the sprite transformed to the destination bitmap.">draw_sprite_v_flip</a>,
<a class="xref" href="#draw_sprite_vh_flip" title="Draws the sprite transformed to the destination bitmap.">draw_sprite_vh_flip</a>,
<a class="xref" href="#fixed" title="Fixed point integer to replace floats.">fixed</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#hline" title="Draws a horizontal line onto the bitmap.">hline</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#pivot_sprite" title="Rotates a sprite around a specified point.">pivot_sprite</a>,
<a class="xref" href="#pivot_sprite_v_flip" title="Rotates and flips a sprite around a specified point.">pivot_sprite_v_flip</a>,
<a class="xref" href="#play_sample" title="Plays a sample.">play_sample</a>,
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#rest" title="Waits a specified number of milliseconds or yields CPU.">rest</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#text_height" title="Returns the height of a font in pixels.">text_height</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>,
<a class="xref" href="#unload_datafile" title="Frees all the objects in a datafile.">unload_datafile</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="exexedat">exexedat</a></b></div><br>
   This program demonstrates how to access the contents of an Allegro
   datafile (created by the grabber utility) linked to the executable by the
   exedat tool. It is basically the exdata example with minor
   modifications.
   
<p>
   You may ask: how do you compile, append and exec your program?
   
<p>
   Answer: like this...
   
<p>
   1) Compile your program like normal. Use the magic filenames with '#'
   to load your data where needed.
   
<p>
   2) Once you compressed your program, run "exedat foo.exe data.dat"
   
<p>
   3) Finally run your program.
   
<p>
   Note that appending data to the end of binaries may not be portable
   across all platforms supported by Allegro.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#DATAFILE" title="Stores an Allegro datafile in memory.">DATAFILE</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#load_datafile" title="Loads a datafile into memory.">load_datafile</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#unload_datafile" title="Frees all the objects in a datafile.">unload_datafile</a>.</blockquote>
<div class="al-api"><b>Example <a name="extrans">extrans</a></b></div><br>
   This program demonstrates how to use the lighting and
   translucency functions. The first part of the example will
   show a dark screen illuminated by a spotlight you can move
   with your mouse. After a key press the example shows the full
   bitmap and the spotlight changes to be a reduced version of
   the background with 50% of translucency.
   
<p>
   The translucency effect is easy to do in all color depths.
   However, the lighting effect has to be performed in a different
   way depending on whether the screen is in 8bit mode or another
   color depth. This is because additive drawing mode uses a
   different set of routines for truecolor modes.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#RGB_MAP" title="Stores an rgb map to accelerate conversions.">RGB_MAP</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#create_light_table" title="Fills a color mapping table for lighting effects.">create_light_table</a>,
<a class="xref" href="#create_rgb_table" title="Generates an RGB mapping table with lookup data for a palette.">create_rgb_table</a>,
<a class="xref" href="#create_trans_table" title="Fills a color mapping table for translucency effects.">create_trans_table</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#mouse_x" title="Global variable with the mouse position/button state.">mouse_x</a>,
<a class="xref" href="#mouse_y" title="Global variable with the mouse position/button state.">mouse_y</a>,
<a class="xref" href="#poll_mouse" title="Polls the mouse.">poll_mouse</a>,
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#rest" title="Waits a specified number of milliseconds or yields CPU.">rest</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_alpha_blender" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#set_write_alpha_blender" title="Enables the special alpha-channel editing mode.">set_write_alpha_blender</a>,
<a class="xref" href="#stretch_blit" title="Scales a rectangular area from one bitmap to another.">stretch_blit</a>.</blockquote>
<div class="al-api"><b>Example <a name="extruec">extruec</a></b></div><br>
   This program shows how to specify colors in the various different
   truecolor pixel formats. The example shows the same screen (a few
   text lines and three coloured gradients) in all the color depth
   modes supported by your video card. The more color depth you have,
   the less banding you will see in the gradients.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#generate_332_palette" title="Constructs a fake truecolor palette.">generate_332_palette</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#vline" title="Draws a vertical line onto the bitmap.">vline</a>.</blockquote>
<div class="al-api"><b>Example <a name="excolmap">excolmap</a></b></div><br>
   This program demonstrates how to create custom graphic effects
   with the create_color_table function. Allegro drawing routines
   are affected by any color table you might have set up. In
   the first part of this example, a greyscale color table is
   set. The result is that a simple rectfill call, instead of
   drawing a rectangle with color zero, uses the already drawn
   pixels to determine the pixel to be drawn (read the comment
   of return_grey_color() for a precise description of the
   algorithm). In the second part of the test, the color table
   is changed to be an inverse table, meaning that any pixel
   drawn will be shown as its color values had been inverted.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#RGB_MAP" title="Stores an rgb map to accelerate conversions.">RGB_MAP</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_color_table" title="Fills a color mapping table for customised effects.">create_color_table</a>,
<a class="xref" href="#create_rgb_table" title="Generates an RGB mapping table with lookup data for a palette.">create_rgb_table</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#generate_332_palette" title="Constructs a fake truecolor palette.">generate_332_palette</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="exrgbhsv">exrgbhsv</a></b></div><br>
   This program shows how to convert colors between the different
   color-space representations. The central area of the screen
   will display the current color. On the top left corner of the
   screen, three sliders allow you to modify the red, green and
   blue value of the color. On the bottom right corner of the
   screen, three sliders allow you to modify the hue, saturation
   and value of the color. The color bars beneath the sliders
   show what the resulting color will look like when the slider
   is dragged to that position.
   
<p>
   Additionally this example also shows how to "inherit" the
   behaviour of a GUI object and extend it, here used to create
   the sliders.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#DIALOG" title="Stores a GUI description.">DIALOG</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#RGB_MAP" title="Stores an rgb map to accelerate conversions.">RGB_MAP</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#create_rgb_table" title="Generates an RGB mapping table with lookup data for a palette.">create_rgb_table</a>,
<a class="xref" href="#d_bitmap_proc" title="Dialog procedure drawing a bitmap.">d_bitmap_proc</a>,
<a class="xref" href="#d_box_proc" title="Dialog procedure drawing boxes onto the screen.">d_box_proc</a>,
<a class="xref" href="#d_slider_proc" title="Dialog procedure implementing a slider control object.">d_slider_proc</a>,
<a class="xref" href="#d_text_proc" title="Dialogs procedure drawing text onto the screen.">d_text_proc</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#do_dialog" title="Basic dialog manager function.">do_dialog</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#generate_332_palette" title="Constructs a fake truecolor palette.">generate_332_palette</a>,
<a class="xref" href="#get_color_depth" title="Returns the current pixel color depth.">get_color_depth</a>,
<a class="xref" href="#hsv_to_rgb" title="Converts color values between the HSV and RGB color spaces.">hsv_to_rgb</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#makecol32" title="Converts an RGB value into a display dependent pixel format.">makecol32</a>,
<a class="xref" href="#makecol8" title="Converts an RGB value into a display dependent pixel format.">makecol8</a>,
<a class="xref" href="#object_message" title="Sends a message to an object and returns the answer.">object_message</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>,
<a class="xref" href="#rgb_to_hsv" title="Converts color values between the HSV and RGB color spaces.">rgb_to_hsv</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color" title="Sets the specified palette entry to the specified RGB triplet.">set_color</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#vline" title="Draws a vertical line onto the bitmap.">vline</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="exshade">exshade</a></b></div><br>
   This program demonstrates how to draw Gouraud shaded (lit)
   sprites.  In an apparently black screen, a planet like sprite
   is drawn close to the middle of the screen. In a similar
   way to how the first test of extrans works, you move the
   cursor on the screen with the mouse. Attached to this mouse
   you can imagine a virtual spotlight illuminating the scene
   around. Depending on where the mouse is, the Gouraud shaded
   sprite will show the direction of the light.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#RGB_MAP" title="Stores an rgb map to accelerate conversions.">RGB_MAP</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_light_table" title="Fills a color mapping table for lighting effects.">create_light_table</a>,
<a class="xref" href="#create_rgb_table" title="Generates an RGB mapping table with lookup data for a palette.">create_rgb_table</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#draw_gouraud_sprite" title="Draws a sprite with gouraud shading.">draw_gouraud_sprite</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#mouse_x" title="Global variable with the mouse position/button state.">mouse_x</a>,
<a class="xref" href="#mouse_y" title="Global variable with the mouse position/button state.">mouse_y</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#poll_mouse" title="Polls the mouse.">poll_mouse</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exblend">exblend</a></b></div><br>
   This program demonstrates how to use the translucency functions
   in truecolor video modes. Two image files are loaded from
   disk and displayed moving slowly around the screen. One of
   the images will be tinted to different colors. The other
   image will be faded out with a varying alpha strength, and
   drawn on top of the other image.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#draw_lit_sprite" title="Draws a sprite tinted with a specific color.">draw_lit_sprite</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#fixcos" title="Fixed point cosine of binary angles.">fixcos</a>,
<a class="xref" href="#fixsin" title="Fixed point sine of binary angles.">fixsin</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#retrace_count" title="Retrace count simulator.">retrace_count</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="exxfade">exxfade</a></b></div><br>
   This program demonstrates how to load and display bitmap files
   in truecolor video modes, and how to crossfade between them.
   You have to use this example from the command line to specify
   as parameters a number of graphic files. Use at least two
   files to see the graphical effect. The example will crossfade
   from one image to another with each key press until you press
   the ESC key.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="exalpha">exalpha</a></b></div><br>
   This program demonstrates how to use the 32 bit RGBA
   translucency functions to store an alpha channel along with
   a bitmap graphic.  Two images are loaded from disk. One will
   be used for the background and the other as a sprite. The
   example generates an alpha channel for the sprite image,
   composing the 32 bit RGBA bitmap during runtime, and draws
   it at the position of the mouse cursor.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#drawing_mode" title="Sets the graphics drawing mode.">drawing_mode</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#getb" title="Extract a color component from the current pixel format.">getb</a>,
<a class="xref" href="#getg" title="Extract a color component from the current pixel format.">getg</a>,
<a class="xref" href="#getpixel" title="Reads a pixel from a bitmap.">getpixel</a>,
<a class="xref" href="#getr" title="Extract a color component from the current pixel format.">getr</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#mouse_x" title="Global variable with the mouse position/button state.">mouse_x</a>,
<a class="xref" href="#mouse_y" title="Global variable with the mouse position/button state.">mouse_y</a>,
<a class="xref" href="#putpixel" title="Writes a pixel into a bitmap.">putpixel</a>,
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_alpha_blender" title="Enables a special alpha-channel blending mode.">set_alpha_blender</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_multiply_blender" title="Enables a multiply blender mode.">set_multiply_blender</a>,
<a class="xref" href="#set_write_alpha_blender" title="Enables the special alpha-channel editing mode.">set_write_alpha_blender</a>,
<a class="xref" href="#solid_mode" title="Shortcut for selecting solid drawing mode.">solid_mode</a>,
<a class="xref" href="#stretch_blit" title="Scales a rectangular area from one bitmap to another.">stretch_blit</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exlights">exlights</a></b></div><br>
   This program shows one way to implement colored lighting effects
   in a hicolor video mode. Warning: it is not for the faint of heart!
   This is by no means the simplest or easiest to understand method,
   I just thought it was a cool concept that would be worth
   demonstrating.
   
<p>
   The basic approach is to select a 15 or 16 bit screen mode, but
   then draw onto 24 bit memory bitmaps. Since we only need the bottom
   5 bits of each 8 bit color in order to store 15 bit data within a
   24 bit location, we can fit a light level into the top 3 bits.
   The tricky bit is that these aren't actually 24 bit images at all:
   they are implemented as 8 bit memory bitmaps, and we just store the
   red level in one pixel, green in the next, and blue in the next,
   making the total image be three times wider than we really wanted.
   This allows us to use all the normal 256 color graphics routines
   for drawing onto our memory surfaces, most importantly the lookup
   table translucency, which can be used to combine the low 5 bits
   of color and the top 3 bits of light in a single drawing operation.
   Some trickery is needed to load 24 bit data into this fake 8 bit
   format, and of course it needs a custom routine to convert the
   resulting image while copying it across to the hardware screen.
   
<p>
   This program chugs slightly on my p133, but not significantly
   worse than any double buffering in what amounts to a 1920x640,
   256 color resolution. The light blending doesn't seem to slow
   it down too badly, so I think this technique would be quite usable
   on faster machines and in lower resolution hicolor modes. The
   biggest problem is that although you keep the full 15 bit color
   resolution, you only get 3 bits of light, ie. 8 light levels.
   You can do some nice colored light patches, but smooth gradients
   aren't going to work too well :-)


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#bmp_unwrite_line" title="Direct access bank switching line release.">bmp_unwrite_line</a>,
<a class="xref" href="#bmp_write_line" title="Direct access bank switching line selection for writing.">bmp_write_line</a>,
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#draw_trans_sprite" title="Draws a sprite blending it with the destination.">draw_trans_sprite</a>,
<a class="xref" href="#fixatan2" title="Fixed point version of the libc atan2() routine.">fixatan2</a>,
<a class="xref" href="#fixsqrt" title="Fixed point square root.">fixsqrt</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#getb_depth" title="Extract a color component from a color in a specified pixel format.">getb_depth</a>,
<a class="xref" href="#getg_depth" title="Extract a color component from a color in a specified pixel format.">getg_depth</a>,
<a class="xref" href="#getpixel" title="Reads a pixel from a bitmap.">getpixel</a>,
<a class="xref" href="#getr_depth" title="Extract a color component from a color in a specified pixel format.">getr_depth</a>,
<a class="xref" href="#hsv_to_rgb" title="Converts color values between the HSV and RGB color spaces.">hsv_to_rgb</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#mouse_x" title="Global variable with the mouse position/button state.">mouse_x</a>,
<a class="xref" href="#mouse_y" title="Global variable with the mouse position/button state.">mouse_y</a>,
<a class="xref" href="#poll_mouse" title="Polls the mouse.">poll_mouse</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#retrace_count" title="Retrace count simulator.">retrace_count</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#select_palette" title="Sets the internal palette for color conversion.">select_palette</a>,
<a class="xref" href="#set_color_conversion" title="Tells Allegro how to convert images during loading time.">set_color_conversion</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>.</blockquote>
<div class="al-api"><b>Example <a name="ex3d">ex3d</a></b></div><br>
   This program demonstrates how to use the 3d matrix functions.
   It isn't a very elegant or efficient piece of code, but it
   does show the stuff in action. It is left to the reader as
   an exercise to design a proper model structure and rendering
   pipeline: after all, the best way to do that sort of stuff
   varies hugely from one game to another.
   
<p>
   The example first shows a screen resolution selection dialog.
   Then, a number of bouncing 3d cubes are animated. Pressing
   a key modifies the rendering of the cubes, which can be
   wireframe, the more complex transparent perspective correct
   texture mapped version, and many other.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#COLOR_MAP" title="Stores a color map to accelerate drawing.">COLOR_MAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#POLYTYPE_ATEX" title="Polygon rendering mode type">POLYTYPE_ATEX</a>,
<a class="xref" href="#POLYTYPE_ATEX_LIT" title="Polygon rendering mode type">POLYTYPE_ATEX_LIT</a>,
<a class="xref" href="#POLYTYPE_ATEX_MASK" title="Polygon rendering mode type">POLYTYPE_ATEX_MASK</a>,
<a class="xref" href="#POLYTYPE_ATEX_MASK_LIT" title="Polygon rendering mode type">POLYTYPE_ATEX_MASK_LIT</a>,
<a class="xref" href="#POLYTYPE_ATEX_MASK_TRANS" title="Polygon rendering mode type">POLYTYPE_ATEX_MASK_TRANS</a>,
<a class="xref" href="#POLYTYPE_ATEX_TRANS" title="Polygon rendering mode type">POLYTYPE_ATEX_TRANS</a>,
<a class="xref" href="#POLYTYPE_FLAT" title="Polygon rendering mode type">POLYTYPE_FLAT</a>,
<a class="xref" href="#POLYTYPE_GCOL" title="Polygon rendering mode type">POLYTYPE_GCOL</a>,
<a class="xref" href="#POLYTYPE_GRGB" title="Polygon rendering mode type">POLYTYPE_GRGB</a>,
<a class="xref" href="#POLYTYPE_PTEX" title="Polygon rendering mode type">POLYTYPE_PTEX</a>,
<a class="xref" href="#POLYTYPE_PTEX_LIT" title="Polygon rendering mode type">POLYTYPE_PTEX_LIT</a>,
<a class="xref" href="#POLYTYPE_PTEX_MASK" title="Polygon rendering mode type">POLYTYPE_PTEX_MASK</a>,
<a class="xref" href="#POLYTYPE_PTEX_MASK_LIT" title="Polygon rendering mode type">POLYTYPE_PTEX_MASK_LIT</a>,
<a class="xref" href="#POLYTYPE_PTEX_MASK_TRANS" title="Polygon rendering mode type">POLYTYPE_PTEX_MASK_TRANS</a>,
<a class="xref" href="#POLYTYPE_PTEX_TRANS" title="Polygon rendering mode type">POLYTYPE_PTEX_TRANS</a>,
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#RGB_MAP" title="Stores an rgb map to accelerate conversions.">RGB_MAP</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#V3D" title="Fixed point vertex structure used by 3d functions.">V3D</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#color_map" title="Global pointer to the color mapping table.">color_map</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_light_table" title="Fills a color mapping table for lighting effects.">create_light_table</a>,
<a class="xref" href="#create_rgb_table" title="Generates an RGB mapping table with lookup data for a palette.">create_rgb_table</a>,
<a class="xref" href="#create_trans_table" title="Fills a color mapping table for translucency effects.">create_trans_table</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#fixed" title="Fixed point integer to replace floats.">fixed</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_transformation_matrix" title="Constructs X, Y, Z rotation matrices with an angle and scaling.">get_transformation_matrix</a>,
<a class="xref" href="#gfx_mode_select_ex" title="Extended version of the graphics mode selection dialog.">gfx_mode_select_ex</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#persp_project" title="Projects a 3d point into 2d screen space.">persp_project</a>,
<a class="xref" href="#polygon_z_normal" title="Finds the Z component of the normal vector to three vertices.">polygon_z_normal</a>,
<a class="xref" href="#quad3d" title="Draws a 3d quad onto the specified bitmap.">quad3d</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#rect" title="Draws an outline rectangle.">rect</a>,
<a class="xref" href="#retrace_count" title="Retrace count simulator.">retrace_count</a>,
<a class="xref" href="#rgb_map" title="Look up table to speed up reducing RGB values to palette colors.">rgb_map</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#set_projection_viewport" title="Sets the viewport used to scale the output of persp_project().">set_projection_viewport</a>,
<a class="xref" href="#set_trans_blender" title="Enables a truecolor blender.">set_trans_blender</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="excamera">excamera</a></b></div><br>
   This program demonstrates how to use the get_camera_matrix()
   function to view a 3d world from any position and angle. The
   example draws a checkered floor through a viewport region
   on the screen. You can use the keyboard to move around the
   camera or modify the size of the viewport. The keys that can
   be used with this example are displayed between brackets at
   the top of the screen.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a>,
<a class="xref" href="#POLYTYPE_FLAT" title="Polygon rendering mode type">POLYTYPE_FLAT</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#apply_matrix_f" title="Multiplies a point by a transformation matrix.">apply_matrix_f</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#clip3d_f" title="Clips the polygon given in vtx using floating point math,">clip3d_f</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_camera_matrix_f" title="Floating point version of get_camera_matrix().">get_camera_matrix_f</a>,
<a class="xref" href="#get_vector_rotation_matrix_f" title="Constructs X, Y, Z rotation matrices with an angle.">get_vector_rotation_matrix_f</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#key_shifts" title="Bitmask containing the current state of modifier keys.">key_shifts</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#persp_project_f" title="Projects a 3d point into 2d screen space.">persp_project_f</a>,
<a class="xref" href="#poll_keyboard" title="Polls the keyboard.">poll_keyboard</a>,
<a class="xref" href="#polygon" title="Draws a filled polygon.">polygon</a>,
<a class="xref" href="#polygon3d_f" title="Draws a 3d polygon onto the specified bitmap.">polygon3d_f</a>,
<a class="xref" href="#rect" title="Draws an outline rectangle.">rect</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#set_projection_viewport" title="Sets the viewport used to scale the output of persp_project().">set_projection_viewport</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="exquat">exquat</a></b></div><br>
   Euler angles are convenient for storing and creating 3D orientations.
   However, this program demonstrates that they are not good when
   interpolating between two different orientations. The problem is
   solved by using Allegro's quaternion operations.
   
<p>
   In this program, two cubes are rotated between random orientations.
   Notice that although they have the same beginning and ending
   orientations, they do not follow the same path between orientations.
   
<p>
   One cube is being rotated by directly incrementing or decrementing
   the Euler angles from the starting point to the ending point.
   This is an intuitive notion, but it is incorrect because it does not
   cause the object to turn around a single unchanging axis of rotation.
   The axis of rotation wobbles resulting in the object spinning in
   strange ways. The object will eventually end up in the orientation
   that the user intended, but it gets there in a way that is unattractive.
   Imagine if this method was used to update the position of a camera in a
   game! Sometimes it would swing wildly and disorient the player.
   
<p>
   The other cube is animated using quaternions. This results in a much
   more pleasing animation because the cube turns around a single axis
   of rotation.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a>,
<a class="xref" href="#QUAT" title="Stores quaternion information.">QUAT</a>,
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#apply_matrix_f" title="Multiplies a point by a transformation matrix.">apply_matrix_f</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_camera_matrix_f" title="Floating point version of get_camera_matrix().">get_camera_matrix_f</a>,
<a class="xref" href="#get_rotation_matrix" title="Constructs X, Y, Z rotation matrices.">get_rotation_matrix</a>,
<a class="xref" href="#get_rotation_matrix_f" title="Constructs X, Y, Z rotation matrices.">get_rotation_matrix_f</a>,
<a class="xref" href="#get_rotation_quat" title="Constructs a quaternion to rotate points around all three axes.">get_rotation_quat</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#matrix_mul_f" title="Multiplies two matrices.">matrix_mul_f</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#persp_project_f" title="Projects a 3d point into 2d screen space.">persp_project_f</a>,
<a class="xref" href="#quat_interpolate" title="Constructs a quaternion representing a rotation between from and to.">quat_interpolate</a>,
<a class="xref" href="#quat_to_matrix" title="Constructs a rotation matrix from a quaternion.">quat_to_matrix</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#rest" title="Waits a specified number of milliseconds or yields CPU.">rest</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#set_projection_viewport" title="Sets the viewport used to scale the output of persp_project().">set_projection_viewport</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exstars">exstars</a></b></div><br>
   This program draws a 3D star field (depth-cued) and a polygon
   starship (controllable with the keyboard cursor keys), using
   the Allegro math functions.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#cross_product" title="Calculates the cross product.">cross_product</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#dot_product" title="Calculates the dot product.">dot_product</a>,
<a class="xref" href="#fixed" title="Fixed point integer to replace floats.">fixed</a>,
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>,
<a class="xref" href="#fixtof" title="Converts a fixed point to floating point.">fixtof</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_rotation_matrix" title="Constructs X, Y, Z rotation matrices.">get_rotation_matrix</a>,
<a class="xref" href="#get_transformation_matrix" title="Constructs X, Y, Z rotation matrices with an angle and scaling.">get_transformation_matrix</a>,
<a class="xref" href="#get_translation_matrix" title="Constructs a translation matrix.">get_translation_matrix</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#normalize_vector" title="Converts the vector to a unit vector.">normalize_vector</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#persp_project" title="Projects a 3d point into 2d screen space.">persp_project</a>,
<a class="xref" href="#poll_keyboard" title="Polls the keyboard.">poll_keyboard</a>,
<a class="xref" href="#putpixel" title="Writes a pixel into a bitmap.">putpixel</a>,
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#set_projection_viewport" title="Sets the viewport used to scale the output of persp_project().">set_projection_viewport</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>,
<a class="xref" href="#triangle" title="Draws a filled triangle.">triangle</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="exscn3d">exscn3d</a></b></div><br>
   This program demonstrates how to use scanline sorting algorithm
   in Allegro (create_scene, clear_scene, ... functions). It
   also provides an example of how to use the 3D clipping
   function. The example consists of a flyby through a lot of
   rotating 3d cubes.
   


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_FUNCTION" title="Locks the code used by a timer.">END_OF_FUNCTION</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#LOCK_FUNCTION" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>,
<a class="xref" href="#LOCK_VARIABLE" title="Locks the memory of a variable used by a timer.">LOCK_VARIABLE</a>,
<a class="xref" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#POLYTYPE_GCOL" title="Polygon rendering mode type">POLYTYPE_GCOL</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#apply_matrix_f" title="Multiplies a point by a transformation matrix.">apply_matrix_f</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_scene" title="Initializes a scene.">clear_scene</a>,
<a class="xref" href="#clip3d_f" title="Clips the polygon given in vtx using floating point math,">clip3d_f</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_scene" title="Allocates memory for a 3d scene.">create_scene</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#destroy_scene" title="Deallocates the memory used by a scene.">destroy_scene</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_rotation_matrix_f" title="Constructs X, Y, Z rotation matrices.">get_rotation_matrix_f</a>,
<a class="xref" href="#get_translation_matrix_f" title="Constructs a translation matrix.">get_translation_matrix_f</a>,
<a class="xref" href="#gfx_mode_select_ex" title="Extended version of the graphics mode selection dialog.">gfx_mode_select_ex</a>,
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#matrix_mul_f" title="Multiplies two matrices.">matrix_mul_f</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#persp_project_f" title="Projects a 3d point into 2d screen space.">persp_project_f</a>,
<a class="xref" href="#polygon_z_normal_f" title="Finds the Z component of the normal vector to three vertices.">polygon_z_normal_f</a>,
<a class="xref" href="#render_scene" title="Renders all the queued scene polygons.">render_scene</a>,
<a class="xref" href="#scene_polygon3d_f" title="Puts a polygon in the scene rendering list.">scene_polygon3d_f</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#set_projection_viewport" title="Sets the viewport used to scale the output of persp_project().">set_projection_viewport</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exzbuf">exzbuf</a></b></div><br>
   This program demonstrates how to use Z-buffered polygons and
   floating point 3D math routines. It also provides a simple
   way to compute fps (frames per second) using a timer. After
   selecting a screen resolution through the standard GUI dialog,
   the example shows two 3D cubes rotating and intersecting each
   other. Rather than having full polygons incorrectly overlap
   other polygons due to per-polygon sorting, each pixel is drawn
   at the correct depth.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_FUNCTION" title="Locks the code used by a timer.">END_OF_FUNCTION</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#LOCK_FUNCTION" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>,
<a class="xref" href="#LOCK_VARIABLE" title="Locks the memory of a variable used by a timer.">LOCK_VARIABLE</a>,
<a class="xref" href="#MATRIX_f" title="Floating point matrix structure.">MATRIX_f</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#POLYTYPE_GCOL" title="Polygon rendering mode type">POLYTYPE_GCOL</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#V3D_f" title="Floating point vertex structure used by 3d functions.">V3D_f</a>,
<a class="xref" href="#ZBUFFER" title="Stores 3d zbuffer information.">ZBUFFER</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#apply_matrix_f" title="Multiplies a point by a transformation matrix.">apply_matrix_f</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_zbuffer" title="Writes a depth value into the given Z-buffer.">clear_zbuffer</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_zbuffer" title="Creates a Z-buffer for a bitmap.">create_zbuffer</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#destroy_zbuffer" title="Destroys a Z-buffer.">destroy_zbuffer</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_transformation_matrix_f" title="Floating point version of get_transformation_matrix().">get_transformation_matrix_f</a>,
<a class="xref" href="#gfx_mode_select_ex" title="Extended version of the graphics mode selection dialog.">gfx_mode_select_ex</a>,
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#persp_project_f" title="Projects a 3d point into 2d screen space.">persp_project_f</a>,
<a class="xref" href="#polygon_z_normal_f" title="Finds the Z component of the normal vector to three vertices.">polygon_z_normal_f</a>,
<a class="xref" href="#quad3d_f" title="Draws a 3d quad onto the specified bitmap.">quad3d_f</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#set_palette_range" title="Sets a specific range of the palette.">set_palette_range</a>,
<a class="xref" href="#set_projection_viewport" title="Sets the viewport used to scale the output of persp_project().">set_projection_viewport</a>,
<a class="xref" href="#set_zbuffer" title="Makes the given Z-buffer the active one.">set_zbuffer</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>.</blockquote>
<div class="al-api"><b>Example <a name="exscroll">exscroll</a></b></div><br>
   This program demonstrates how to use hardware scrolling.
   The scrolling should work on anything that supports virtual
   screens larger than the physical screen.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#scroll_screen" title="Requests a hardware scroll request.">scroll_screen</a>,
<a class="xref" href="#set_color" title="Sets the specified palette entry to the specified RGB triplet.">set_color</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#vline" title="Draws a vertical line onto the bitmap.">vline</a>.</blockquote>
<div class="al-api"><b>Example <a name="ex3buf">ex3buf</a></b></div><br>
   This program demonstrates the use of triple buffering. Several
   triangles are displayed rotating and bouncing on the screen
   until you press a key. Note that on some platforms you
   can't get real hardware triple buffering.  The Allegro code
   remains the same, but most likely the graphic driver will
   emulate it. Unfortunately, in these cases you can't expect
   the animation to be completely smooth and flicker free.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#enable_triple_buffer" title="Enables triple buffering.">enable_triple_buffer</a>,
<a class="xref" href="#fixcos" title="Fixed point cosine of binary angles.">fixcos</a>,
<a class="xref" href="#fixed" title="Fixed point integer to replace floats.">fixed</a>,
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>,
<a class="xref" href="#fixsin" title="Fixed point sine of binary angles.">fixsin</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#poll_scroll" title="Checks the status of a scroll request with triple buffering.">poll_scroll</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#request_video_bitmap" title="Triple buffering page flip request.">request_video_bitmap</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#triangle" title="Draws a filled triangle.">triangle</a>,
<a class="xref" href="#ustrzcpy" title="Copies a string into another one, specifying size.">ustrzcpy</a>.</blockquote>
<div class="al-api"><b>Example <a name="ex12bit">ex12bit</a></b></div><br>
   This program sets up a 12-bit mode on any 8-bit card, by
   setting up a 256-colour palette that will fool the eye into
   grouping two 8-bit pixels into one 12-bit pixel. In order
   to do this, you make your 256-colour palette with all the
   combinations of blue and green, assuming green ranges from 0-15
   and blue from 0-14. This takes up 16x15=240 colours. This
   leaves 16 colours to use as red (red ranges from 0-15).
   Then you put your green/blue in one pixel, and your red in
   the pixel next to it. The eye gets fooled into thinking it's
   all one pixel.
   
<p>
   The example starts setting a normal 256 color mode, and
   construct a special palette for it. But then comes the trick:
   you need to write to a set of two adjacent pixels to form a
   single 12 bit dot. Two eight bit pixels is the same as one 16
   bit pixel, so after setting the video mode you need to hack
   the screen bitmap about, halving the width and changing it
   to use the 16 bit drawing code. Then, once you have packed a
   color into the correct format (using the makecol12() function
   below), any of the normal Allegro drawing functions can be
   used with this 12 bit display!
   
<p>
   Things to note:
   
<p>
   <ul><li>The horizontal width is halved, so you get resolutions
   like 320x480, 400x600, and 512x768.
   
   <li>Because each dot is spread over two actual pixels, the
   display will be darker than in a normal video mode.
   
   <li>Any bitmap data will obviously need converting to the
   correct 12 bit format: regular 15 or 16 bit images won't
   display correctly...
   
   <li>Although this works like a truecolor mode, it is
   actually using a 256 color palette, so palette fades are
   still possible!
   
   <li>This code only works in linear screen modes (don't try
   Mode-X).</ul>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#MATRIX" title="Fixed point matrix structure.">MATRIX</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#RGB" title="Single palette entry.">RGB</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#apply_matrix" title="Multiplies a point by a transformation matrix.">apply_matrix</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#circle" title="Draws a circle.">circle</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#ellipsefill" title="Draws a filled ellipse.">ellipsefill</a>,
<a class="xref" href="#fade_out" title="Gradually fades the palette to black.">fade_out</a>,
<a class="xref" href="#fixcos" title="Fixed point cosine of binary angles.">fixcos</a>,
<a class="xref" href="#fixed" title="Fixed point integer to replace floats.">fixed</a>,
<a class="xref" href="#fixsin" title="Fixed point sine of binary angles.">fixsin</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_rotation_matrix" title="Constructs X, Y, Z rotation matrices.">get_rotation_matrix</a>,
<a class="xref" href="#getpixel" title="Reads a pixel from a bitmap.">getpixel</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#masked_blit" title="Copies a rectangle skipping pixels with the mask color.">masked_blit</a>,
<a class="xref" href="#putpixel" title="Writes a pixel into a bitmap.">putpixel</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#set_color" title="Sets the specified palette entry to the specified RGB triplet.">set_color</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#text_height" title="Returns the height of a font in pixels.">text_height</a>,
<a class="xref" href="#text_length" title="Returns the length of a string in pixels.">text_length</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exaccel">exaccel</a></b></div><br>
   This program demonstrates how to use an offscreen part of
   the video memory to store source graphics for a hardware
   accelerated graphics driver. The example loads the <tt>`mysha.pcx'</tt>
   file and then blits it several times on the screen. Depending
   on whether you have enough video memory and Allegro supports
   the hardware acceleration features of your card, your success
   running this example may be none at all, sluggish performance
   due to software emulation, or flicker free smooth hardware
   accelerated animation.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#replace_filename" title="Replaces path+filename with a new filename tail.">replace_filename</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#show_video_bitmap" title="Flips the hardware screen to use the specified page.">show_video_bitmap</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exspline">exspline</a></b></div><br>
   This program demonstrates the use of spline curves to create smooth
   paths connecting a number of node points. This can be useful for
   constructing realistic motion and animations.
   
<p>
   The technique is to connect the series of guide points p1..p(n) with
   spline curves from p1-p2, p2-p3, etc. Each spline must pass though
   both of its guide points, so they must be used as the first and fourth
   of the spline control points. The fun bit is coming up with sensible
   values for the second and third spline control points, such that the
   spline segments will have equal gradients where they meet. I came
   up with the following solution:
   
<p>
   For each guide point p(n), calculate the desired tangent to the curve
   at that point. I took this to be the vector p(n-1) -> p(n+1), which
   can easily be calculated with the inverse tangent function, and gives
   decent looking results. One implication of this is that two dummy
   guide points are needed at each end of the curve, which are used in
   the tangent calculations but not connected to the set of splines.
   
<p>
   Having got these tangents, it becomes fairly easy to calculate the
   spline control points. For a spline between guide points p(a) and
   p(b), the second control point should lie along the positive tangent
   from p(a), and the third control point should lie along the negative
   tangent from p(b). How far they are placed along these tangents
   controls the shape of the curve: I found that applying a 'curviness'
   scaling factor to the distance between p(a) and p(b) works well.
   
<p>
   One thing to note about splines is that the generated points are
   not all equidistant. Instead they tend to bunch up nearer to the
   ends of the spline, which means you will need to apply some fudges
   to get an object to move at a constant speed. On the other hand,
   in situations where the curve has a noticeable change of direction
   at each guide point, the effect can be quite nice because it makes
   the object slow down for the curve.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#alert" title="Displays a popup alert box.">alert</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#calc_spline" title="Calculates a series of values along a Bezier spline.">calc_spline</a>,
<a class="xref" href="#circlefill" title="Draws a filled circle.">circlefill</a>,
<a class="xref" href="#clear_keybuf" title="Clears the keyboard buffer.">clear_keybuf</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#fixatan2" title="Fixed point version of the libc atan2() routine.">fixatan2</a>,
<a class="xref" href="#fixcos" title="Fixed point cosine of binary angles.">fixcos</a>,
<a class="xref" href="#fixed" title="Fixed point integer to replace floats.">fixed</a>,
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>,
<a class="xref" href="#fixsin" title="Fixed point sine of binary angles.">fixsin</a>,
<a class="xref" href="#fixsqrt" title="Fixed point square root.">fixsqrt</a>,
<a class="xref" href="#fixtof" title="Converts a fixed point to floating point.">fixtof</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#ftofix" title="Converts a floating point value to fixed point.">ftofix</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#itofix" title="Converts an integer to fixed point.">itofix</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#mouse_b" title="Global variable with the mouse position/button state.">mouse_b</a>,
<a class="xref" href="#mouse_x" title="Global variable with the mouse position/button state.">mouse_x</a>,
<a class="xref" href="#mouse_y" title="Global variable with the mouse position/button state.">mouse_y</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#poll_mouse" title="Polls the mouse.">poll_mouse</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#spline" title="Draws a Bezier spline using four control points.">spline</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>,
<a class="xref" href="#xor_mode" title="Shortcut for toggling xor drawing mode on and off.">xor_mode</a>.</blockquote>
<div class="al-api"><b>Example <a name="exsyscur">exsyscur</a></b></div><br>
   This program demonstrates the use of hardware accelerated mouse cursors.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#enable_hardware_cursor" title="Enables the OS hardware cursor.">enable_hardware_cursor</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#select_mouse_cursor" title="Tells Allegro to select software or hardware cursor drawing.">select_mouse_cursor</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>,
<a class="xref" href="#text_height" title="Returns the height of a font in pixels.">text_height</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exupdate">exupdate</a></b></div><br>
   This program demonstrates how to support double buffering,
   page flipping, and triple buffering as options within a single
   program, and how to make things run at a constant rate no
   matter what the speed of your computer. You have to use this
   example from the command line to specify as first parameter a
   number which represents the type of video update you want: 1
   for double buffering with memory bitmaps, 2 for page flipping,
   3 for triple buffering and 4 for double buffering with system
   bitmaps. After this, a dialog allows you to select a screen
   resolution and finally you will see a kaleidoscopic animation,
   along with a frames per second counter on the top left of
   the screen.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_FUNCTION" title="Locks the code used by a timer.">END_OF_FUNCTION</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#LOCK_FUNCTION" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>,
<a class="xref" href="#LOCK_VARIABLE" title="Locks the memory of a variable used by a timer.">LOCK_VARIABLE</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_system_bitmap" title="Creates a system memory bitmap.">create_system_bitmap</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#enable_triple_buffer" title="Enables triple buffering.">enable_triple_buffer</a>,
<a class="xref" href="#fixcos" title="Fixed point cosine of binary angles.">fixcos</a>,
<a class="xref" href="#fixed" title="Fixed point integer to replace floats.">fixed</a>,
<a class="xref" href="#fixmul" title="Multiplies two fixed point values together.">fixmul</a>,
<a class="xref" href="#fixsin" title="Fixed point sine of binary angles.">fixsin</a>,
<a class="xref" href="#fixtoi" title="Converts a fixed point to integer with rounding.">fixtoi</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#ftofix" title="Converts a floating point value to fixed point.">ftofix</a>,
<a class="xref" href="#generate_332_palette" title="Constructs a fake truecolor palette.">generate_332_palette</a>,
<a class="xref" href="#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#gfx_mode_select_ex" title="Extended version of the graphics mode selection dialog.">gfx_mode_select_ex</a>,
<a class="xref" href="#install_int_ex" title="Adds or modifies a timer.">install_int_ex</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#line" title="Draws a line onto the bitmap.">line</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#poll_scroll" title="Checks the status of a scroll request with triple buffering.">poll_scroll</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#request_video_bitmap" title="Triple buffering page flip request.">request_video_bitmap</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#show_video_bitmap" title="Flips the hardware screen to use the specified page.">show_video_bitmap</a>,
<a class="xref" href="#textout_ex" title="Writes a string on a bitmap.">textout_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>,
<a class="xref" href="#triangle" title="Draws a filled triangle.">triangle</a>,
<a class="xref" href="#vsync" title="Waits for a vertical retrace to begin.">vsync</a>,
<a class="xref" href="#xor_mode" title="Shortcut for toggling xor drawing mode on and off.">xor_mode</a>.</blockquote>
<div class="al-api"><b>Example <a name="exswitch">exswitch</a></b></div><br>
   This program shows how to control the console switching mode, and
   let your program run in the background. These functions don't apply
   to every platform and driver, for example you can't control the
   switching mode from a DOS program.
   
<p>
   Yes, I know the fractal drawing is very slow: that's the point!
   This is so you can easily check whether it goes on working in the
   background after you switch away from the app.
   
<p>
   Depending on the type of selected switching mode, you will see
   whether the contents of the screen are preserved or not.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_FUNCTION" title="Locks the code used by a timer.">END_OF_FUNCTION</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#LOCK_FUNCTION" title="Locks the memory of a function used by a timer.">LOCK_FUNCTION</a>,
<a class="xref" href="#LOCK_VARIABLE" title="Locks the memory of a variable used by a timer.">LOCK_VARIABLE</a>,
<a class="xref" href="#PALETTE" title="Stores palette information.">PALETTE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_exit" title="Closes down the Allegro system.">allegro_exit</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#get_display_switch_mode" title="Returns the current display switching mode.">get_display_switch_mode</a>,
<a class="xref" href="#gfx_mode_select_ex" title="Extended version of the graphics mode selection dialog.">gfx_mode_select_ex</a>,
<a class="xref" href="#install_int" title="Installs a user timer handler.">install_int</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_mouse" title="Installs the Allegro mouse handler.">install_mouse</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#palette_color" title="Maps palette indexes into the current pixel format colors.">palette_color</a>,
<a class="xref" href="#putpixel" title="Writes a pixel into a bitmap.">putpixel</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#rectfill" title="Draws a solid filled rectangle.">rectfill</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_display_switch_callback" title="Installs a switching notification callback.">set_display_switch_callback</a>,
<a class="xref" href="#set_display_switch_mode" title="Tells Allegro how the program handles background switching.">set_display_switch_mode</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#textout_centre_ex" title="Writes a centered string on a bitmap.">textout_centre_ex</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>.</blockquote>
<div class="al-api"><b>Example <a name="exstream">exstream</a></b></div><br>
   This program shows how to use the audio stream functions to
   transfer large blocks of sample data to the sound card. In
   this case, the sample data is generated during runtime,
   and the resulting sound reminds of a car engine when you
   are accelerating.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#AUDIOSTREAM" title="Stores an audiostream.">AUDIOSTREAM</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>,
<a class="xref" href="#desktop_palette" title="The palette used by the Atari ST low resolution desktop.">desktop_palette</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#free_audio_stream_buffer" title="Tells the audio stream player new data can be played.">free_audio_stream_buffer</a>,
<a class="xref" href="#get_audio_stream_buffer" title="Tells you if you need to fill the audiostream or not.">get_audio_stream_buffer</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#install_sound" title="Initialises the sound module.">install_sound</a>,
<a class="xref" href="#install_timer" title="Installs the Allegro timer interrupt handler.">install_timer</a>,
<a class="xref" href="#keypressed" title="Tells if there are keypresses waiting in the input buffer.">keypressed</a>,
<a class="xref" href="#makecol" title="Converts an RGB value into the current pixel format.">makecol</a>,
<a class="xref" href="#play_audio_stream" title="Creates a new audio stream and starts playing it.">play_audio_stream</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#set_palette" title="Sets the entire palette of 256 colors.">set_palette</a>,
<a class="xref" href="#stop_audio_stream" title="Destroys an audio stream when it is no longer required.">stop_audio_stream</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>,
<a class="xref" href="#voice_start" title="Activates a voice.">voice_start</a>,
<a class="xref" href="#voice_stop" title="Stops a voice.">voice_stop</a>.</blockquote>
<div class="al-api"><b>Example <a name="expackf">expackf</a></b></div><br>
   This program demonstrates the use of the packfile functions, with some
   simple tests.
   
<p>
   The first test uses the standard packfile functions to transfer a
   bitmap file into a block of memory, then reads the bitmap out of the
   block of memory, using a custom packfile vtable.
   
<p>
   The second test reads in a bitmap with another custom packfile
   vtable, which uses libc's file stream functions.
   
<p>
   The third test demonstrates seeking with a custom vtable.
   
<p>
   The fourth test reads two bitmaps, and dumps them back into a
   single file, using a custom vtable again.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#ASSERT" title="Debugging helper macro to assert.">ASSERT</a>,
<a class="xref" href="#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a>,
<a class="xref" href="#END_OF_MAIN" title="Macro to put after your main() function.">END_OF_MAIN</a>,
<a class="xref" href="#PACKFILE" title="Packfile structure, similar to the libc FILE structure.">PACKFILE</a>,
<a class="xref" href="#PACKFILE_VTABLE" title="Packfile vtable structure, for custom packfiles.">PACKFILE_VTABLE</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#alert" title="Displays a popup alert box.">alert</a>,
<a class="xref" href="#allegro_error" title="Stores the last Allegro error message.">allegro_error</a>,
<a class="xref" href="#allegro_init" title="Macro to initialise the Allegro library.">allegro_init</a>,
<a class="xref" href="#allegro_message" title="Used mainly to show error messages to users.">allegro_message</a>,
<a class="xref" href="#blit" title="Copies a rectangular area from one bitmap to another.">blit</a>,
<a class="xref" href="#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#file_size_ex" title="Returns the size of a file in bytes.">file_size_ex</a>,
<a class="xref" href="#font" title="A simple 8x8 fixed size font.">font</a>,
<a class="xref" href="#install_keyboard" title="Installs the Allegro keyboard interrupt handler.">install_keyboard</a>,
<a class="xref" href="#key" title="Array of flags indicating key state.">key</a>,
<a class="xref" href="#load_bmp_pf" title="Packfile version of load_bmp.">load_bmp_pf</a>,
<a class="xref" href="#load_pcx" title="Loads a PCX bitmap from a file.">load_pcx</a>,
<a class="xref" href="#load_pcx_pf" title="Packfile version of load_pcx.">load_pcx_pf</a>,
<a class="xref" href="#load_tga_pf" title="Packfile version of load_tga.">load_tga_pf</a>,
<a class="xref" href="#pack_fclose" title="Closes a stream previously opened.">pack_fclose</a>,
<a class="xref" href="#pack_fopen" title="Opens a file according to mode.">pack_fopen</a>,
<a class="xref" href="#pack_fopen_vtable" title="">pack_fopen_vtable</a>,
<a class="xref" href="#pack_fread" title="Reads n bytes from the stream.">pack_fread</a>,
<a class="xref" href="#pack_fseek" title="Seeks inside a stream.">pack_fseek</a>,
<a class="xref" href="#readkey" title="Returns the next character from the keyboard buffer.">readkey</a>,
<a class="xref" href="#save_bmp_pf" title="Packfile version of save_bmp.">save_bmp_pf</a>,
<a class="xref" href="#save_tga_pf" title="Packfile version of save_tga.">save_tga_pf</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#text_height" title="Returns the height of a font in pixels.">text_height</a>,
<a class="xref" href="#textprintf_centre_ex" title="Formatted centered output of a string.">textprintf_centre_ex</a>,
<a class="xref" href="#textprintf_ex" title="Formatted output of a string.">textprintf_ex</a>.</blockquote>
<h1><a name="Community">Community</a></h1>

<p>
Allegro was originally created by Shawn Hargreaves. Published sometime between
1994 and 1995, it was just a simple lib for himself. At that time, many people
were switching from Borland C to DJGPP and looking for a decent graphics
library. Allegro was the first reasonably complete one to show up, so it
attracted enough interest to keep growing, and a little contribution here, and
some more encouragement there made it all light up like fire.

<p>
Some time after the latest 3.x stable release, though, Shawn was flooded with
Allegro tasks and Real Life (TM) work, and chose the latter to focus his
energies on. While this somehow stalled Allegro's development, it also
attracted a lot of people who wanted Allegro to live longer. Also, by that
time other people had started to work on Windows and Unix ports of Allegro,
which suggested that Allegro had the potential to survive its only decaying
main platform (DOS).

<p>
The current situation is that Shawn still keeps watching Allegro's progress
from time to time, but is not involved with development any more. The
community that grew over the years when Shawn was in charge of everything has
stepped forward to continue improving Allegro. Transformed into a meritocratic
community, users keep sending bug reports to the mailing lists, developers
around the world keep sending patches to fix them, and a few carefully chosen
have write access to the SVN repository, from which releases are built every
now and then.

<p>
But, who decides when a build is stable enough? Who decides when somebody is
granted write access to the SVN? Who chooses the lesser of two evils patching
some obscure bug? And more importantly, who decides what's Allegro's mascot?
For all these reasons, the community decided to replace Shawn's position with
the Allegro Dictator.

<p>
In republican Rome, political power was with the Senate and the Consuls.
However, if it was necessary that decisions were made very quickly then the
senate could appoint a Dictator. The Dictator was appointed for a specified
duration or charged with a specific task, after which he was expected to
surrender his authority back to the Senate. Nowadays, the Allegro Dictator is
a benevolent figure and rarely has to use his overwhelming fist of iron to put
order into chaos.

<p>
The truth is that the Allegro Dictator is usually the person in charge of
doing releases and all that unsexy work inside the community, like pestering
users to test some obscure bugfix or rejecting incomplete patches.

<p>
Past Allegro dictators have been: Shawn Hargreaves, George Foot, Peter Wang
and Eric Botcazou. At the moment of writing this, Evert Glebbeek is the
active Allegro Dictator. Should you want to change Allegro in some illogical
way, he's the guy you have to send your bribes too :-)



<p><br>
<h1><a name="Conclusion">Conclusion</a></h1>

<p>
All good things must come to an end. Writing documentation is not a good 
thing, though, and that means it goes on for ever. There is always something 
we've forgotten to explain, or some essential detail we've left out, but for
now you will have to make do with this. Feel free to ask if you can't figure 
something out.

<p>
Enjoy. We hope you find some of this stuff useful.


<p><br>
By Shawn Hargreaves and the Allegro development team.

<p>
<a href="http://alleg.sourceforge.net/">http://alleg.sourceforge.net/</a>



<p><br>
<h1><a name="Index">Index</a></h1>

<p>
<div class='mini_toc' id='top'>
	<a href='#mini_toc_A0'>A</a>
	<a href='#mini_toc_B0'>B</a>
	<a href='#mini_toc_C0'>C</a>
	<a href='#mini_toc_D0'>D</a>
	<a href='#mini_toc_E0'>E</a>
	<a href='#mini_toc_F0'>F</a>
	<a href='#mini_toc_G0'>G</a>
	<a href='#mini_toc_J0'>J</a>
	<a href='#mini_toc_L0'>L</a>
	<a href='#mini_toc_M0'>M</a>
	<a href='#mini_toc_P0'>P</a>
	<a href='#mini_toc_Q0'>Q</a>
	<a href='#mini_toc_R0'>R</a>
	<a href='#mini_toc_S0'>S</a>
	<a href='#mini_toc_T0'>T</a>
	<a href='#mini_toc_V0'>V</a>
	<a href='#mini_toc_Z0'>Z</a>
	<a href='#mini_toc__0'>_</a>
	<a href='#mini_toc_a1'>a</a>
	<a href='#mini_toc_b1'>b</a>
	<a href='#mini_toc_c1'>c</a>
	<a href='#mini_toc_d1'>d</a>
	<a href='#mini_toc_e1'>e</a>
	<a href='#mini_toc_f1'>f</a>
	<a href='#mini_toc_g1'>g</a>
	<a href='#mini_toc_h1'>h</a>
	<a href='#mini_toc_i1'>i</a>
	<a href='#mini_toc_j1'>j</a>
	<a href='#mini_toc_k1'>k</a>
	<a href='#mini_toc_l1'>l</a>
	<a href='#mini_toc_m1'>m</a>
	<a href='#mini_toc_n1'>n</a>
	<a href='#mini_toc_o1'>o</a>
	<a href='#mini_toc_p1'>p</a>
	<a href='#mini_toc_q1'>q</a>
	<a href='#mini_toc_r1'>r</a>
	<a href='#mini_toc_s1'>s</a>
	<a href='#mini_toc_t1'>t</a>
	<a href='#mini_toc_u1'>u</a>
	<a href='#mini_toc_v1'>v</a>
	<a href='#mini_toc_w1'>w</a>
	<a href='#mini_toc_x1'>x</a>
	
</div>

<h1 class='mini_toc' id='mini_toc_A0'><a href='#top'>A</a></h1>
<ul>
<li><a href="#ALLEGRO_DATE">ALLEGRO_DATE</a> &mdash; Defined to a number with the release date of Allegro.
<li><a href="#ALLEGRO_DATE_STR">ALLEGRO_DATE_STR</a> &mdash; Defined to a string with the year Allegro was released.
<li><a href="#ALLEGRO_SUB_VERSION">ALLEGRO_SUB_VERSION</a> &mdash; Defined to the middle version of Allegro.
<li><a href="#ALLEGRO_VERSION">ALLEGRO_VERSION</a> &mdash; Defined to the major version of Allegro.
<li><a href="#ALLEGRO_VERSION_STR">ALLEGRO_VERSION_STR</a> &mdash; Defined to a string with the full Allegro version number.
<li><a href="#ALLEGRO_WIP_VERSION">ALLEGRO_WIP_VERSION</a> &mdash; Defined to the minor version of Allegro.
<li><a href="#AL_ID">AL_ID</a> &mdash; Converts four 8 bit values to a packed 32 bit integer ID.
<li><a href="#ASSERT">ASSERT</a> &mdash; Debugging helper macro to assert.
<li><a href="#AUDIOSTREAM">AUDIOSTREAM</a> &mdash; Stores an audiostream.

</ul>
<h1 class='mini_toc' id='mini_toc_B0'><a href='#top'>B</a></h1>
<ul>
<li><a href="#BITMAP">BITMAP</a> &mdash; Stores the contents of a bitmap.

</ul>
<h1 class='mini_toc' id='mini_toc_C0'><a href='#top'>C</a></h1>
<ul>
<li><a href="#COLOR_MAP">COLOR_MAP</a> &mdash; Stores a color map to accelerate drawing.
<li><a href="#COMPILED_SPRITE">COMPILED_SPRITE</a> &mdash; Stores the contents of a compiled sprite.

</ul>
<h1 class='mini_toc' id='mini_toc_D0'><a href='#top'>D</a></h1>
<ul>
<li><a href="#DATAFILE">DATAFILE</a> &mdash; Stores an Allegro datafile in memory.
<li><a href="#DAT_ID">DAT_ID</a> &mdash; Makes an ID value from four letters.
<li><a href="#DIALOG">DIALOG</a> &mdash; Stores a GUI description.
<li><a href="#DIALOG_PLAYER">DIALOG_PLAYER</a> &mdash; Stores GUI data internally used by Allegro.
<li><a href="#DIGI_*/BeOS">DIGI_*/BeOS</a> &mdash; Supported BeOS digital sound drivers.
<li><a href="#DIGI_*/DOS">DIGI_*/DOS</a> &mdash; Supported DOS digital sound drivers.
<li><a href="#DIGI_*/MacOSX">DIGI_*/MacOSX</a> &mdash; Supported MacOSX digital sound drivers.
<li><a href="#DIGI_*/QNX">DIGI_*/QNX</a> &mdash; Supported QNX digital sound drivers.
<li><a href="#DIGI_*/Unix">DIGI_*/Unix</a> &mdash; Supported Unix digital sound drivers.
<li><a href="#DIGI_*/Windows">DIGI_*/Windows</a> &mdash; Supported Windows digital sound drivers.

</ul>
<h1 class='mini_toc' id='mini_toc_E0'><a href='#top'>E</a></h1>
<ul>
<li><a href="#END_OF_FUNCTION">END_OF_FUNCTION</a> &mdash; Locks the code used by a timer.
<li><a href="#END_OF_MAIN">END_OF_MAIN</a> &mdash; Macro to put after your main() function.

</ul>
<h1 class='mini_toc' id='mini_toc_F0'><a href='#top'>F</a></h1>
<ul>
<li><a href="#FONT">FONT</a> &mdash; Stores an Allegro font.

</ul>
<h1 class='mini_toc' id='mini_toc_G0'><a href='#top'>G</a></h1>
<ul>
<li><a href="#GFX_*/BeOS">GFX_*/BeOS</a> &mdash; Supported BeOS graphic drivers.
<li><a href="#GFX_*/DOS">GFX_*/DOS</a> &mdash; Supported DOS graphic drivers.
<li><a href="#GFX_*/Linux">GFX_*/Linux</a> &mdash; Supported Linux console graphic drivers.
<li><a href="#GFX_*/MacOSX">GFX_*/MacOSX</a> &mdash; Supported MacOSX graphic drivers.
<li><a href="#GFX_*/QNX">GFX_*/QNX</a> &mdash; Supported QNX graphic drivers.
<li><a href="#GFX_*/Windows">GFX_*/Windows</a> &mdash; Supported Windows graphic drivers.
<li><a href="#GFX_*/X">GFX_*/X</a> &mdash; Supported X graphic drivers.
<li><a href="#GFX_MODE">GFX_MODE</a> &mdash; Stores video mode information.
<li><a href="#GFX_MODE_LIST">GFX_MODE_LIST</a> &mdash; Stores an array of GFX_MODE structures.

</ul>
<h1 class='mini_toc' id='mini_toc_J0'><a href='#top'>J</a></h1>
<ul>
<li><a href="#JOYSTICK_AXIS_INFO">JOYSTICK_AXIS_INFO</a> &mdash; Stores joystick axis information.
<li><a href="#JOYSTICK_BUTTON_INFO">JOYSTICK_BUTTON_INFO</a> &mdash; Stores joystick button information.
<li><a href="#JOYSTICK_INFO">JOYSTICK_INFO</a> &mdash; Stores information about joysticks.
<li><a href="#JOYSTICK_STICK_INFO">JOYSTICK_STICK_INFO</a> &mdash; Stores joystick stick information.
<li><a href="#JOY_TYPE_*/DOS">JOY_TYPE_*/DOS</a> &mdash; Supported DOS joystick drivers.
<li><a href="#JOY_TYPE_*/Linux">JOY_TYPE_*/Linux</a> &mdash; Supported Linux joystick drivers.
<li><a href="#JOY_TYPE_*/Windows">JOY_TYPE_*/Windows</a> &mdash; Supported Windows joystick drivers.

</ul>
<h1 class='mini_toc' id='mini_toc_L0'><a href='#top'>L</a></h1>
<ul>
<li><a href="#LOCK_FUNCTION">LOCK_FUNCTION</a> &mdash; Locks the memory of a function used by a timer.
<li><a href="#LOCK_VARIABLE">LOCK_VARIABLE</a> &mdash; Locks the memory of a variable used by a timer.
<li><a href="#LZSS_PACK_DATA">LZSS_PACK_DATA</a> &mdash; Opaque structure for handling LZSS compression.
<li><a href="#LZSS_UNPACK_DATA">LZSS_UNPACK_DATA</a> &mdash; Opaque structure for handling LZSS decompression.

</ul>
<h1 class='mini_toc' id='mini_toc_M0'><a href='#top'>M</a></h1>
<ul>
<li><a href="#MAKE_VERSION">MAKE_VERSION</a> &mdash; Create a 32 bit integer from the Allegro version
<li><a href="#MASK_COLOR_15">MASK_COLOR_15</a> &mdash; Constant representing the mask value in sprites.
<li><a href="#MASK_COLOR_16">MASK_COLOR_16</a> &mdash; Constant representing the mask value in sprites.
<li><a href="#MASK_COLOR_24">MASK_COLOR_24</a> &mdash; Constant representing the mask value in sprites.
<li><a href="#MASK_COLOR_32">MASK_COLOR_32</a> &mdash; Constant representing the mask value in sprites.
<li><a href="#MASK_COLOR_8">MASK_COLOR_8</a> &mdash; Constant representing the mask value in sprites.
<li><a href="#MATRIX">MATRIX</a> &mdash; Fixed point matrix structure.
<li><a href="#MATRIX_f">MATRIX_f</a> &mdash; Floating point matrix structure.
<li><a href="#MENU">MENU</a> &mdash; Stores the entries of a menu.
<li><a href="#MENU_PLAYER">MENU_PLAYER</a> &mdash; Stores GUI data internally used by Allegro.
<li><a href="#MIDI">MIDI</a> &mdash; Stores MIDI data.
<li><a href="#MIDI_*/BeOS">MIDI_*/BeOS</a> &mdash; Supported BeOS MIDI sound drivers.
<li><a href="#MIDI_*/DOS">MIDI_*/DOS</a> &mdash; Supported DOS MIDI sound drivers.
<li><a href="#MIDI_*/MacOSX">MIDI_*/MacOSX</a> &mdash; Supported MacOSX MIDI sound drivers.
<li><a href="#MIDI_*/QNX">MIDI_*/QNX</a> &mdash; Supported QNX MIDI sound drivers.
<li><a href="#MIDI_*/Unix">MIDI_*/Unix</a> &mdash; Supported Unix MIDI sound drivers.
<li><a href="#MIDI_*/Windows">MIDI_*/Windows</a> &mdash; Supported Windows MIDI sound drivers.

</ul>
<h1 class='mini_toc' id='mini_toc_P0'><a href='#top'>P</a></h1>
<ul>
<li><a href="#PACKFILE">PACKFILE</a> &mdash; Packfile structure, similar to the libc FILE structure.
<li><a href="#PACKFILE_VTABLE">PACKFILE_VTABLE</a> &mdash; Packfile vtable structure, for custom packfiles.
<li><a href="#PALETTE">PALETTE</a> &mdash; Stores palette information.
<li><a href="#PAL_SIZE">PAL_SIZE</a> &mdash; Number of entries in a palette.
<li><a href="#POLYTYPE_ATEX">POLYTYPE_ATEX</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_ATEX_LIT">POLYTYPE_ATEX_LIT</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_ATEX_MASK">POLYTYPE_ATEX_MASK</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_ATEX_MASK_LIT">POLYTYPE_ATEX_MASK_LIT</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_ATEX_MASK_TRANS">POLYTYPE_ATEX_MASK_TRANS</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_ATEX_TRANS">POLYTYPE_ATEX_TRANS</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_FLAT">POLYTYPE_FLAT</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_GCOL">POLYTYPE_GCOL</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_GRGB">POLYTYPE_GRGB</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX">POLYTYPE_PTEX</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX_LIT">POLYTYPE_PTEX_LIT</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX_MASK">POLYTYPE_PTEX_MASK</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX_MASK_LIT">POLYTYPE_PTEX_MASK_LIT</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX_MASK_TRANS">POLYTYPE_PTEX_MASK_TRANS</a> &mdash; Polygon rendering mode type
<li><a href="#POLYTYPE_PTEX_TRANS">POLYTYPE_PTEX_TRANS</a> &mdash; Polygon rendering mode type

</ul>
<h1 class='mini_toc' id='mini_toc_Q0'><a href='#top'>Q</a></h1>
<ul>
<li><a href="#QUAT">QUAT</a> &mdash; Stores quaternion information.

</ul>
<h1 class='mini_toc' id='mini_toc_R0'><a href='#top'>R</a></h1>
<ul>
<li><a href="#RGB">RGB</a> &mdash; Single palette entry.
<li><a href="#RGB_MAP">RGB_MAP</a> &mdash; Stores an rgb map to accelerate conversions.
<li><a href="#RLE_SPRITE">RLE_SPRITE</a> &mdash; Stores the contents of an RLE sprite.

</ul>
<h1 class='mini_toc' id='mini_toc_S0'><a href='#top'>S</a></h1>
<ul>
<li><a href="#SAMPLE">SAMPLE</a> &mdash; Stores sound data.
<li><a href="#SCREEN_H">SCREEN_H</a> &mdash; Global define to obtain the size of the screen.
<li><a href="#SCREEN_W">SCREEN_W</a> &mdash; Global define to obtain the size of the screen.

</ul>
<h1 class='mini_toc' id='mini_toc_T0'><a href='#top'>T</a></h1>
<ul>
<li><a href="#TRACE">TRACE</a> &mdash; Debugging helper macro to trace messages.

</ul>
<h1 class='mini_toc' id='mini_toc_V0'><a href='#top'>V</a></h1>
<ul>
<li><a href="#V3D">V3D</a> &mdash; Fixed point vertex structure used by 3d functions.
<li><a href="#V3D_f">V3D_f</a> &mdash; Floating point vertex structure used by 3d functions.
<li><a href="#VIRTUAL_H">VIRTUAL_H</a> &mdash; Global define to obtain the virtual size of the screen.
<li><a href="#VIRTUAL_W">VIRTUAL_W</a> &mdash; Global define to obtain the virtual size of the screen.

</ul>
<h1 class='mini_toc' id='mini_toc_Z0'><a href='#top'>Z</a></h1>
<ul>
<li><a href="#ZBUFFER">ZBUFFER</a> &mdash; Stores 3d zbuffer information.

</ul>
<h1 class='mini_toc' id='mini_toc__0'><a href='#top'>_</a></h1>
<ul>
<li><a href="#_getpixel">_getpixel</a> &mdash; Faster specific version of getpixel().
<li><a href="#_getpixel15">_getpixel15</a> &mdash; Faster specific version of getpixel().
<li><a href="#_getpixel16">_getpixel16</a> &mdash; Faster specific version of getpixel().
<li><a href="#_getpixel24">_getpixel24</a> &mdash; Faster specific version of getpixel().
<li><a href="#_getpixel32">_getpixel32</a> &mdash; Faster specific version of getpixel().
<li><a href="#_putpixel">_putpixel</a> &mdash; Faster specific version of putpixel().
<li><a href="#_putpixel15">_putpixel15</a> &mdash; Faster specific version of putpixel().
<li><a href="#_putpixel16">_putpixel16</a> &mdash; Faster specific version of putpixel().
<li><a href="#_putpixel24">_putpixel24</a> &mdash; Faster specific version of putpixel().
<li><a href="#_putpixel32">_putpixel32</a> &mdash; Faster specific version of putpixel().
<li><a href="#_set_color">_set_color</a> &mdash; Inline version of set_color().
<li><a href="#_ustrdup">_ustrdup</a> &mdash; Duplicates a string with a custom memory allocator.

</ul>
<h1 class='mini_toc' id='mini_toc_a1'><a href='#top'>a</a></h1>
<ul>
<li><a href="#acquire_bitmap">acquire_bitmap</a> &mdash; Locks the bitmap before drawing onto it.
<li><a href="#acquire_screen">acquire_screen</a> &mdash; Shortcut of acquire_bitmap(screen);
<li><a href="#active_dialog">active_dialog</a> &mdash; Global pointer to the most recent activated dialog.
<li><a href="#active_menu">active_menu</a> &mdash; Global pointer to the most recent activated menu.
<li><a href="#add_clip_rect">add_clip_rect</a> &mdash; Intersects a bitmap's clipping rectangle with the given area.
<li><a href="#adjust_sample">adjust_sample</a> &mdash; Alters the parameters of a sample while it is playing.
<li><a href="#al_assert">al_assert</a> &mdash; Asserts at the specified file and line number.
<li><a href="#al_ffblk">al_ffblk</a> &mdash; Cross platform structure storing file information.
<li><a href="#al_ffblk_get_size">al_ffblk_get_size</a> &mdash; Get size of file returned by al_findfirst/al_findnext.
<li><a href="#al_findclose">al_findclose</a> &mdash; Closes a previously opened search with al_findfirst().
<li><a href="#al_findfirst">al_findfirst</a> &mdash; Low-level function for searching files.
<li><a href="#al_findnext">al_findnext</a> &mdash; Finds the next file in a search started by al_findfirst().
<li><a href="#al_trace">al_trace</a> &mdash; Outputs a debugging trace message.
<li><a href="#alert">alert</a> &mdash; Displays a popup alert box.
<li><a href="#alert3">alert3</a> &mdash; Like alert(), but with three buttons.
<li><a href="#allegro_404_char">allegro_404_char</a> &mdash; Character used when Allegro cannot find a glyph.
<li><a href="#allegro_error">allegro_error</a> &mdash; Stores the last Allegro error message.
<li><a href="#allegro_exit">allegro_exit</a> &mdash; Closes down the Allegro system.
<li><a href="#allegro_icon">allegro_icon</a> &mdash; Pointer to the Allegro X11 icon.
<li><a href="#allegro_id">allegro_id</a> &mdash; String containing date and version number of Allegro.
<li><a href="#allegro_init">allegro_init</a> &mdash; Macro to initialise the Allegro library.
<li><a href="#allegro_message">allegro_message</a> &mdash; Used mainly to show error messages to users.
<li><a href="#allocate_voice">allocate_voice</a> &mdash; Allocates a sound card voice for a sample.
<li><a href="#append_filename">append_filename</a> &mdash; Concatenates a filename to a path.
<li><a href="#apply_matrix">apply_matrix</a> &mdash; Multiplies a point by a transformation matrix.
<li><a href="#apply_matrix_f">apply_matrix_f</a> &mdash; Multiplies a point by a transformation matrix.
<li><a href="#apply_quat">apply_quat</a> &mdash; Multiplies a point by a quaternion.
<li><a href="#arc">arc</a> &mdash; Draws a circular arc.

</ul>
<h1 class='mini_toc' id='mini_toc_b1'><a href='#top'>b</a></h1>
<ul>
<li><a href="#bestfit_color">bestfit_color</a> &mdash; Finds a palette color fitting the requested RGB values.
<li><a href="#bitmap_color_depth">bitmap_color_depth</a> &mdash; Returns the color depth of the specified bitmap.
<li><a href="#bitmap_mask_color">bitmap_mask_color</a> &mdash; Returns the mask color of the specified bitmap.
<li><a href="#black_palette">black_palette</a> &mdash; A palette containing solid black colors.
<li><a href="#blit">blit</a> &mdash; Copies a rectangular area from one bitmap to another.
<li><a href="#blit_from_hdc">blit_from_hdc</a> &mdash; Blits from a Windows device context to an Allegro memory bitmap.
<li><a href="#blit_to_hdc">blit_to_hdc</a> &mdash; Blits an Allegro memory bitmap to a Windows device context.
<li><a href="#bmp_read_line">bmp_read_line</a> &mdash; Direct access bank switching line selection for reading.
<li><a href="#bmp_unwrite_line">bmp_unwrite_line</a> &mdash; Direct access bank switching line release.
<li><a href="#bmp_write_line">bmp_write_line</a> &mdash; Direct access bank switching line selection for writing.
<li><a href="#broadcast_dialog_message">broadcast_dialog_message</a> &mdash; Broadcasts a message to all the objects in the active dialog.

</ul>
<h1 class='mini_toc' id='mini_toc_c1'><a href='#top'>c</a></h1>
<ul>
<li><a href="#calc_spline">calc_spline</a> &mdash; Calculates a series of values along a Bezier spline.
<li><a href="#calibrate_joystick">calibrate_joystick</a> &mdash; Calibrates the specified joystick.
<li><a href="#calibrate_joystick_name">calibrate_joystick_name</a> &mdash; Returns the next calibration text string.
<li><a href="#canonicalize_filename">canonicalize_filename</a> &mdash; Converts any filename into its canonical form.
<li><a href="#centre_dialog">centre_dialog</a> &mdash; Centers an array of dialog objects.
<li><a href="#check_cpu">check_cpu</a> &mdash; Detects the CPU type.
<li><a href="#circle">circle</a> &mdash; Draws a circle.
<li><a href="#circlefill">circlefill</a> &mdash; Draws a filled circle.
<li><a href="#clear_bitmap">clear_bitmap</a> &mdash; Clears the bitmap to color 0.
<li><a href="#clear_keybuf">clear_keybuf</a> &mdash; Clears the keyboard buffer.
<li><a href="#clear_scene">clear_scene</a> &mdash; Initializes a scene.
<li><a href="#clear_to_color">clear_to_color</a> &mdash; Clears the bitmap to the specified color.
<li><a href="#clear_zbuffer">clear_zbuffer</a> &mdash; Writes a depth value into the given Z-buffer.
<li><a href="#clip3d">clip3d</a> &mdash; Clips the polygon given in vtx using fixed point math.
<li><a href="#clip3d_f">clip3d_f</a> &mdash; Clips the polygon given in vtx using floating point math,
<li><a href="#close_fli">close_fli</a> &mdash; Closes a FLI file previously opened.
<li><a href="#color_map">color_map</a> &mdash; Global pointer to the color mapping table.
<li><a href="#config_is_hooked">config_is_hooked</a> &mdash; Tells if a config section has custom hooks.
<li><a href="#convert_bitmap_to_hbitmap">convert_bitmap_to_hbitmap</a> &mdash; Converts an Allegro memory bitmap to a Windows DDB.
<li><a href="#convert_hbitmap_to_bitmap">convert_hbitmap_to_bitmap</a> &mdash; Creates an Allegro memory bitmap from a Windows DDB.
<li><a href="#convert_hpalette_to_palette">convert_hpalette_to_palette</a> &mdash; Converts a Windows palette to an Allegro palette.
<li><a href="#convert_palette_to_hpalette">convert_palette_to_hpalette</a> &mdash; Converts an Allegro palette to a Windows palette.
<li><a href="#cpu_capabilities">cpu_capabilities</a> &mdash; Contains the capability flags of the CPU.
<li><a href="#cpu_family">cpu_family</a> &mdash; Contains the CPU type.
<li><a href="#cpu_model">cpu_model</a> &mdash; Contains the Intel CPU submodel.
<li><a href="#cpu_vendor">cpu_vendor</a> &mdash; Contains the CPU vendor name.
<li><a href="#create_bitmap">create_bitmap</a> &mdash; Creates a memory bitmap.
<li><a href="#create_bitmap_ex">create_bitmap_ex</a> &mdash; Creates a memory bitmap specifying color depth.
<li><a href="#create_blender_table">create_blender_table</a> &mdash; Emulates truecolor blender effects in paletted modes.
<li><a href="#create_color_table">create_color_table</a> &mdash; Fills a color mapping table for customised effects.
<li><a href="#create_datafile_index">create_datafile_index</a> &mdash; Creates an index for a datafile.
<li><a href="#create_light_table">create_light_table</a> &mdash; Fills a color mapping table for lighting effects.
<li><a href="#create_lzss_pack_data">create_lzss_pack_data</a> &mdash; Creates an LZSS structure for compression.
<li><a href="#create_lzss_unpack_data">create_lzss_unpack_data</a> &mdash; Creates an LZSS structure for decompression.
<li><a href="#create_rgb_table">create_rgb_table</a> &mdash; Generates an RGB mapping table with lookup data for a palette.
<li><a href="#create_sample">create_sample</a> &mdash; Constructs a new sample structure of the specified type.
<li><a href="#create_scene">create_scene</a> &mdash; Allocates memory for a 3d scene.
<li><a href="#create_sub_bitmap">create_sub_bitmap</a> &mdash; Creates a memory sub bitmap.
<li><a href="#create_sub_zbuffer">create_sub_zbuffer</a> &mdash; Creates a sub-z-buffer.
<li><a href="#create_system_bitmap">create_system_bitmap</a> &mdash; Creates a system memory bitmap.
<li><a href="#create_trans_table">create_trans_table</a> &mdash; Fills a color mapping table for translucency effects.
<li><a href="#create_video_bitmap">create_video_bitmap</a> &mdash; Creates a video memory bitmap.
<li><a href="#create_zbuffer">create_zbuffer</a> &mdash; Creates a Z-buffer for a bitmap.
<li><a href="#cross_product">cross_product</a> &mdash; Calculates the cross product.
<li><a href="#cross_product_f">cross_product_f</a> &mdash; Calculates the cross product.

</ul>
<h1 class='mini_toc' id='mini_toc_d1'><a href='#top'>d</a></h1>
<ul>
<li><a href="#d_bitmap_proc">d_bitmap_proc</a> &mdash; Dialog procedure drawing a bitmap.
<li><a href="#d_box_proc">d_box_proc</a> &mdash; Dialog procedure drawing boxes onto the screen.
<li><a href="#d_button_proc">d_button_proc</a> &mdash; Dialog procedure implementing a button object.
<li><a href="#d_check_proc">d_check_proc</a> &mdash; Dialog procedure implementing a check box object.
<li><a href="#d_clear_proc">d_clear_proc</a> &mdash; Dialog procedure to clear the screen.
<li><a href="#d_ctext_proc">d_ctext_proc</a> &mdash; Dialogs procedure drawing text onto the screen.
<li><a href="#d_edit_proc">d_edit_proc</a> &mdash; Dialog procedure implementing an editable text object.
<li><a href="#d_icon_proc">d_icon_proc</a> &mdash; Dialog procedure implementing a bitmap button.
<li><a href="#d_keyboard_proc">d_keyboard_proc</a> &mdash; Invisible dialog procedure for implementing keyboard shortcuts.
<li><a href="#d_list_proc">d_list_proc</a> &mdash; Dialog procedure implementing a list box object.
<li><a href="#d_menu_proc">d_menu_proc</a> &mdash; Dialog procedure implementing a menu bar object.
<li><a href="#d_radio_proc">d_radio_proc</a> &mdash; Dialog procedure implementing a radio button object.
<li><a href="#d_rtext_proc">d_rtext_proc</a> &mdash; Dialogs procedure drawing text onto the screen.
<li><a href="#d_shadow_box_proc">d_shadow_box_proc</a> &mdash; Dialog procedure drawing boxes onto the screen.
<li><a href="#d_slider_proc">d_slider_proc</a> &mdash; Dialog procedure implementing a slider control object.
<li><a href="#d_text_list_proc">d_text_list_proc</a> &mdash; Dialog procedure implementing a list box object with type ahead.
<li><a href="#d_text_proc">d_text_proc</a> &mdash; Dialogs procedure drawing text onto the screen.
<li><a href="#d_textbox_proc">d_textbox_proc</a> &mdash; Dialog procedure implementing a text box object.
<li><a href="#d_yield_proc">d_yield_proc</a> &mdash; Invisible dialog procedure that yields CPU time slices.
<li><a href="#deallocate_voice">deallocate_voice</a> &mdash; Frees a sound card voice.
<li><a href="#default_palette">default_palette</a> &mdash; The default IBM BIOS palette.
<li><a href="#delete_file">delete_file</a> &mdash; Removes a file from the disk.
<li><a href="#desktop_color_depth">desktop_color_depth</a> &mdash; Finds out the desktop color depth.
<li><a href="#desktop_palette">desktop_palette</a> &mdash; The palette used by the Atari ST low resolution desktop.
<li><a href="#destroy_bitmap">destroy_bitmap</a> &mdash; Destroys any type of created bitmap.
<li><a href="#destroy_compiled_sprite">destroy_compiled_sprite</a> &mdash; Destroys a compiled sprite.
<li><a href="#destroy_datafile_index">destroy_datafile_index</a> &mdash; Destroys a datafile index.
<li><a href="#destroy_font">destroy_font</a> &mdash; Frees the memory being used by a font structure.
<li><a href="#destroy_gfx_mode_list">destroy_gfx_mode_list</a> &mdash; Frees the list created by get_gfx_mode_list().
<li><a href="#destroy_midi">destroy_midi</a> &mdash; Destroys a MIDI structure when you are done with it.
<li><a href="#destroy_rle_sprite">destroy_rle_sprite</a> &mdash; Destroys an RLE sprite.
<li><a href="#destroy_sample">destroy_sample</a> &mdash; Destroys a sample structure when you are done with it.
<li><a href="#destroy_scene">destroy_scene</a> &mdash; Deallocates the memory used by a scene.
<li><a href="#destroy_zbuffer">destroy_zbuffer</a> &mdash; Destroys a Z-buffer.
<li><a href="#detect_digi_driver">detect_digi_driver</a> &mdash; Detects whether the specified digital sound device is available.
<li><a href="#detect_midi_driver">detect_midi_driver</a> &mdash; Detects whether the specified MIDI sound device is available.
<li><a href="#dialog_message">dialog_message</a> &mdash; Sends a message to all the objects in an array.
<li><a href="#digi_recorder">digi_recorder</a> &mdash; Hook notifying you when a new sample buffer becomes available.
<li><a href="#disable_hardware_cursor">disable_hardware_cursor</a> &mdash; Disables the OS hardware cursor.
<li><a href="#do_arc">do_arc</a> &mdash; Calculates all the points in a circular arc.
<li><a href="#do_circle">do_circle</a> &mdash; Calculates all the points in a circle.
<li><a href="#do_dialog">do_dialog</a> &mdash; Basic dialog manager function.
<li><a href="#do_ellipse">do_ellipse</a> &mdash; Calculates all the points in an ellipse.
<li><a href="#do_line">do_line</a> &mdash; Calculates all the points along a line.
<li><a href="#do_menu">do_menu</a> &mdash; Displays an animates a popup menu.
<li><a href="#do_uconvert">do_uconvert</a> &mdash; Converts a string to another encoding format.
<li><a href="#dot_product">dot_product</a> &mdash; Calculates the dot product.
<li><a href="#dot_product_f">dot_product_f</a> &mdash; Calculates the dot product.
<li><a href="#draw_character_ex">draw_character_ex</a> &mdash; Draws non transparent pixels of the sprite with a color.
<li><a href="#draw_compiled_sprite">draw_compiled_sprite</a> &mdash; Draws a compiled sprite.
<li><a href="#draw_gouraud_sprite">draw_gouraud_sprite</a> &mdash; Draws a sprite with gouraud shading.
<li><a href="#draw_lit_rle_sprite">draw_lit_rle_sprite</a> &mdash; Draws a tinted RLE sprite.
<li><a href="#draw_lit_sprite">draw_lit_sprite</a> &mdash; Draws a sprite tinted with a specific color.
<li><a href="#draw_rle_sprite">draw_rle_sprite</a> &mdash; Draws an RLE sprite.
<li><a href="#draw_sprite">draw_sprite</a> &mdash; Draws a copy of the sprite onto the destination bitmap.
<li><a href="#draw_sprite_h_flip">draw_sprite_h_flip</a> &mdash; Draws the sprite transformed to the destination bitmap.
<li><a href="#draw_sprite_v_flip">draw_sprite_v_flip</a> &mdash; Draws the sprite transformed to the destination bitmap.
<li><a href="#draw_sprite_vh_flip">draw_sprite_vh_flip</a> &mdash; Draws the sprite transformed to the destination bitmap.
<li><a href="#draw_to_hdc">draw_to_hdc</a> &mdash; Draws an Allegro bitmap to a Windows device context.
<li><a href="#draw_trans_rle_sprite">draw_trans_rle_sprite</a> &mdash; Draws a translucent RLE sprite.
<li><a href="#draw_trans_sprite">draw_trans_sprite</a> &mdash; Draws a sprite blending it with the destination.
<li><a href="#drawing_mode">drawing_mode</a> &mdash; Sets the graphics drawing mode.

</ul>
<h1 class='mini_toc' id='mini_toc_e1'><a href='#top'>e</a></h1>
<ul>
<li><a href="#ellipse">ellipse</a> &mdash; Draws an ellipse.
<li><a href="#ellipsefill">ellipsefill</a> &mdash; Draws a filled ellipse.
<li><a href="#empty_string">empty_string</a> &mdash; Universal string NULL terminator.
<li><a href="#enable_hardware_cursor">enable_hardware_cursor</a> &mdash; Enables the OS hardware cursor.
<li><a href="#enable_triple_buffer">enable_triple_buffer</a> &mdash; Enables triple buffering.
<li><a href="#ex12bit">ex12bit</a> &mdash; How to fake a 12-bit truecolor mode on an 8-bit card.
<li><a href="#ex3buf">ex3buf</a> &mdash; Mode-X triple buffering and retrace interrupt simulation.
<li><a href="#ex3d">ex3d</a> &mdash; 3d 'bouncy cubes' demo.
<li><a href="#exaccel">exaccel</a> &mdash; Using offscreen video memory to store source graphics for VBE/AF.
<li><a href="#exalpha">exalpha</a> &mdash; Creating and using 32 bit RGBA sprites.
<li><a href="#exbitmap">exbitmap</a> &mdash; Loading and displaying PCX and BMP files.
<li><a href="#exblend">exblend</a> &mdash; Using translucency in truecolor modes.
<li><a href="#excamera">excamera</a> &mdash; Viewing a 3d world from an arbitrary camera position.
<li><a href="#excolmap">excolmap</a> &mdash; Creating graphical effects with color mapping tables.
<li><a href="#exconfig">exconfig</a> &mdash; Using the configuration routines.
<li><a href="#excustom">excustom</a> &mdash; Creating custom GUI objects.
<li><a href="#exdata">exdata</a> &mdash; Accessing the contents of datafiles.
<li><a href="#exdbuf">exdbuf</a> &mdash; How to use double buffering to avoid flicker.
<li><a href="#exexedat">exexedat</a> &mdash; Appending datafiles onto your executable.
<li><a href="#exfixed">exfixed</a> &mdash; Using fixed point maths.
<li><a href="#exflame">exflame</a> &mdash; How to write directly to video memory improving performance.
<li><a href="#exflip">exflip</a> &mdash; Comparison of double buffering and page flipping.
<li><a href="#exgui">exgui</a> &mdash; Using the GUI routines.
<li><a href="#exhello">exhello</a> &mdash; Simple graphical "hello world" program.
<li><a href="#exists">exists</a> &mdash; Shortcut version of file_exists() for normal files.
<li><a href="#exjoy">exjoy</a> &mdash; Detecting, calibrating and using joystick input.
<li><a href="#exkeys">exkeys</a> &mdash; How to get input from the keyboard in different ways.
<li><a href="#exlights">exlights</a> &mdash; One way to do colored lighting effects in a hicolor video mode.
<li><a href="#exmem">exmem</a> &mdash; Drawing onto memory bitmaps and then blitting them to the screen.
<li><a href="#exmidi">exmidi</a> &mdash; Playing MIDI music.
<li><a href="#exmouse">exmouse</a> &mdash; Getting input from the mouse.
<li><a href="#expackf">expackf</a> &mdash; Using custom PACKFILE vtables.
<li><a href="#expal">expal</a> &mdash; Palette effects and color cycling.
<li><a href="#expat">expat</a> &mdash; Using patterned drawing modes and sub-bitmaps.
<li><a href="#exquat">exquat</a> &mdash; A comparison between Euler angles and quaternions.
<li><a href="#exrgbhsv">exrgbhsv</a> &mdash; RGB <-> HSV color space conversions.
<li><a href="#exsample">exsample</a> &mdash; Playing digital samples.
<li><a href="#exscale">exscale</a> &mdash; Loading PCX files and bitmap stretching.
<li><a href="#exscn3d">exscn3d</a> &mdash; Using the 3d scene functions.
<li><a href="#exscroll">exscroll</a> &mdash; Mode-X hardware scrolling and split screens.
<li><a href="#exshade">exshade</a> &mdash; Gouraud shaded sprites.
<li><a href="#exspline">exspline</a> &mdash; Constructing smooth movement paths from spline curves.
<li><a href="#exsprite">exsprite</a> &mdash; Datafiles access and sprite animation.
<li><a href="#exstars">exstars</a> &mdash; 3d starfield and lightsourced spaceship.
<li><a href="#exstream">exstream</a> &mdash; Playing audio streams.
<li><a href="#exswitch">exswitch</a> &mdash; Controlling the console switch mode for background running.
<li><a href="#extimer">extimer</a> &mdash; Using the timer (delays and interrupts).
<li><a href="#extract_font_range">extract_font_range</a> &mdash; Extracts a range of characters from a font.
<li><a href="#extrans">extrans</a> &mdash; Lighting and translucency effects.
<li><a href="#extruec">extruec</a> &mdash; Truecolor pixel format conversions.
<li><a href="#exunicod">exunicod</a> &mdash; Using Unicode string functions.
<li><a href="#exupdate">exupdate</a> &mdash; Supporting different screen update methods in a single program.
<li><a href="#exxfade">exxfade</a> &mdash; Truecolor image loading and fades.
<li><a href="#exzbuf">exzbuf</a> &mdash; Z-buffered polygons demo.

</ul>
<h1 class='mini_toc' id='mini_toc_f1'><a href='#top'>f</a></h1>
<ul>
<li><a href="#fade_from">fade_from</a> &mdash; Gradually fades the palette between two others.
<li><a href="#fade_from_range">fade_from_range</a> &mdash; Gradually fades a part of the palette between two others.
<li><a href="#fade_in">fade_in</a> &mdash; Gradually fades the palette from black.
<li><a href="#fade_in_range">fade_in_range</a> &mdash; Gradually fades a part of the palette from black.
<li><a href="#fade_interpolate">fade_interpolate</a> &mdash; Calculates a new palette interpolated between two others.
<li><a href="#fade_out">fade_out</a> &mdash; Gradually fades the palette to black.
<li><a href="#fade_out_range">fade_out_range</a> &mdash; Gradually fades a part of the palette to black.
<li><a href="#fastline">fastline</a> &mdash; Faster version of line().
<li><a href="#file_exists">file_exists</a> &mdash; Tells if a file exists.
<li><a href="#file_select_ex">file_select_ex</a> &mdash; Displays the Allegro file selector with a caption.
<li><a href="#file_size_ex">file_size_ex</a> &mdash; Returns the size of a file in bytes.
<li><a href="#file_time">file_time</a> &mdash; Returns the modification time of a file.
<li><a href="#find_allegro_resource">find_allegro_resource</a> &mdash; Searches for a support file in many places.
<li><a href="#find_datafile_object">find_datafile_object</a> &mdash; Searches a datafile for an object with a name.
<li><a href="#find_dialog_focus">find_dialog_focus</a> &mdash; Searches the dialog for the object which has the input focus.
<li><a href="#fix_filename_case">fix_filename_case</a> &mdash; Converts a filename to a standardised case.
<li><a href="#fix_filename_slashes">fix_filename_slashes</a> &mdash; Converts all the directory separators to a standard character.
<li><a href="#fixacos">fixacos</a> &mdash; Fixed point inverse cosine lookup table.
<li><a href="#fixadd">fixadd</a> &mdash; Safe function to add fixed point numbers clamping overflow.
<li><a href="#fixasin">fixasin</a> &mdash; Fixed point inverse sine lookup table.
<li><a href="#fixatan">fixatan</a> &mdash; Fixed point inverse tangent lookup table.
<li><a href="#fixatan2">fixatan2</a> &mdash; Fixed point version of the libc atan2() routine.
<li><a href="#fixceil">fixceil</a> &mdash; Returns the smallest integer not less than x.
<li><a href="#fixcos">fixcos</a> &mdash; Fixed point cosine of binary angles.
<li><a href="#fixdiv">fixdiv</a> &mdash; Fixed point division.
<li><a href="#fixed">fixed</a> &mdash; Fixed point integer to replace floats.
<li><a href="#fixfloor">fixfloor</a> &mdash; Returns the greatest integer not greater than x.
<li><a href="#fixhypot">fixhypot</a> &mdash; Fixed point hypotenuse.
<li><a href="#fixmul">fixmul</a> &mdash; Multiplies two fixed point values together.
<li><a href="#fixsin">fixsin</a> &mdash; Fixed point sine of binary angles.
<li><a href="#fixsqrt">fixsqrt</a> &mdash; Fixed point square root.
<li><a href="#fixsub">fixsub</a> &mdash; Safe function to subtract fixed point numbers clamping underflow.
<li><a href="#fixtan">fixtan</a> &mdash; Fixed point tangent of binary angles.
<li><a href="#fixtof">fixtof</a> &mdash; Converts a fixed point to floating point.
<li><a href="#fixtoi">fixtoi</a> &mdash; Converts a fixed point to integer with rounding.
<li><a href="#fixtorad_r">fixtorad_r</a> &mdash; Constant to convert angles in fixed point format to radians.
<li><a href="#fixup_datafile">fixup_datafile</a> &mdash; Fixes truecolor images in compiled datafiles.
<li><a href="#fli_bitmap">fli_bitmap</a> &mdash; Contains the current frame of the animation.
<li><a href="#fli_bmp_dirty_from">fli_bmp_dirty_from</a> &mdash; Indicate which parts of the image have changed.
<li><a href="#fli_bmp_dirty_to">fli_bmp_dirty_to</a> &mdash; Indicate which parts of the image have changed.
<li><a href="#fli_frame">fli_frame</a> &mdash; Stores the current frame number of the animation.
<li><a href="#fli_pal_dirty_from">fli_pal_dirty_from</a> &mdash; Indicate which parts of the palette have changed.
<li><a href="#fli_pal_dirty_to">fli_pal_dirty_to</a> &mdash; Indicate which parts of the palette have changed.
<li><a href="#fli_palette">fli_palette</a> &mdash; Contains the current palette of the animation.
<li><a href="#fli_timer">fli_timer</a> &mdash; Global variable for timing FLI playback.
<li><a href="#floodfill">floodfill</a> &mdash; Floodfills an enclosed area.
<li><a href="#flush_config_file">flush_config_file</a> &mdash; Flushes the current config file to disk.
<li><a href="#font">font</a> &mdash; A simple 8x8 fixed size font.
<li><a href="#font_has_alpha">font_has_alpha</a> &mdash; Search all pixels of a font for alpha values.
<li><a href="#for_each_file_ex">for_each_file_ex</a> &mdash; Executes callback() for each file matching a wildcard.
<li><a href="#free_audio_stream_buffer">free_audio_stream_buffer</a> &mdash; Tells the audio stream player new data can be played.
<li><a href="#free_config_entries">free_config_entries</a> &mdash; Frees memory allocated for config entry lists.
<li><a href="#free_lzss_pack_data">free_lzss_pack_data</a> &mdash; Frees an LZSS structure.
<li><a href="#free_lzss_unpack_data">free_lzss_unpack_data</a> &mdash; Frees an LZSS structure.
<li><a href="#freeze_mouse_flag">freeze_mouse_flag</a> &mdash; Flag to avoid redrawing the mouse pointer.
<li><a href="#ftofix">ftofix</a> &mdash; Converts a floating point value to fixed point.

</ul>
<h1 class='mini_toc' id='mini_toc_g1'><a href='#top'>g</a></h1>
<ul>
<li><a href="#generate_332_palette">generate_332_palette</a> &mdash; Constructs a fake truecolor palette.
<li><a href="#generate_optimized_palette">generate_optimized_palette</a> &mdash; Generates an optimized palette for a bitmap.
<li><a href="#get_align_matrix">get_align_matrix</a> &mdash; Rotates a matrix to align it along specified coordinate vectors.
<li><a href="#get_align_matrix_f">get_align_matrix_f</a> &mdash; Floating point version of get_align_matrix().
<li><a href="#get_audio_stream_buffer">get_audio_stream_buffer</a> &mdash; Tells you if you need to fill the audiostream or not.
<li><a href="#get_camera_matrix">get_camera_matrix</a> &mdash; Constructs a camera matrix for perspective projection.
<li><a href="#get_camera_matrix_f">get_camera_matrix_f</a> &mdash; Floating point version of get_camera_matrix().
<li><a href="#get_clip_rect">get_clip_rect</a> &mdash; Returns the clipping rectangle of a bitmap.
<li><a href="#get_clip_state">get_clip_state</a> &mdash; Tells if clipping is on for a bitmap.
<li><a href="#get_color">get_color</a> &mdash; Retrieves the specified palette entry.
<li><a href="#get_color_conversion">get_color_conversion</a> &mdash; Returns the current color conversion mode.
<li><a href="#get_color_depth">get_color_depth</a> &mdash; Returns the current pixel color depth.
<li><a href="#get_compiled_sprite">get_compiled_sprite</a> &mdash; Creates a compiled sprite using a bitmap as source.
<li><a href="#get_config_argv">get_config_argv</a> &mdash; Reads a token list from the configuration file.
<li><a href="#get_config_float">get_config_float</a> &mdash; Retrieves a float from the configuration file.
<li><a href="#get_config_hex">get_config_hex</a> &mdash; Retrieves a hexadecimal value from the configuration file.
<li><a href="#get_config_id">get_config_id</a> &mdash; Retrieves a driver ID from a configuration file.
<li><a href="#get_config_int">get_config_int</a> &mdash; Retrieves an integer from the configuration file.
<li><a href="#get_config_string">get_config_string</a> &mdash; Retrieves a string from the configuration file.
<li><a href="#get_config_text">get_config_text</a> &mdash; Returns a string translated to the current language.
<li><a href="#get_datafile_property">get_datafile_property</a> &mdash; Returns the property string for the object.
<li><a href="#get_desktop_resolution">get_desktop_resolution</a> &mdash; Finds out the desktop resolution.
<li><a href="#get_display_switch_mode">get_display_switch_mode</a> &mdash; Returns the current display switching mode.
<li><a href="#get_executable_name">get_executable_name</a> &mdash; Obtains the full path to the current executable.
<li><a href="#get_extension">get_extension</a> &mdash; Returns a pointer to the extension of a filename.
<li><a href="#get_filename">get_filename</a> &mdash; Returns a pointer to the filename portion of a path.
<li><a href="#get_font_range_begin">get_font_range_begin</a> &mdash; Returns the start of a character range in a font.
<li><a href="#get_font_range_end">get_font_range_end</a> &mdash; Returns the last character of a character range in a font.
<li><a href="#get_font_ranges">get_font_ranges</a> &mdash; Returns the number of character ranges in a font.
<li><a href="#get_gfx_mode_list">get_gfx_mode_list</a> &mdash; Obtains a list of available video modes.
<li><a href="#get_hardware_volume">get_hardware_volume</a> &mdash; Retrieves the hardware sound output volume.
<li><a href="#get_midi_length">get_midi_length</a> &mdash; Determines the total playing time of a midi, in seconds.
<li><a href="#get_mixer_bits">get_mixer_bits</a> &mdash; Returns the mixer bit depth (8 or 16).
<li><a href="#get_mixer_buffer_length">get_mixer_buffer_length</a> &mdash; Returns the number of samples per channel in the mixer buffer.
<li><a href="#get_mixer_channels">get_mixer_channels</a> &mdash; Returns the number of output channels.
<li><a href="#get_mixer_frequency">get_mixer_frequency</a> &mdash; Returns the mixer frequency, in Hz.
<li><a href="#get_mixer_quality">get_mixer_quality</a> &mdash; Returns the current mixing quality.
<li><a href="#get_mixer_voices">get_mixer_voices</a> &mdash; Returns the number of voices allocated to the mixer.
<li><a href="#get_mouse_mickeys">get_mouse_mickeys</a> &mdash; How far the mouse has moved since the last call to this function.
<li><a href="#get_palette">get_palette</a> &mdash; Retrieves the entire palette of 256 colors.
<li><a href="#get_palette_range">get_palette_range</a> &mdash; Retrieves a specific palette range.
<li><a href="#get_refresh_rate">get_refresh_rate</a> &mdash; Returns the current refresh rate.
<li><a href="#get_rle_sprite">get_rle_sprite</a> &mdash; Creates an RLE sprite using a bitmap as source.
<li><a href="#get_rotation_matrix">get_rotation_matrix</a> &mdash; Constructs X, Y, Z rotation matrices.
<li><a href="#get_rotation_matrix_f">get_rotation_matrix_f</a> &mdash; Constructs X, Y, Z rotation matrices.
<li><a href="#get_rotation_quat">get_rotation_quat</a> &mdash; Constructs a quaternion to rotate points around all three axes.
<li><a href="#get_scaling_matrix">get_scaling_matrix</a> &mdash; Constructs a scaling matrix.
<li><a href="#get_scaling_matrix_f">get_scaling_matrix_f</a> &mdash; Constructs a scaling matrix.
<li><a href="#get_sound_input_cap_bits">get_sound_input_cap_bits</a> &mdash; Checks which audio input sample formats are supported.
<li><a href="#get_sound_input_cap_parm">get_sound_input_cap_parm</a> &mdash; Detects if the specified recording parameters are supported.
<li><a href="#get_sound_input_cap_rate">get_sound_input_cap_rate</a> &mdash; Returns the maximum sample frequency for recording.
<li><a href="#get_sound_input_cap_stereo">get_sound_input_cap_stereo</a> &mdash; Tells if the input driver is capable of stereo recording.
<li><a href="#get_transformation_matrix">get_transformation_matrix</a> &mdash; Constructs X, Y, Z rotation matrices with an angle and scaling.
<li><a href="#get_transformation_matrix_f">get_transformation_matrix_f</a> &mdash; Floating point version of get_transformation_matrix().
<li><a href="#get_translation_matrix">get_translation_matrix</a> &mdash; Constructs a translation matrix.
<li><a href="#get_translation_matrix_f">get_translation_matrix_f</a> &mdash; Constructs a translation matrix.
<li><a href="#get_uformat">get_uformat</a> &mdash; Finds out what text encoding format is currently selected.
<li><a href="#get_vector_rotation_matrix">get_vector_rotation_matrix</a> &mdash; Constructs X, Y, Z rotation matrices with an angle.
<li><a href="#get_vector_rotation_matrix_f">get_vector_rotation_matrix_f</a> &mdash; Constructs X, Y, Z rotation matrices with an angle.
<li><a href="#get_vector_rotation_quat">get_vector_rotation_quat</a> &mdash; Constructs a quaternion to rotate points around a vector.
<li><a href="#get_volume">get_volume</a> &mdash; Retrieves the global sound output volume.
<li><a href="#get_x_rotate_matrix">get_x_rotate_matrix</a> &mdash; Construct X axis rotation matrices.
<li><a href="#get_x_rotate_matrix_f">get_x_rotate_matrix_f</a> &mdash; Construct X axis rotation matrices.
<li><a href="#get_x_rotate_quat">get_x_rotate_quat</a> &mdash; Construct axis rotation quaternions.
<li><a href="#get_y_rotate_matrix">get_y_rotate_matrix</a> &mdash; Construct Y axis rotation matrices.
<li><a href="#get_y_rotate_matrix_f">get_y_rotate_matrix_f</a> &mdash; Construct Y axis rotation matrices.
<li><a href="#get_y_rotate_quat">get_y_rotate_quat</a> &mdash; Construct axis rotation quaternions.
<li><a href="#get_z_rotate_matrix">get_z_rotate_matrix</a> &mdash; Construct Z axis rotation matrices.
<li><a href="#get_z_rotate_matrix_f">get_z_rotate_matrix_f</a> &mdash; Construct Z axis rotation matrices.
<li><a href="#get_z_rotate_quat">get_z_rotate_quat</a> &mdash; Construct axis rotation quaternions.
<li><a href="#geta">geta</a> &mdash; Extract a color component from the current pixel format.
<li><a href="#geta32">geta32</a> &mdash; Extract the alpha component form a 32-bit pixel format color.
<li><a href="#geta_depth">geta_depth</a> &mdash; Extract a color component from a color in a specified pixel format.
<li><a href="#getb">getb</a> &mdash; Extract a color component from the current pixel format.
<li><a href="#getb15">getb15</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getb16">getb16</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getb24">getb24</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getb32">getb32</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getb8">getb8</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getb_depth">getb_depth</a> &mdash; Extract a color component from a color in a specified pixel format.
<li><a href="#getg">getg</a> &mdash; Extract a color component from the current pixel format.
<li><a href="#getg15">getg15</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getg16">getg16</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getg24">getg24</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getg32">getg32</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getg8">getg8</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getg_depth">getg_depth</a> &mdash; Extract a color component from a color in a specified pixel format.
<li><a href="#getpixel">getpixel</a> &mdash; Reads a pixel from a bitmap.
<li><a href="#getr">getr</a> &mdash; Extract a color component from the current pixel format.
<li><a href="#getr15">getr15</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getr16">getr16</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getr24">getr24</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getr32">getr32</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getr8">getr8</a> &mdash; Extract a color component from the specified pixel format.
<li><a href="#getr_depth">getr_depth</a> &mdash; Extract a color component from a color in a specified pixel format.
<li><a href="#gfx_capabilities">gfx_capabilities</a> &mdash; Bitfield describing video hardware capabilities.
<li><a href="#gfx_mode_select">gfx_mode_select</a> &mdash; Displays the Allegro graphics mode selection dialog.
<li><a href="#gfx_mode_select_ex">gfx_mode_select_ex</a> &mdash; Extended version of the graphics mode selection dialog.
<li><a href="#gfx_mode_select_filter">gfx_mode_select_filter</a> &mdash; Even more extended version of the graphics mode selection dialog.
<li><a href="#grab_font_from_bitmap">grab_font_from_bitmap</a> &mdash; Grabs a font from a bitmap
<li><a href="#gui_bg_color">gui_bg_color</a> &mdash; The foreground and background colors for the standard dialogs.
<li><a href="#gui_button_proc">gui_button_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_ctext_proc">gui_ctext_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_edit_proc">gui_edit_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_fg_color">gui_fg_color</a> &mdash; The foreground and background colors for the standard dialogs.
<li><a href="#gui_font_baseline">gui_font_baseline</a> &mdash; Adjusts the keyboard shortcut underscores height.
<li><a href="#gui_get_screen">gui_get_screen</a> &mdash; Returns the bitmap surface GUI routines draw to.
<li><a href="#gui_list_proc">gui_list_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_menu_draw_menu">gui_menu_draw_menu</a> &mdash; Hooks to modify the appearance of menus.
<li><a href="#gui_menu_draw_menu_item">gui_menu_draw_menu_item</a> &mdash; Hooks to modify the appearance of menus.
<li><a href="#gui_mg_color">gui_mg_color</a> &mdash; The color used for displaying greyed-out dialog objects.
<li><a href="#gui_mouse_b">gui_mouse_b</a> &mdash; Hook functions used by the GUI routines to access the mouse state.
<li><a href="#gui_mouse_focus">gui_mouse_focus</a> &mdash; Tells if the input focus follows the mouse pointer.
<li><a href="#gui_mouse_x">gui_mouse_x</a> &mdash; Hook functions used by the GUI routines to access the mouse state.
<li><a href="#gui_mouse_y">gui_mouse_y</a> &mdash; Hook functions used by the GUI routines to access the mouse state.
<li><a href="#gui_mouse_z">gui_mouse_z</a> &mdash; Hook functions used by the GUI routines to access the mouse state.
<li><a href="#gui_set_screen">gui_set_screen</a> &mdash; Changes the bitmap surface GUI routines draw to.
<li><a href="#gui_shadow_box_proc">gui_shadow_box_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_strlen">gui_strlen</a> &mdash; Returns the length of a string in pixels.
<li><a href="#gui_text_list_proc">gui_text_list_proc</a> &mdash; Hooks to customise the look and feel of Allegro dialogs.
<li><a href="#gui_textout_ex">gui_textout_ex</a> &mdash; Draws a text string onto the screen with keyboard shortcut underbars.

</ul>
<h1 class='mini_toc' id='mini_toc_h1'><a href='#top'>h</a></h1>
<ul>
<li><a href="#hline">hline</a> &mdash; Draws a horizontal line onto the bitmap.
<li><a href="#hook_config_section">hook_config_section</a> &mdash; Hooks a configuration file section with custom handlers.
<li><a href="#hsv_to_rgb">hsv_to_rgb</a> &mdash; Converts color values between the HSV and RGB color spaces.

</ul>
<h1 class='mini_toc' id='mini_toc_i1'><a href='#top'>i</a></h1>
<ul>
<li><a href="#i_love_bill">i_love_bill</a> &mdash; Tells if Allegro has to used fixed rate timers.
<li><a href="#identity_matrix">identity_matrix</a> &mdash; Global containing the identity matrix.
<li><a href="#identity_matrix_f">identity_matrix_f</a> &mdash; Global containing the identity matrix.
<li><a href="#identity_quat">identity_quat</a> &mdash; Global variable containing the identity quaternion.
<li><a href="#init_dialog">init_dialog</a> &mdash; Low level initialisation of a dialog.
<li><a href="#init_menu">init_menu</a> &mdash; Low level initialisation of a menu.
<li><a href="#initialise_joystick">initialise_joystick</a> &mdash; Deprecated version of install_joystick().
<li><a href="#install_allegro">install_allegro</a> &mdash; Initialise the Allegro library.
<li><a href="#install_int">install_int</a> &mdash; Installs a user timer handler.
<li><a href="#install_int_ex">install_int_ex</a> &mdash; Adds or modifies a timer.
<li><a href="#install_joystick">install_joystick</a> &mdash; Initialises the joystick.
<li><a href="#install_keyboard">install_keyboard</a> &mdash; Installs the Allegro keyboard interrupt handler.
<li><a href="#install_keyboard_hooks">install_keyboard_hooks</a> &mdash; Installs custom keyboard hooks.
<li><a href="#install_mouse">install_mouse</a> &mdash; Installs the Allegro mouse handler.
<li><a href="#install_param_int">install_param_int</a> &mdash; Installs a timer routine with a customizable parameter.
<li><a href="#install_param_int_ex">install_param_int_ex</a> &mdash; Adds or modifies a timer with a customizable parameter.
<li><a href="#install_sound">install_sound</a> &mdash; Initialises the sound module.
<li><a href="#install_sound_input">install_sound_input</a> &mdash; Initialises the sound recorder module.
<li><a href="#install_timer">install_timer</a> &mdash; Installs the Allegro timer interrupt handler.
<li><a href="#is_color_font">is_color_font</a> &mdash; Returns TRUE if a font is a color font.
<li><a href="#is_compatible_font">is_compatible_font</a> &mdash; Check if two fonts are of the same type.
<li><a href="#is_inside_bitmap">is_inside_bitmap</a> &mdash; Tells if a point is inside a bitmap.
<li><a href="#is_linear_bitmap">is_linear_bitmap</a> &mdash; Tells if a bitmap is linear.
<li><a href="#is_memory_bitmap">is_memory_bitmap</a> &mdash; Tells if a bitmap is a memory bitmap.
<li><a href="#is_mono_font">is_mono_font</a> &mdash; Returns TRUE if a font is a monochrome font.
<li><a href="#is_planar_bitmap">is_planar_bitmap</a> &mdash; Tells if a bitmap is a planar screen bitmap.
<li><a href="#is_relative_filename">is_relative_filename</a> &mdash; Returns TRUE if the filename is relative.
<li><a href="#is_same_bitmap">is_same_bitmap</a> &mdash; Tells if two bitmaps describe the same drawing surface.
<li><a href="#is_screen_bitmap">is_screen_bitmap</a> &mdash; Tells if a bitmap is the screen bitmap or sub bitmap.
<li><a href="#is_sub_bitmap">is_sub_bitmap</a> &mdash; Tells if a bitmap is a sub bitmap.
<li><a href="#is_system_bitmap">is_system_bitmap</a> &mdash; Tells if a bitmap is a system bitmap or sub bitmap.
<li><a href="#is_trans_font">is_trans_font</a> &mdash; Returns TRUE if a font uses transparency.
<li><a href="#is_video_bitmap">is_video_bitmap</a> &mdash; Tells if a bitmap is a screen bitmap, video memory or sub bitmap.
<li><a href="#is_windowed_mode">is_windowed_mode</a> &mdash; Tells if you are running in windowed mode.
<li><a href="#itofix">itofix</a> &mdash; Converts an integer to fixed point.

</ul>
<h1 class='mini_toc' id='mini_toc_j1'><a href='#top'>j</a></h1>
<ul>
<li><a href="#joy">joy</a> &mdash; Global array of joystick state information.

</ul>
<h1 class='mini_toc' id='mini_toc_k1'><a href='#top'>k</a></h1>
<ul>
<li><a href="#key">key</a> &mdash; Array of flags indicating key state.
<li><a href="#key_led_flag">key_led_flag</a> &mdash; Flag to prevent the keyboard LEDs from being updated.
<li><a href="#key_shifts">key_shifts</a> &mdash; Bitmask containing the current state of modifier keys.
<li><a href="#keyboard_callback">keyboard_callback</a> &mdash; User specified keyboard callback handler.
<li><a href="#keyboard_lowlevel_callback">keyboard_lowlevel_callback</a> &mdash; User specified low level keyboard event handler.
<li><a href="#keyboard_needs_poll">keyboard_needs_poll</a> &mdash; Tells if the keyboard needs polling.
<li><a href="#keyboard_ucallback">keyboard_ucallback</a> &mdash; User specified unicode keyboard callback handler.
<li><a href="#keypressed">keypressed</a> &mdash; Tells if there are keypresses waiting in the input buffer.

</ul>
<h1 class='mini_toc' id='mini_toc_l1'><a href='#top'>l</a></h1>
<ul>
<li><a href="#line">line</a> &mdash; Draws a line onto the bitmap.
<li><a href="#list_config_entries">list_config_entries</a> &mdash; Lists the names of all entries in a config section
<li><a href="#list_config_sections">list_config_sections</a> &mdash; Lists the names of all sections available in the current configuration.
<li><a href="#load_bios_font">load_bios_font</a> &mdash; Loads a 8x8 or 8x16 BIOS format font.
<li><a href="#load_bitmap">load_bitmap</a> &mdash; Loads any supported bitmap from a file.
<li><a href="#load_bitmap_font">load_bitmap_font</a> &mdash; Grabs a font from a bitmap file.
<li><a href="#load_bmp">load_bmp</a> &mdash; Loads a BMP bitmap from a file.
<li><a href="#load_bmp_pf">load_bmp_pf</a> &mdash; Packfile version of load_bmp.
<li><a href="#load_dat_font">load_dat_font</a> &mdash; Loads a FONT from an Allegro datafile.
<li><a href="#load_datafile">load_datafile</a> &mdash; Loads a datafile into memory.
<li><a href="#load_datafile_callback">load_datafile_callback</a> &mdash; Loads a datafile into memory, calling a hook per object.
<li><a href="#load_datafile_object">load_datafile_object</a> &mdash; Loads a specific object from a datafile.
<li><a href="#load_datafile_object_indexed">load_datafile_object_indexed</a> &mdash; Loads a single object from a datafile index.
<li><a href="#load_font">load_font</a> &mdash; Loads a font from a file.
<li><a href="#load_grx_font">load_grx_font</a> &mdash; Loads a GRX format font.
<li><a href="#load_grx_or_bios_font">load_grx_or_bios_font</a> &mdash; Loads either a BIOS or GRX format font.
<li><a href="#load_ibk">load_ibk</a> &mdash; Reads in a .IBK patch definition file for the Adlib driver.
<li><a href="#load_joystick_data">load_joystick_data</a> &mdash; Loads joystick calibration data.
<li><a href="#load_lbm">load_lbm</a> &mdash; Loads an LBM bitmap from a file.
<li><a href="#load_midi">load_midi</a> &mdash; Loads a MIDI file.
<li><a href="#load_midi_patches">load_midi_patches</a> &mdash; Forces the MIDI driver to load a set of patches.
<li><a href="#load_pcx">load_pcx</a> &mdash; Loads a PCX bitmap from a file.
<li><a href="#load_pcx_pf">load_pcx_pf</a> &mdash; Packfile version of load_pcx.
<li><a href="#load_sample">load_sample</a> &mdash; Loads a sample from a file.
<li><a href="#load_tga">load_tga</a> &mdash; Loads a TGA bitmap from a file.
<li><a href="#load_tga_pf">load_tga_pf</a> &mdash; Packfile version of load_tga.
<li><a href="#load_txt_font">load_txt_font</a> &mdash; Loads a font script.
<li><a href="#load_voc">load_voc</a> &mdash; Loads a sample from a Creative Labs VOC file.
<li><a href="#load_voc_pf">load_voc_pf</a> &mdash; Packfile version of load_voc.
<li><a href="#load_wav">load_wav</a> &mdash; Loads a sample from a RIFF WAV file.
<li><a href="#load_wav_pf">load_wav_pf</a> &mdash; Packfile version of load_wav.
<li><a href="#lock_bitmap">lock_bitmap</a> &mdash; Locks the memory used by a bitmap.
<li><a href="#lock_midi">lock_midi</a> &mdash; Locks all the memory used by a MIDI file.
<li><a href="#lock_sample">lock_sample</a> &mdash; Locks all the memory used by a sample.
<li><a href="#lzss_read">lzss_read</a> &mdash; Decompresses data using LZSS.
<li><a href="#lzss_write">lzss_write</a> &mdash; Compresses data using LZSS.

</ul>
<h1 class='mini_toc' id='mini_toc_m1'><a href='#top'>m</a></h1>
<ul>
<li><a href="#make_absolute_filename">make_absolute_filename</a> &mdash; Makes an absolute filename from a path and relative filename.
<li><a href="#make_relative_filename">make_relative_filename</a> &mdash; Tries to make a relative filename from absolute path and filename.
<li><a href="#make_trans_font">make_trans_font</a> &mdash; Makes a font use transparency.
<li><a href="#makeacol">makeacol</a> &mdash; Converts RGBA colors into display dependent pixel formats.
<li><a href="#makeacol32">makeacol32</a> &mdash; Converts an RGBA color into a 32-bit display pixel format.
<li><a href="#makeacol_depth">makeacol_depth</a> &mdash; Converts RGBA colors into display dependent pixel formats.
<li><a href="#makecol">makecol</a> &mdash; Converts an RGB value into the current pixel format.
<li><a href="#makecol15">makecol15</a> &mdash; Converts an RGB value into a display dependent pixel format.
<li><a href="#makecol15_dither">makecol15_dither</a> &mdash; Calculates a dithered 15 or 16-bit RGB value.
<li><a href="#makecol16">makecol16</a> &mdash; Converts an RGB value into a display dependent pixel format.
<li><a href="#makecol16_dither">makecol16_dither</a> &mdash; Calculates a dithered 15 or 16-bit RGB value.
<li><a href="#makecol24">makecol24</a> &mdash; Converts an RGB value into a display dependent pixel format.
<li><a href="#makecol32">makecol32</a> &mdash; Converts an RGB value into a display dependent pixel format.
<li><a href="#makecol8">makecol8</a> &mdash; Converts an RGB value into a display dependent pixel format.
<li><a href="#makecol_depth">makecol_depth</a> &mdash; Converts an RGB value into the specified pixel format.
<li><a href="#masked_blit">masked_blit</a> &mdash; Copies a rectangle skipping pixels with the mask color.
<li><a href="#masked_stretch_blit">masked_stretch_blit</a> &mdash; Scales a rectangular area skipping pixels with the mask color.
<li><a href="#matrix_mul">matrix_mul</a> &mdash; Multiplies two matrices.
<li><a href="#matrix_mul_f">matrix_mul_f</a> &mdash; Multiplies two matrices.
<li><a href="#matrix_to_quat">matrix_to_quat</a> &mdash; Constructs a quaternion from a rotation matrix.
<li><a href="#merge_fonts">merge_fonts</a> &mdash; Merges two fonts into one font.
<li><a href="#midi_loop_end">midi_loop_end</a> &mdash; Loop start and end points, set by play_looped_midi().
<li><a href="#midi_loop_start">midi_loop_start</a> &mdash; Loop start and end points, set by play_looped_midi().
<li><a href="#midi_meta_callback">midi_meta_callback</a> &mdash; Hook functions allowing you to intercept MIDI player events.
<li><a href="#midi_msg_callback">midi_msg_callback</a> &mdash; Hook functions allowing you to intercept MIDI player events.
<li><a href="#midi_out">midi_out</a> &mdash; Streams a block of MIDI commands into the player.
<li><a href="#midi_pause">midi_pause</a> &mdash; Pauses the MIDI player.
<li><a href="#midi_pos">midi_pos</a> &mdash; Stores the current position in the MIDI file.
<li><a href="#midi_recorder">midi_recorder</a> &mdash; Hook notifying you when new MIDI data becomes available.
<li><a href="#midi_resume">midi_resume</a> &mdash; Resumes playback of a paused MIDI file.
<li><a href="#midi_seek">midi_seek</a> &mdash; Seeks to the given midi_pos in the current MIDI file.
<li><a href="#midi_sysex_callback">midi_sysex_callback</a> &mdash; Hook functions allowing you to intercept MIDI player events.
<li><a href="#midi_time">midi_time</a> &mdash; The current position in the MIDI file, in seconds.
<li><a href="#mouse_b">mouse_b</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#mouse_callback">mouse_callback</a> &mdash; User specified mouse callback.
<li><a href="#mouse_needs_poll">mouse_needs_poll</a> &mdash; Tells if the mouse driver requires polling.
<li><a href="#mouse_pos">mouse_pos</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#mouse_sprite">mouse_sprite</a> &mdash; Global variable with the mouse sprite and focus point.
<li><a href="#mouse_w">mouse_w</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#mouse_x">mouse_x</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#mouse_x_focus">mouse_x_focus</a> &mdash; Global variable with the mouse sprite and focus point.
<li><a href="#mouse_y">mouse_y</a> &mdash; Global variable with the mouse position/button state.
<li><a href="#mouse_y_focus">mouse_y_focus</a> &mdash; Global variable with the mouse sprite and focus point.
<li><a href="#mouse_z">mouse_z</a> &mdash; Global variable with the mouse position/button state.

</ul>
<h1 class='mini_toc' id='mini_toc_n1'><a href='#top'>n</a></h1>
<ul>
<li><a href="#need_uconvert">need_uconvert</a> &mdash; Tells if a string requires encoding conversion.
<li><a href="#next_fli_frame">next_fli_frame</a> &mdash; Reads the next frame of the current animation file.
<li><a href="#normalize_vector">normalize_vector</a> &mdash; Converts the vector to a unit vector.
<li><a href="#normalize_vector_f">normalize_vector_f</a> &mdash; Converts the vector to a unit vector.
<li><a href="#num_joysticks">num_joysticks</a> &mdash; Global variable saying how many joysticks there are.

</ul>
<h1 class='mini_toc' id='mini_toc_o1'><a href='#top'>o</a></h1>
<ul>
<li><a href="#object_message">object_message</a> &mdash; Sends a message to an object and returns the answer.
<li><a href="#offer_focus">offer_focus</a> &mdash; Offers the input focus to a particular object.
<li><a href="#open_fli">open_fli</a> &mdash; Makes a FLI file open and ready for playing.
<li><a href="#open_memory_fli">open_memory_fli</a> &mdash; Makes a FLI file open and ready for playing.
<li><a href="#os_multitasking">os_multitasking</a> &mdash; Indicates if the OS is multitasking.
<li><a href="#os_revision">os_revision</a> &mdash; Version of the OS currently running.
<li><a href="#os_type">os_type</a> &mdash; Stores the detected type of the OS.
<li><a href="#os_version">os_version</a> &mdash; Version of the OS currently running.
<li><a href="#override_config_data">override_config_data</a> &mdash; Specifies a block of data containing config overrides.
<li><a href="#override_config_file">override_config_file</a> &mdash; Specifies a file containing config overrides.

</ul>
<h1 class='mini_toc' id='mini_toc_p1'><a href='#top'>p</a></h1>
<ul>
<li><a href="#pack_fclose">pack_fclose</a> &mdash; Closes a stream previously opened.
<li><a href="#pack_fclose_chunk">pack_fclose_chunk</a> &mdash; Closes a previously opened sub-chunk.
<li><a href="#pack_feof">pack_feof</a> &mdash; Returns nonzero as soon as you reach the end of the file.
<li><a href="#pack_ferror">pack_ferror</a> &mdash; Tells if an error occurred during an operation on the stream.
<li><a href="#pack_fgets">pack_fgets</a> &mdash; Reads a line from the stream.
<li><a href="#pack_fopen">pack_fopen</a> &mdash; Opens a file according to mode.
<li><a href="#pack_fopen_chunk">pack_fopen_chunk</a> &mdash; Opens a sub-chunk of a file.
<li><a href="#pack_fopen_vtable">pack_fopen_vtable</a> 
<li><a href="#pack_fputs">pack_fputs</a> &mdash; Writes a string to the stream.
<li><a href="#pack_fread">pack_fread</a> &mdash; Reads n bytes from the stream.
<li><a href="#pack_fseek">pack_fseek</a> &mdash; Seeks inside a stream.
<li><a href="#pack_fwrite">pack_fwrite</a> &mdash; Writes n bytes to the stream.
<li><a href="#pack_getc">pack_getc</a> &mdash; Returns the next character from a stream.
<li><a href="#pack_igetl">pack_igetl</a> &mdash; Like pack_getc(), but using 32-bit Intel byte ordering words.
<li><a href="#pack_igetw">pack_igetw</a> &mdash; Like pack_getc(), but using 16-bit Intel byte ordering words.
<li><a href="#pack_iputl">pack_iputl</a> &mdash; Like pack_putc(), but using 32-bit Intel byte ordering words.
<li><a href="#pack_iputw">pack_iputw</a> &mdash; Like pack_putc(), but using 16-bit Intel byte ordering words.
<li><a href="#pack_mgetl">pack_mgetl</a> &mdash; Like pack_getc(), but using 32-bit Motorola byte ordering words.
<li><a href="#pack_mgetw">pack_mgetw</a> &mdash; Like pack_getc(), but using 16-bit Motorola byte ordering words.
<li><a href="#pack_mputl">pack_mputl</a> &mdash; Like pack_putc(), but using 32-bit Motorola byte ordering words.
<li><a href="#pack_mputw">pack_mputw</a> &mdash; Like pack_putc(), but using 16-bit Motorola byte ordering words.
<li><a href="#pack_putc">pack_putc</a> &mdash; Puts a character in the stream.
<li><a href="#pack_ungetc">pack_ungetc</a> &mdash; Moves one single character back to the input buffer.
<li><a href="#packfile_password">packfile_password</a> &mdash; Sets the global I/O encryption password.
<li><a href="#palette_color">palette_color</a> &mdash; Maps palette indexes into the current pixel format colors.
<li><a href="#persp_project">persp_project</a> &mdash; Projects a 3d point into 2d screen space.
<li><a href="#persp_project_f">persp_project_f</a> &mdash; Projects a 3d point into 2d screen space.
<li><a href="#pivot_scaled_sprite">pivot_scaled_sprite</a> &mdash; Rotates and stretches a sprite around a specified point.
<li><a href="#pivot_scaled_sprite_v_flip">pivot_scaled_sprite_v_flip</a> &mdash; Rotates, stretches and flips a sprite around a specified point.
<li><a href="#pivot_sprite">pivot_sprite</a> &mdash; Rotates a sprite around a specified point.
<li><a href="#pivot_sprite_v_flip">pivot_sprite_v_flip</a> &mdash; Rotates and flips a sprite around a specified point.
<li><a href="#play_audio_stream">play_audio_stream</a> &mdash; Creates a new audio stream and starts playing it.
<li><a href="#play_fli">play_fli</a> &mdash; Plays a FLI or FLC animation from disk.
<li><a href="#play_looped_midi">play_looped_midi</a> &mdash; Starts playing a MIDI file with a user-defined loop position.
<li><a href="#play_memory_fli">play_memory_fli</a> &mdash; Plays a FLI or FLC animation from memory.
<li><a href="#play_midi">play_midi</a> &mdash; Starts playing the specified MIDI file.
<li><a href="#play_sample">play_sample</a> &mdash; Plays a sample.
<li><a href="#poll_joystick">poll_joystick</a> &mdash; Polls the joystick.
<li><a href="#poll_keyboard">poll_keyboard</a> &mdash; Polls the keyboard.
<li><a href="#poll_mouse">poll_mouse</a> &mdash; Polls the mouse.
<li><a href="#poll_scroll">poll_scroll</a> &mdash; Checks the status of a scroll request with triple buffering.
<li><a href="#polygon">polygon</a> &mdash; Draws a filled polygon.
<li><a href="#polygon3d">polygon3d</a> &mdash; Draws a 3d polygon onto the specified bitmap.
<li><a href="#polygon3d_f">polygon3d_f</a> &mdash; Draws a 3d polygon onto the specified bitmap.
<li><a href="#polygon_z_normal">polygon_z_normal</a> &mdash; Finds the Z component of the normal vector to three vertices.
<li><a href="#polygon_z_normal_f">polygon_z_normal_f</a> &mdash; Finds the Z component of the normal vector to three vertices.
<li><a href="#pop_config_state">pop_config_state</a> &mdash; Pops a previously pushed configuration state.
<li><a href="#popup_dialog">popup_dialog</a> &mdash; do_dialog() used for popup dialogs.
<li><a href="#position_dialog">position_dialog</a> &mdash; Moves an array of dialog objects to the specified position.
<li><a href="#position_mouse">position_mouse</a> &mdash; Moves the mouse to the specified screen position.
<li><a href="#position_mouse_w">position_mouse_w</a> &mdash; Sets the horizontal mouse wheel position.
<li><a href="#position_mouse_z">position_mouse_z</a> &mdash; Sets the mouse wheel position global variable.
<li><a href="#push_config_state">push_config_state</a> &mdash; Pushes the current configuration state.
<li><a href="#put_backslash">put_backslash</a> &mdash; Puts a path separator at the end of a path if needed.
<li><a href="#putpixel">putpixel</a> &mdash; Writes a pixel into a bitmap.

</ul>
<h1 class='mini_toc' id='mini_toc_q1'><a href='#top'>q</a></h1>
<ul>
<li><a href="#qnx_get_window">qnx_get_window</a> &mdash; Retrieves a handle to the window used by Allegro.
<li><a href="#qscale_matrix">qscale_matrix</a> &mdash; Optimised routine for scaling an already generated matrix.
<li><a href="#qscale_matrix_f">qscale_matrix_f</a> &mdash; Optimised routine for scaling an already generated matrix.
<li><a href="#qtranslate_matrix">qtranslate_matrix</a> &mdash; Optimised routine for translating an already generated matrix.
<li><a href="#qtranslate_matrix_f">qtranslate_matrix_f</a> &mdash; Optimised routine for translating an already generated matrix.
<li><a href="#quad3d">quad3d</a> &mdash; Draws a 3d quad onto the specified bitmap.
<li><a href="#quad3d_f">quad3d_f</a> &mdash; Draws a 3d quad onto the specified bitmap.
<li><a href="#quat_interpolate">quat_interpolate</a> &mdash; Constructs a quaternion representing a rotation between from and to.
<li><a href="#quat_mul">quat_mul</a> &mdash; Multiplies two quaternions.
<li><a href="#quat_slerp">quat_slerp</a> &mdash; Version of quat_interpolate() allowing control over the rotation.
<li><a href="#quat_to_matrix">quat_to_matrix</a> &mdash; Constructs a rotation matrix from a quaternion.

</ul>
<h1 class='mini_toc' id='mini_toc_r1'><a href='#top'>r</a></h1>
<ul>
<li><a href="#radtofix_r">radtofix_r</a> &mdash; Constant to convert radians to fixed point angles.
<li><a href="#read_sound_input">read_sound_input</a> &mdash; Retrieves the last recorded audio buffer.
<li><a href="#readkey">readkey</a> &mdash; Returns the next character from the keyboard buffer.
<li><a href="#reallocate_voice">reallocate_voice</a> &mdash; Switches the sample of an already-allocated voice.
<li><a href="#rect">rect</a> &mdash; Draws an outline rectangle.
<li><a href="#rectfill">rectfill</a> &mdash; Draws a solid filled rectangle.
<li><a href="#register_assert_handler">register_assert_handler</a> &mdash; Registers a custom handler for assert failures.
<li><a href="#register_bitmap_file_type">register_bitmap_file_type</a> &mdash; Registers custom bitmap loading/saving functions.
<li><a href="#register_datafile_object">register_datafile_object</a> &mdash; Registers load/destroy functions for custom object types.
<li><a href="#register_font_file_type">register_font_file_type</a> &mdash; Register a new font loading function.
<li><a href="#register_sample_file_type">register_sample_file_type</a> &mdash; Registers custom loading/saving sample routines.
<li><a href="#register_trace_handler">register_trace_handler</a> &mdash; Registers a custom handler for trace output.
<li><a href="#register_uformat">register_uformat</a> &mdash; Installs handler functions for a new text encoding format.
<li><a href="#release_bitmap">release_bitmap</a> &mdash; Releases a previously locked bitmap.
<li><a href="#release_screen">release_screen</a> &mdash; Shortcut of release_bitmap(screen);
<li><a href="#release_voice">release_voice</a> &mdash; Releases a sound card voice.
<li><a href="#reload_config_texts">reload_config_texts</a> &mdash; Reloads translated strings returned by get_config_text().
<li><a href="#remove_display_switch_callback">remove_display_switch_callback</a> &mdash; Removes a switching notification callback.
<li><a href="#remove_int">remove_int</a> &mdash; Removes a timers.
<li><a href="#remove_joystick">remove_joystick</a> &mdash; Removes the joystick handler.
<li><a href="#remove_keyboard">remove_keyboard</a> &mdash; Removes the Allegro keyboard handler.
<li><a href="#remove_mouse">remove_mouse</a> &mdash; Removes the mouse handler.
<li><a href="#remove_param_int">remove_param_int</a> &mdash; Removes a timer with a customizable parameter.
<li><a href="#remove_sound">remove_sound</a> &mdash; Cleans up after you are finished with the sound routines.
<li><a href="#remove_sound_input">remove_sound_input</a> &mdash; Cleans up after you are finished with the sound input routines.
<li><a href="#remove_timer">remove_timer</a> &mdash; Removes the Allegro time handler.
<li><a href="#render_scene">render_scene</a> &mdash; Renders all the queued scene polygons.
<li><a href="#replace_extension">replace_extension</a> &mdash; Replaces filename+extension with a new extension tail.
<li><a href="#replace_filename">replace_filename</a> &mdash; Replaces path+filename with a new filename tail.
<li><a href="#request_refresh_rate">request_refresh_rate</a> &mdash; Requests a specific refresh rate during graphic mode switch.
<li><a href="#request_scroll">request_scroll</a> &mdash; Queues a hardware scroll request with triple buffering.
<li><a href="#request_video_bitmap">request_video_bitmap</a> &mdash; Triple buffering page flip request.
<li><a href="#reserve_voices">reserve_voices</a> &mdash; Reserve a number of voices for the digital and MIDI drivers.
<li><a href="#reset_fli_variables">reset_fli_variables</a> &mdash; Resets the bitmap and palette dirty global variables.
<li><a href="#rest">rest</a> &mdash; Waits a specified number of milliseconds or yields CPU.
<li><a href="#rest_callback">rest_callback</a> &mdash; Like rest(), but calls the callback during the wait.
<li><a href="#retrace_count">retrace_count</a> &mdash; Retrace count simulator.
<li><a href="#rgb_map">rgb_map</a> &mdash; Look up table to speed up reducing RGB values to palette colors.
<li><a href="#rgb_to_hsv">rgb_to_hsv</a> &mdash; Converts color values between the HSV and RGB color spaces.
<li><a href="#rotate_scaled_sprite">rotate_scaled_sprite</a> &mdash; Rotates and stretches a sprite.
<li><a href="#rotate_scaled_sprite_v_flip">rotate_scaled_sprite_v_flip</a> &mdash; Rotates, stretches and flips a sprite.
<li><a href="#rotate_sprite">rotate_sprite</a> &mdash; Rotates a sprite.
<li><a href="#rotate_sprite_v_flip">rotate_sprite_v_flip</a> &mdash; Rotates and flips a sprite.

</ul>
<h1 class='mini_toc' id='mini_toc_s1'><a href='#top'>s</a></h1>
<ul>
<li><a href="#save_bitmap">save_bitmap</a> &mdash; Saves a bitmap into any supported file format.
<li><a href="#save_bmp">save_bmp</a> &mdash; Saves a bitmap into a BMP file.
<li><a href="#save_bmp_pf">save_bmp_pf</a> &mdash; Packfile version of save_bmp.
<li><a href="#save_joystick_data">save_joystick_data</a> &mdash; Saves joystick calibration data.
<li><a href="#save_pcx">save_pcx</a> &mdash; Saves a bitmap into a PCX file.
<li><a href="#save_pcx_pf">save_pcx_pf</a> &mdash; Packfile version of save_pcx.
<li><a href="#save_sample">save_sample</a> &mdash; Writes a sample into a file.
<li><a href="#save_tga">save_tga</a> &mdash; Saves a bitmap into a TGA file.
<li><a href="#save_tga_pf">save_tga_pf</a> &mdash; Packfile version of save_tga.
<li><a href="#scancode_to_ascii">scancode_to_ascii</a> &mdash; Converts a scancode to an ASCII character.
<li><a href="#scancode_to_name">scancode_to_name</a> &mdash; Converts a scancode to a key name.
<li><a href="#scare_mouse">scare_mouse</a> &mdash; Helper for hiding the mouse pointer before drawing.
<li><a href="#scare_mouse_area">scare_mouse_area</a> &mdash; Helper for hiding the mouse cursor before drawing in an area.
<li><a href="#scene_gap">scene_gap</a> &mdash; Number controlling the scene z-sorting algorithm behaviour.
<li><a href="#scene_polygon3d">scene_polygon3d</a> &mdash; Puts a polygon in the scene rendering list.
<li><a href="#scene_polygon3d_f">scene_polygon3d_f</a> &mdash; Puts a polygon in the scene rendering list.
<li><a href="#screen">screen</a> &mdash; Global pointer to the screen hardware video memory.
<li><a href="#scroll_screen">scroll_screen</a> &mdash; Requests a hardware scroll request.
<li><a href="#select_mouse_cursor">select_mouse_cursor</a> &mdash; Tells Allegro to select software or hardware cursor drawing.
<li><a href="#select_palette">select_palette</a> &mdash; Sets the internal palette for color conversion.
<li><a href="#set_add_blender">set_add_blender</a> &mdash; Enables an additive blender mode.
<li><a href="#set_allegro_resource_path">set_allegro_resource_path</a> &mdash; Sets a specific resource search path.
<li><a href="#set_alpha_blender">set_alpha_blender</a> &mdash; Enables a special alpha-channel blending mode.
<li><a href="#set_blender_mode">set_blender_mode</a> &mdash; Specifies a custom set of truecolor blender routines.
<li><a href="#set_blender_mode_ex">set_blender_mode_ex</a> &mdash; An even more complex version of set_blender_mode().
<li><a href="#set_burn_blender">set_burn_blender</a> &mdash; Enables a burn blender mode.
<li><a href="#set_clip_rect">set_clip_rect</a> &mdash; Sets the clipping rectangle of a bitmap.
<li><a href="#set_clip_state">set_clip_state</a> &mdash; Turns on or off the clipping of a bitmap.
<li><a href="#set_close_button_callback">set_close_button_callback</a> &mdash; Handles the user clicking on the close button of the window.
<li><a href="#set_color">set_color</a> &mdash; Sets the specified palette entry to the specified RGB triplet.
<li><a href="#set_color_blender">set_color_blender</a> &mdash; Enables a color blender mode.
<li><a href="#set_color_conversion">set_color_conversion</a> &mdash; Tells Allegro how to convert images during loading time.
<li><a href="#set_color_depth">set_color_depth</a> &mdash; Sets the global pixel color depth.
<li><a href="#set_config_data">set_config_data</a> &mdash; Sets a block of configuration data.
<li><a href="#set_config_file">set_config_file</a> &mdash; Sets the configuration file.
<li><a href="#set_config_float">set_config_float</a> &mdash; Writes a float in the configuration file.
<li><a href="#set_config_hex">set_config_hex</a> &mdash; Writes a hexadecimal integer in the configuration file.
<li><a href="#set_config_id">set_config_id</a> &mdash; Writes a driver ID in the configuration file.
<li><a href="#set_config_int">set_config_int</a> &mdash; Writes an integer in the configuration file.
<li><a href="#set_config_string">set_config_string</a> &mdash; Writes a string in the configuration file.
<li><a href="#set_dialog_color">set_dialog_color</a> &mdash; Sets the colors of an array of dialog objects.
<li><a href="#set_difference_blender">set_difference_blender</a> &mdash; Enables a difference blender mode.
<li><a href="#set_display_switch_callback">set_display_switch_callback</a> &mdash; Installs a switching notification callback.
<li><a href="#set_display_switch_mode">set_display_switch_mode</a> &mdash; Tells Allegro how the program handles background switching.
<li><a href="#set_dissolve_blender">set_dissolve_blender</a> &mdash; Enables a dissolve blender mode.
<li><a href="#set_dodge_blender">set_dodge_blender</a> &mdash; Enables a dodge blender mode.
<li><a href="#set_gdi_color_format">set_gdi_color_format</a> &mdash; Tells Allegro to use the GDI color layout for truecolor images.
<li><a href="#set_gfx_mode">set_gfx_mode</a> &mdash; Sets a graphic video mode.
<li><a href="#set_hardware_volume">set_hardware_volume</a> &mdash; Alters the hardware sound output volume.
<li><a href="#set_hue_blender">set_hue_blender</a> &mdash; Enables a hue blender mode.
<li><a href="#set_invert_blender">set_invert_blender</a> &mdash; Enables an invert blender mode.
<li><a href="#set_keyboard_rate">set_keyboard_rate</a> &mdash; Sets the keyboard repeat rate.
<li><a href="#set_leds">set_leds</a> &mdash; Sets the state of the keyboard LED indicators.
<li><a href="#set_luminance_blender">set_luminance_blender</a> &mdash; Enables a luminance blender mode.
<li><a href="#set_mixer_quality">set_mixer_quality</a> &mdash; Sets the resampling quality of the mixer.
<li><a href="#set_mouse_cursor_bitmap">set_mouse_cursor_bitmap</a> &mdash; Changes the image Allegro uses for mouse cursors.
<li><a href="#set_mouse_range">set_mouse_range</a> &mdash; Sets the area of the screen restricting mouse movement.
<li><a href="#set_mouse_speed">set_mouse_speed</a> &mdash; Sets the mouse speed.
<li><a href="#set_mouse_sprite">set_mouse_sprite</a> &mdash; Sets the mouse sprite.
<li><a href="#set_mouse_sprite_focus">set_mouse_sprite_focus</a> &mdash; Sets the mouse sprite focus.
<li><a href="#set_multiply_blender">set_multiply_blender</a> &mdash; Enables a multiply blender mode.
<li><a href="#set_palette">set_palette</a> &mdash; Sets the entire palette of 256 colors.
<li><a href="#set_palette_range">set_palette_range</a> &mdash; Sets a specific range of the palette.
<li><a href="#set_palette_to_hdc">set_palette_to_hdc</a> &mdash; Selects and realizes a palette on the specified device context.
<li><a href="#set_projection_viewport">set_projection_viewport</a> &mdash; Sets the viewport used to scale the output of persp_project().
<li><a href="#set_saturation_blender">set_saturation_blender</a> &mdash; Enables a saturation blender mode.
<li><a href="#set_screen_blender">set_screen_blender</a> &mdash; Enables a screen blender mode.
<li><a href="#set_sound_input_source">set_sound_input_source</a> &mdash; Selects the audio input source.
<li><a href="#set_trans_blender">set_trans_blender</a> &mdash; Enables a truecolor blender.
<li><a href="#set_ucodepage">set_ucodepage</a> &mdash; Sets 8-bit to Unicode conversion tables.
<li><a href="#set_uformat">set_uformat</a> &mdash; Set the global current text encoding format.
<li><a href="#set_volume">set_volume</a> &mdash; Alters the global sound output volume.
<li><a href="#set_volume_per_voice">set_volume_per_voice</a> &mdash; Sets the volume of a voice.
<li><a href="#set_window_title">set_window_title</a> &mdash; Sets the window title of the Allegro program.
<li><a href="#set_write_alpha_blender">set_write_alpha_blender</a> &mdash; Enables the special alpha-channel editing mode.
<li><a href="#set_zbuffer">set_zbuffer</a> &mdash; Makes the given Z-buffer the active one.
<li><a href="#show_mouse">show_mouse</a> &mdash; Tells Allegro to display a mouse pointer on the screen.
<li><a href="#show_os_cursor">show_os_cursor</a> &mdash; Low level function to display the operating system cursor.
<li><a href="#show_video_bitmap">show_video_bitmap</a> &mdash; Flips the hardware screen to use the specified page.
<li><a href="#shutdown_dialog">shutdown_dialog</a> &mdash; Destroys a dialog player returned by init_dialog().
<li><a href="#shutdown_menu">shutdown_menu</a> &mdash; Destroys a menu player object returned by init_menu().
<li><a href="#simulate_keypress">simulate_keypress</a> &mdash; Stuffs a key into the keyboard buffer.
<li><a href="#simulate_ukeypress">simulate_ukeypress</a> &mdash; Stuffs an unicode key into the keyboard buffer.
<li><a href="#solid_mode">solid_mode</a> &mdash; Shortcut for selecting solid drawing mode.
<li><a href="#spline">spline</a> &mdash; Draws a Bezier spline using four control points.
<li><a href="#start_sound_input">start_sound_input</a> &mdash; Starts recording in the specified format.
<li><a href="#stop_audio_stream">stop_audio_stream</a> &mdash; Destroys an audio stream when it is no longer required.
<li><a href="#stop_midi">stop_midi</a> &mdash; Stops whatever music is currently playing.
<li><a href="#stop_sample">stop_sample</a> &mdash; Stops a sample from playing.
<li><a href="#stop_sound_input">stop_sound_input</a> &mdash; Stops audio recording.
<li><a href="#stretch_blit">stretch_blit</a> &mdash; Scales a rectangular area from one bitmap to another.
<li><a href="#stretch_blit_from_hdc">stretch_blit_from_hdc</a> &mdash; Blits from a Windows device context to an Allegro memory bitmap.
<li><a href="#stretch_blit_to_hdc">stretch_blit_to_hdc</a> &mdash; Blits an Allegro memory bitmap to a Windows device context.
<li><a href="#stretch_sprite">stretch_sprite</a> &mdash; Stretches a sprite to the destination bitmap.

</ul>
<h1 class='mini_toc' id='mini_toc_t1'><a href='#top'>t</a></h1>
<ul>
<li><a href="#text_height">text_height</a> &mdash; Returns the height of a font in pixels.
<li><a href="#text_length">text_length</a> &mdash; Returns the length of a string in pixels.
<li><a href="#textout_centre_ex">textout_centre_ex</a> &mdash; Writes a centered string on a bitmap.
<li><a href="#textout_ex">textout_ex</a> &mdash; Writes a string on a bitmap.
<li><a href="#textout_justify_ex">textout_justify_ex</a> &mdash; Draws justified text within a region.
<li><a href="#textout_right_ex">textout_right_ex</a> &mdash; Writes a right aligned string on a bitmap.
<li><a href="#textprintf_centre_ex">textprintf_centre_ex</a> &mdash; Formatted centered output of a string.
<li><a href="#textprintf_ex">textprintf_ex</a> &mdash; Formatted output of a string.
<li><a href="#textprintf_justify_ex">textprintf_justify_ex</a> &mdash; Formatted justified output of a string.
<li><a href="#textprintf_right_ex">textprintf_right_ex</a> &mdash; Formatted right aligned output of a string.
<li><a href="#three_finger_flag">three_finger_flag</a> &mdash; Flag to deactivate the emergency exit key combination.
<li><a href="#transpose_font">transpose_font</a> &mdash; Transposes all characters in a font.
<li><a href="#triangle">triangle</a> &mdash; Draws a filled triangle.
<li><a href="#triangle3d">triangle3d</a> &mdash; Draws a 3d triangle onto the specified bitmap.
<li><a href="#triangle3d_f">triangle3d_f</a> &mdash; Draws a 3d triangle onto the specified bitmap.

</ul>
<h1 class='mini_toc' id='mini_toc_u1'><a href='#top'>u</a></h1>
<ul>
<li><a href="#uatof">uatof</a> &mdash; Converts a string into a double.
<li><a href="#uconvert">uconvert</a> &mdash; High level string encoding conversion wrapper.
<li><a href="#uconvert_ascii">uconvert_ascii</a> &mdash; Converts string from ASCII into the current format.
<li><a href="#uconvert_size">uconvert_size</a> &mdash; Number of bytes needed to store a string after conversion.
<li><a href="#uconvert_toascii">uconvert_toascii</a> &mdash; Converts strings from the current format into ASCII.
<li><a href="#ucwidth">ucwidth</a> &mdash; Low level helper function for testing Unicode text data.
<li><a href="#ugetat">ugetat</a> &mdash; Finds out the value of a character in a string.
<li><a href="#ugetc">ugetc</a> &mdash; Low level helper function for reading Unicode text data.
<li><a href="#ugetx">ugetx</a> &mdash; Low level helper function for reading Unicode text data.
<li><a href="#ugetxc">ugetxc</a> &mdash; Low level helper function for reading Unicode text data.
<li><a href="#uinsert">uinsert</a> &mdash; Inserts a character in a string.
<li><a href="#uisdigit">uisdigit</a> &mdash; Tells if a character is a digit.
<li><a href="#uisok">uisok</a> &mdash; Low level helper function for testing Unicode text data.
<li><a href="#uisspace">uisspace</a> &mdash; Tells if a character is whitespace.
<li><a href="#unload_datafile">unload_datafile</a> &mdash; Frees all the objects in a datafile.
<li><a href="#unload_datafile_object">unload_datafile_object</a> &mdash; Frees an object previously loaded by load_datafile_object().
<li><a href="#unscare_mouse">unscare_mouse</a> &mdash; Undoes the effect of scare_mouse() or scare_mouse_area().
<li><a href="#unselect_palette">unselect_palette</a> &mdash; Restores the palette before last call to select_palette().
<li><a href="#uoffset">uoffset</a> &mdash; Finds the offset of a character in a string.
<li><a href="#update_dialog">update_dialog</a> &mdash; Low level function to update a dialog player.
<li><a href="#update_menu">update_menu</a> &mdash; Low level function to update a menu player.
<li><a href="#ureadkey">ureadkey</a> &mdash; Returns the next unicode character from the keyboard buffer.
<li><a href="#uremove">uremove</a> &mdash; Removes a character from a string.
<li><a href="#usetat">usetat</a> &mdash; Replaces a character in a string.
<li><a href="#usetc">usetc</a> &mdash; Low level helper function for writing Unicode text data.
<li><a href="#usprintf">usprintf</a> &mdash; Writes formatted data into a buffer.
<li><a href="#ustrcat">ustrcat</a> &mdash; Concatenates a string to another one.
<li><a href="#ustrchr">ustrchr</a> &mdash; Finds the first occurrence of a character in a string.
<li><a href="#ustrcmp">ustrcmp</a> &mdash; Compares two strings.
<li><a href="#ustrcpy">ustrcpy</a> &mdash; Copies a string into another one.
<li><a href="#ustrdup">ustrdup</a> &mdash; Duplicates a string.
<li><a href="#ustrerror">ustrerror</a> &mdash; Returns a string describing errno.
<li><a href="#ustricmp">ustricmp</a> &mdash; Compares two strings ignoring case.
<li><a href="#ustrlen">ustrlen</a> &mdash; Tells the number of characters in a string.
<li><a href="#ustrlwr">ustrlwr</a> &mdash; Replaces all letters with lower case.
<li><a href="#ustrncat">ustrncat</a> &mdash; Concatenates a string to another one, specifying size.
<li><a href="#ustrncmp">ustrncmp</a> &mdash; Compares up to n letters of two strings.
<li><a href="#ustrncpy">ustrncpy</a> &mdash; Copies a string into another one, specifying size.
<li><a href="#ustrnicmp">ustrnicmp</a> &mdash; Compares up to n letters of two strings ignoring case.
<li><a href="#ustrpbrk">ustrpbrk</a> &mdash; Finds the first character that matches any in a set.
<li><a href="#ustrrchr">ustrrchr</a> &mdash; Finds the last occurrence of a character in a string.
<li><a href="#ustrsize">ustrsize</a> &mdash; Size of the string in bytes without null terminator.
<li><a href="#ustrsizez">ustrsizez</a> &mdash; Size of the string in bytes including null terminator.
<li><a href="#ustrstr">ustrstr</a> &mdash; Finds the first occurrence of a string in another one.
<li><a href="#ustrtod">ustrtod</a> &mdash; Converts a string into a floating point number.
<li><a href="#ustrtok">ustrtok</a> &mdash; Retrieves tokens from a string.
<li><a href="#ustrtok_r">ustrtok_r</a> &mdash; Reentrant function to retrieve tokens from a string.
<li><a href="#ustrtol">ustrtol</a> &mdash; Converts a string into an integer.
<li><a href="#ustrupr">ustrupr</a> &mdash; Replaces all letters with upper case.
<li><a href="#ustrzcat">ustrzcat</a> &mdash; Concatenates a string to another one, specifying size.
<li><a href="#ustrzcpy">ustrzcpy</a> &mdash; Copies a string into another one, specifying size.
<li><a href="#ustrzncat">ustrzncat</a> &mdash; Concatenates a string to another one, specifying size.
<li><a href="#ustrzncpy">ustrzncpy</a> &mdash; Copies a string into another one, specifying size.
<li><a href="#uszprintf">uszprintf</a> &mdash; Writes formatted data into a buffer, specifying size.
<li><a href="#utolower">utolower</a> &mdash; Converts a letter to lower case.
<li><a href="#utoupper">utoupper</a> &mdash; Converts a letter to upper case.
<li><a href="#uvsprintf">uvsprintf</a> &mdash; Writes formatted data into a buffer, using variable arguments.
<li><a href="#uvszprintf">uvszprintf</a> &mdash; Writes formatted data into a buffer, using size and variable arguments.
<li><a href="#uwidth">uwidth</a> &mdash; Low level helper function for testing Unicode text data.
<li><a href="#uwidth_max">uwidth_max</a> &mdash; Number of bytes a character can occupy.

</ul>
<h1 class='mini_toc' id='mini_toc_v1'><a href='#top'>v</a></h1>
<ul>
<li><a href="#vector_length">vector_length</a> &mdash; Calculates the length of a vector.
<li><a href="#vector_length_f">vector_length_f</a> &mdash; Calculates the length of a vector.
<li><a href="#vline">vline</a> &mdash; Draws a vertical line onto the bitmap.
<li><a href="#voice_check">voice_check</a> &mdash; Checks whether a voice is currently allocated.
<li><a href="#voice_get_frequency">voice_get_frequency</a> &mdash; Returns the current pitch of the voice.
<li><a href="#voice_get_pan">voice_get_pan</a> &mdash; Returns the current pan position.
<li><a href="#voice_get_position">voice_get_position</a> &mdash; Returns the current position of a voice.
<li><a href="#voice_get_volume">voice_get_volume</a> &mdash; Returns the current volume of the voice.
<li><a href="#voice_ramp_volume">voice_ramp_volume</a> &mdash; Starts a volume ramp for a voice.
<li><a href="#voice_set_echo">voice_set_echo</a> &mdash; Sets the echo parameters for a voice.
<li><a href="#voice_set_frequency">voice_set_frequency</a> &mdash; Sets the pitch of the voice.
<li><a href="#voice_set_pan">voice_set_pan</a> &mdash; Sets the pan position.
<li><a href="#voice_set_playmode">voice_set_playmode</a> &mdash; Adjusts the loop status of the specified voice.
<li><a href="#voice_set_position">voice_set_position</a> &mdash; Sets the position of a voice.
<li><a href="#voice_set_priority">voice_set_priority</a> &mdash; Sets the priority of a voice.
<li><a href="#voice_set_tremolo">voice_set_tremolo</a> &mdash; Sets the tremolo parameters for a voice.
<li><a href="#voice_set_vibrato">voice_set_vibrato</a> &mdash; Sets the vibrato parameters for a voice.
<li><a href="#voice_set_volume">voice_set_volume</a> &mdash; Sets the volume of the voice.
<li><a href="#voice_start">voice_start</a> &mdash; Activates a voice.
<li><a href="#voice_stop">voice_stop</a> &mdash; Stops a voice.
<li><a href="#voice_stop_frequency_sweep">voice_stop_frequency_sweep</a> &mdash; Interrupts a frequency sweep operation.
<li><a href="#voice_stop_pan_sweep">voice_stop_pan_sweep</a> &mdash; Interrupts a pan sweep operation.
<li><a href="#voice_stop_volumeramp">voice_stop_volumeramp</a> &mdash; Interrupts a volume ramp operation.
<li><a href="#voice_sweep_frequency">voice_sweep_frequency</a> &mdash; Starts a frequency sweep for a voice.
<li><a href="#voice_sweep_pan">voice_sweep_pan</a> &mdash; Starts a pan sweep for a voice.
<li><a href="#vsync">vsync</a> &mdash; Waits for a vertical retrace to begin.

</ul>
<h1 class='mini_toc' id='mini_toc_w1'><a href='#top'>w</a></h1>
<ul>
<li><a href="#win_get_dc">win_get_dc</a> &mdash; Retrieves a handle to the device context.
<li><a href="#win_get_window">win_get_window</a> &mdash; Retrieves a handle to the window used by Allegro.
<li><a href="#win_release_dc">win_release_dc</a> &mdash; Releases a handle to the device context.
<li><a href="#win_set_window">win_set_window</a> &mdash; Registers an user-created window to be used by Allegro.
<li><a href="#win_set_wnd_create_proc">win_set_wnd_create_proc</a> &mdash; Registers a custom procedure to be used by Allegro for creating its window.

</ul>
<h1 class='mini_toc' id='mini_toc_x1'><a href='#top'>x</a></h1>
<ul>
<li><a href="#xor_mode">xor_mode</a> &mdash; Shortcut for toggling xor drawing mode on and off.
<li><a href="#xwin_set_window_name">xwin_set_window_name</a> &mdash; Specify the window name and group (or class).
</ul>



</body>
</html>
